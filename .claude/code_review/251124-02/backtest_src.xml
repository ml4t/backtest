<?xml version="1.0" encoding="UTF-8"?>
<codebase>
  <metadata>
    <package>ml4t.backtest</package>
    <version>0.2.0</version>
    <file_count>33</file_count>
  </metadata>
  <files>
    <file path="ml4t/backtest/__init__.py">
      <![CDATA["""ml4t.backtest - Minimal event-driven backtesting engine.

A clean, extensible backtesting engine with:
- Multi-asset support
- Polars-first data handling
- Pluggable commission/slippage models
- Same-bar and next-bar execution modes
- Live trading compatible interface
"""

__version__ = "0.2.0"

# Import from modules
# Analytics
from .analytics import (
    EquityCurve,
    TradeAnalyzer,
    cagr,
    calmar_ratio,
    max_drawdown,
    sharpe_ratio,
    sortino_ratio,
    volatility,
)
from .broker import Broker

# Calendar functions (pandas_market_calendars integration)
from .calendar import (
    CALENDAR_ALIASES,
    filter_to_trading_days,
    filter_to_trading_sessions,
    generate_trading_minutes,
    get_calendar,
    get_early_closes,
    get_holidays,
    get_schedule,
    get_trading_days,
    is_market_open,
    is_trading_day,
    list_calendars,
    next_trading_day,
    previous_trading_day,
)
from .config import (
    PRESETS_DIR,
    BacktestConfig,
    DataFrequency,
    ExecutionPrice,
    FillTiming,
    ShareType,
    SignalProcessing,
    SizingMethod,
)
from .config import (
    CommissionModel as CommissionModelType,
)
from .config import (
    SlippageModel as SlippageModelType,
)
from .datafeed import DataFeed
from .engine import BacktestEngine, Engine, run_backtest

# Execution model (volume limits, market impact, rebalancing)
from .execution import (
    ExecutionLimits,
    ExecutionResult,
    LinearImpact,
    MarketImpactModel,
    NoImpact,
    NoLimits,
    RebalanceConfig,
    SquareRootImpact,
    TargetWeightExecutor,
    VolumeParticipationLimit,
)
from .models import (
    CombinedCommission,
    CommissionModel,
    FixedSlippage,
    NoCommission,
    NoSlippage,
    PercentageCommission,
    PercentageSlippage,
    PerShareCommission,
    SlippageModel,
    TieredCommission,
    VolumeShareSlippage,
)
from .strategy import Strategy
from .types import (
    AssetClass,
    ContractSpec,
    ExecutionMode,
    Fill,
    Order,
    OrderSide,
    OrderStatus,
    OrderType,
    Position,
    StopFillMode,
    StopLevelBasis,
    Trade,
)

__all__ = [
    # Types
    "AssetClass",
    "ContractSpec",
    "OrderType",
    "OrderSide",
    "OrderStatus",
    "ExecutionMode",
    "StopFillMode",
    "StopLevelBasis",
    "Order",
    "Position",
    "Fill",
    "Trade",
    # Models
    "CommissionModel",
    "SlippageModel",
    "NoCommission",
    "PercentageCommission",
    "PerShareCommission",
    "TieredCommission",
    "CombinedCommission",
    "NoSlippage",
    "FixedSlippage",
    "PercentageSlippage",
    "VolumeShareSlippage",
    # Core
    "DataFeed",
    "Broker",
    "Strategy",
    "Engine",
    "BacktestEngine",  # Backward compatibility alias
    "run_backtest",
    # Configuration
    "BacktestConfig",
    "DataFrequency",
    "FillTiming",
    "ExecutionPrice",
    "ShareType",
    "SizingMethod",
    "SignalProcessing",
    "CommissionModelType",
    "SlippageModelType",
    "PRESETS_DIR",
    # Analytics
    "EquityCurve",
    "TradeAnalyzer",
    "sharpe_ratio",
    "sortino_ratio",
    "calmar_ratio",
    "max_drawdown",
    "cagr",
    "volatility",
    # Calendar functions
    "CALENDAR_ALIASES",
    "get_calendar",
    "get_schedule",
    "get_trading_days",
    "is_trading_day",
    "is_market_open",
    "next_trading_day",
    "previous_trading_day",
    "list_calendars",
    "get_holidays",
    "get_early_closes",
    "filter_to_trading_days",
    "filter_to_trading_sessions",
    "generate_trading_minutes",
    # Execution model
    "ExecutionLimits",
    "NoLimits",
    "VolumeParticipationLimit",
    "MarketImpactModel",
    "NoImpact",
    "LinearImpact",
    "SquareRootImpact",
    "ExecutionResult",
    # Rebalancing
    "RebalanceConfig",
    "TargetWeightExecutor",
]
]]>
    </file>
    <file path="ml4t/backtest/accounting/__init__.py">
      <![CDATA["""Accounting module for backtesting engine.

Provides proper accounting constraints for both cash accounts (no leverage, no shorts)
and margin accounts (leverage enabled, shorts allowed).

Key Components:
- Position: Unified position tracking (from types module)
- AccountPolicy: Interface for account type constraints
- CashAccountPolicy: Cash account constraints (cash &gt;= 0, no shorts)
- MarginAccountPolicy: Margin account constraints (NLV/BP/MM calculations)
- AccountState: Account state management and position tracking
- Gatekeeper: Order validation before execution
"""

from ..types import Position
from .account import AccountState
from .gatekeeper import Gatekeeper
from .policy import AccountPolicy, CashAccountPolicy, MarginAccountPolicy

__all__ = [
    "Position",
    "AccountPolicy",
    "CashAccountPolicy",
    "MarginAccountPolicy",
    "AccountState",
    "Gatekeeper",
]
]]>
    </file>
    <file path="ml4t/backtest/accounting/account.py">
      <![CDATA["""Account state management.

This module provides the AccountState class that tracks cash, positions, and
delegates validation to the appropriate AccountPolicy.
"""

from ..types import Position
from .policy import AccountPolicy


class AccountState:
    """Account state ledger with policy-based constraints.

    AccountState is the central ledger that tracks:
    - Cash balance
    - Open positions
    - Account policy (cash vs margin)

    It delegates all validation and constraint checking to the AccountPolicy,
    making it easy to support different account types.

    Example:
        &gt;&gt;&gt; from ml4t.backtest.accounting import AccountState, CashAccountPolicy
        &gt;&gt;&gt; policy = CashAccountPolicy()
        &gt;&gt;&gt; account = AccountState(initial_cash=100000.0, policy=policy)
        &gt;&gt;&gt; account.buying_power
        100000.0
    """

    def __init__(self, initial_cash: float, policy: AccountPolicy):
        """Initialize account state.

        Args:
            initial_cash: Starting cash balance
            policy: AccountPolicy instance (CashAccountPolicy or MarginAccountPolicy)
        """
        self.cash = initial_cash
        self.positions: dict[str, Position] = {}
        self.policy = policy

    @property
    def total_equity(self) -&gt; float:
        """Calculate total account equity (Net Liquidating Value).

        For both cash and margin accounts:
            NLV = Cash + Σ(position.market_value)

        Returns:
            Total account equity
        """
        return self.cash + sum(p.market_value for p in self.positions.values())

    @property
    def buying_power(self) -&gt; float:
        """Calculate available buying power for new long positions.

        Delegates to policy:
        - Cash account: buying_power = max(0, cash)
        - Margin account: buying_power = (NLV - MM) / initial_margin_rate

        Returns:
            Available buying power in dollars
        """
        return self.policy.calculate_buying_power(self.cash, self.positions)

    def allows_short_selling(self) -&gt; bool:
        """Check if short selling is allowed.

        Delegates to policy:
        - Cash account: False
        - Margin account: True

        Returns:
            True if short selling allowed, False otherwise
        """
        return self.policy.allows_short_selling()

    def mark_to_market(self, current_prices: dict[str, float]) -&gt; None:
        """Update positions with current market prices.

        This is called at the end of each bar to update unrealized P&amp;L.

        Args:
            current_prices: Dictionary mapping asset -&gt; current_price
        """
        for asset, position in self.positions.items():
            if asset in current_prices:
                position.current_price = current_prices[asset]

    def get_position(self, asset: str) -&gt; Position | None:
        """Get position for a specific asset.

        Args:
            asset: Asset identifier

        Returns:
            Position object if exists, None otherwise
        """
        return self.positions.get(asset)

    def get_position_quantity(self, asset: str) -&gt; float:
        """Get quantity for a specific asset (0 if no position).

        Args:
            asset: Asset identifier

        Returns:
            Position quantity (positive=long, negative=short, 0=flat)
        """
        pos = self.positions.get(asset)
        return pos.quantity if pos else 0.0

    def apply_fill(self, asset: str, quantity_delta: float, fill_price: float, timestamp) -&gt; float:
        """Apply a fill to the account, updating position and cash.

        This method handles both long and short positions correctly:
        - Long positions (quantity &gt; 0): Cash decreases when buying, increases when selling
        - Short positions (quantity &lt; 0): Cash increases when shorting, decreases when covering

        Args:
            asset: Asset identifier
            quantity_delta: Signed quantity change (positive=buy, negative=sell/short)
            fill_price: Fill price per unit
            timestamp: Fill timestamp

        Returns:
            Cash change (positive=cash in, negative=cash out)

        Examples:
            Open long (buy 100 @ $150):
                quantity_delta=+100, fill_price=$150
                cash_change = -$15,000 (paid to buy)

            Close long (sell 100 @ $160):
                quantity_delta=-100, fill_price=$160
                cash_change = +$16,000 (received from sale)

            Open short (sell 100 @ $150):
                quantity_delta=-100, fill_price=$150
                cash_change = +$15,000 (proceeds from short sale)

            Close short (buy 100 @ $145):
                quantity_delta=+100, fill_price=$145
                cash_change = -$14,500 (paid to cover short)

        Note:
            Commission should be handled separately by the caller.
            This method only handles the asset position and base cash flow.
        """

        # Calculate cash flow: negative for buys, positive for sells/shorts
        # Formula: cash_change = -quantity_delta × fill_price
        # Works for both longs and shorts:
        #   - Buy (quantity_delta &gt; 0): cash decreases (negative change)
        #   - Sell/Short (quantity_delta &lt; 0): cash increases (positive change)
        cash_change = -quantity_delta * fill_price

        # Update cash balance
        self.cash += cash_change

        # Update position
        pos = self.positions.get(asset)
        if pos is None:
            # New position (long or short)
            if quantity_delta != 0:
                self.positions[asset] = Position(
                    asset=asset,
                    quantity=quantity_delta,
                    entry_price=fill_price,
                    current_price=fill_price,
                    entry_time=timestamp,
                    bars_held=0,
                )
        else:
            # Existing position - update quantity and cost basis
            old_qty = pos.quantity
            new_qty = old_qty + quantity_delta

            if new_qty == 0:
                # Position fully closed
                del self.positions[asset]
            elif (old_qty &gt; 0 and new_qty &lt; 0) or (old_qty &lt; 0 and new_qty &gt; 0):
                # Position reversal (long → short or short → long)
                # Close old position, open new position in opposite direction
                del self.positions[asset]
                self.positions[asset] = Position(
                    asset=asset,
                    quantity=new_qty,
                    entry_price=fill_price,
                    current_price=fill_price,
                    entry_time=timestamp,
                    bars_held=0,
                )
            elif abs(new_qty) &gt; abs(old_qty):
                # Adding to existing position (same direction)
                # Update weighted average entry price
                old_cost = abs(old_qty) * pos.entry_price
                new_cost = abs(quantity_delta) * fill_price
                total_cost = old_cost + new_cost
                pos.entry_price = total_cost / abs(new_qty)
                pos.quantity = new_qty
            else:
                # Partial close (reducing position size)
                # Entry price remains unchanged for partial closes
                pos.quantity = new_qty

        return cash_change

    def __repr__(self) -&gt; str:
        """String representation for debugging."""
        policy_name = self.policy.__class__.__name__
        num_positions = len(self.positions)
        return (
            f"AccountState("
            f"cash=${self.cash:,.2f}, "
            f"equity=${self.total_equity:,.2f}, "
            f"positions={num_positions}, "
            f"policy={policy_name})"
        )
]]>
    </file>
    <file path="ml4t/backtest/accounting/gatekeeper.py">
      <![CDATA["""Order validation gatekeeper.

This module provides the Gatekeeper class that validates orders before execution,
ensuring they meet account policy constraints and preventing invalid trades.
"""

from ..models import CommissionModel
from ..types import Order, OrderSide
from .account import AccountState


class Gatekeeper:
    """Pre-execution order validation to enforce account constraints.

    The Gatekeeper is the critical component that prevents invalid orders from
    executing. It checks account policy constraints (cash limits, short selling,
    margin requirements) BEFORE orders are filled.

    Key Responsibilities:
    - Validate orders against account policy constraints
    - Distinguish reducing (exit) orders from opening (entry) orders
    - Include commission in cost calculations
    - Prevent unlimited debt bug (line 587 in engine.py)

    Example:
        &gt;&gt;&gt; from ml4t.backtest.accounting import AccountState, CashAccountPolicy, Gatekeeper
        &gt;&gt;&gt; from ml4t.backtest.engine import Order, OrderSide, OrderType, PercentageCommission
        &gt;&gt;&gt; policy = CashAccountPolicy()
        &gt;&gt;&gt; account = AccountState(initial_cash=100000.0, policy=policy)
        &gt;&gt;&gt; commission_model = PercentageCommission(rate=0.001)
        &gt;&gt;&gt; gatekeeper = Gatekeeper(account, commission_model)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Validate a buy order
        &gt;&gt;&gt; order = Order(asset="AAPL", side=OrderSide.BUY, quantity=100)
        &gt;&gt;&gt; valid, reason = gatekeeper.validate_order(order, price=150.0)
        &gt;&gt;&gt; print(valid)  # True (have enough cash)
    """

    def __init__(self, account: AccountState, commission_model: CommissionModel):
        """Initialize gatekeeper with account and commission model.

        Args:
            account: AccountState instance to validate against
            commission_model: CommissionModel for calculating transaction costs
        """
        self.account = account
        self.commission_model = commission_model

    def validate_order(self, order: Order, price: float) -&gt; tuple[bool, str]:
        """Validate order before execution.

        This is the main validation entry point called by the Broker before
        executing any order. It performs the following checks:

        1. Detect position reversals (long→short or short→long)
        2. Check if order is reducing existing position
        3. Reducing orders always approved (closing positions frees capital)
        4. Opening orders and reversals validated via account policy
        5. Commission included in cost calculation

        Args:
            order: Order to validate
            price: Expected fill price

        Returns:
            (is_valid, rejection_reason) tuple:
                - is_valid: True if order can proceed, False if rejected
                - rejection_reason: Human-readable explanation (empty if valid)

        Examples:
            Reducing order (always approved):
                &gt;&gt;&gt; # Current: Long 100 shares, Order: Sell 50
                &gt;&gt;&gt; valid, reason = gatekeeper.validate_order(sell_order, 150.0)
                &gt;&gt;&gt; assert valid == True
                &gt;&gt;&gt; assert reason == ""

            Position reversal (cash account):
                &gt;&gt;&gt; # Current: Long 100, Order: Sell 150 (reverse to short 50)
                &gt;&gt;&gt; valid, reason = gatekeeper.validate_order(sell_order, 150.0)
                &gt;&gt;&gt; assert valid == False
                &gt;&gt;&gt; assert "Position reversal not allowed" in reason

            Position reversal (margin account):
                &gt;&gt;&gt; # Current: Long 100, Order: Sell 150 (reverse to short 50)
                &gt;&gt;&gt; valid, reason = gatekeeper.validate_order(sell_order, 150.0)
                &gt;&gt;&gt; # valid depends on buying power for new short 50 position

            Opening order (validated):
                &gt;&gt;&gt; # No position, Order: Buy 100 shares @ $150
                &gt;&gt;&gt; valid, reason = gatekeeper.validate_order(buy_order, 150.0)
                &gt;&gt;&gt; # valid depends on cash: need $15,000 + commission

            Rejected order:
                &gt;&gt;&gt; # Cash account trying to short
                &gt;&gt;&gt; short_order = Order(asset="AAPL", side=OrderSide.SELL, quantity=100)
                &gt;&gt;&gt; valid, reason = gatekeeper.validate_order(short_order, 150.0)
                &gt;&gt;&gt; assert valid == False
                &gt;&gt;&gt; assert "Short selling not allowed" in reason
        """
        # Get current position quantity (0 if no position)
        current_qty = self.account.get_position_quantity(order.asset)

        # Determine order direction (positive=buy, negative=sell)
        order_qty_delta = self._calculate_quantity_delta(order.side, order.quantity)

        # Check for position reversal (long→short or short→long)
        # This is a special case that requires different validation
        if self._is_reversal(current_qty, order_qty_delta):
            # Cash accounts don't allow reversals (no short selling)
            if not self.account.policy.allows_short_selling():
                return False, "Position reversal not allowed in cash account"

            # Margin accounts: Reversal is conceptually split into:
            # 1. Close existing position (always approved - reduces risk)
            # 2. Open new opposite position (must validate buying power)
            #
            # We validate via validate_position_change which correctly handles
            # the buying power requirement for the new opposite position
            commission = self.commission_model.calculate(order.asset, order.quantity, price)
            return self.account.policy.validate_position_change(
                asset=order.asset,
                current_quantity=current_qty,
                quantity_delta=order_qty_delta,
                price=price,
                current_positions=self.account.positions,
                cash=self.account.cash - commission,
            )

        # Check if this is a reducing order (closing/reducing existing position)
        if self._is_reducing_order(current_qty, order_qty_delta):
            # Reducing orders always allowed (frees up capital)
            return True, ""

        # This is an opening order (new position or adding to existing)
        # Calculate commission to include in cost
        commission = self.commission_model.calculate(order.asset, order.quantity, price)

        # Validate based on whether we have an existing position
        if current_qty == 0.0:
            # New position - use validate_new_position
            new_qty = order_qty_delta  # Full order quantity
            return self.account.policy.validate_new_position(
                asset=order.asset,
                quantity=new_qty,
                price=price,
                current_positions=self.account.positions,
                cash=self.account.cash - commission,  # Account for commission cost
            )
        else:
            # Adding to existing position - use validate_position_change
            return self.account.policy.validate_position_change(
                asset=order.asset,
                current_quantity=current_qty,
                quantity_delta=order_qty_delta,
                price=price,
                current_positions=self.account.positions,
                cash=self.account.cash - commission,  # Account for commission cost
            )

    def _is_reversal(self, current_qty: float, order_qty_delta: float) -&gt; bool:
        """Check if order reverses position (long → short or short → long).

        A reversal occurs when an order causes the position to change sign,
        creating a new opposite position. This is distinct from simply closing
        a position (where the result would be zero or same sign).

        Args:
            current_qty: Current position quantity (positive=long, negative=short)
            order_qty_delta: Order quantity delta (positive=buy, negative=sell)

        Returns:
            True if order reverses position, False otherwise

        Examples:
            Reversals (returns True):
                &gt;&gt;&gt; gatekeeper._is_reversal(100, -150)  # Long 100, sell 150 → short 50
                True
                &gt;&gt;&gt; gatekeeper._is_reversal(-100, 150)  # Short 100, buy 150 → long 50
                True

            Non-reversals (returns False):
                &gt;&gt;&gt; gatekeeper._is_reversal(0, 100)     # No position, buy 100
                False
                &gt;&gt;&gt; gatekeeper._is_reversal(100, -100)  # Long 100, sell 100 → flat
                False
                &gt;&gt;&gt; gatekeeper._is_reversal(100, -50)   # Long 100, sell 50 → long 50
                False
                &gt;&gt;&gt; gatekeeper._is_reversal(100, 50)    # Long 100, buy 50 → long 150
                False

        Note:
            Position reversals are only allowed in margin accounts. Cash accounts
            do not support short selling and therefore cannot have reversals.
        """
        if current_qty == 0.0:
            # No existing position - cannot reverse
            return False

        new_qty = current_qty + order_qty_delta

        # Check if signs differ between current and new position
        # (both must be non-zero for a true reversal)
        return (current_qty &gt; 0 and new_qty &lt; 0) or (current_qty &lt; 0 and new_qty &gt; 0)

    def _calculate_quantity_delta(self, side: OrderSide, quantity: float) -&gt; float:
        """Convert order side and quantity to signed delta.

        Args:
            side: BUY or SELL
            quantity: Order quantity (always positive)

        Returns:
            Signed quantity delta (positive=buy, negative=sell)

        Examples:
            &gt;&gt;&gt; gatekeeper._calculate_quantity_delta(OrderSide.BUY, 100)
            100.0
            &gt;&gt;&gt; gatekeeper._calculate_quantity_delta(OrderSide.SELL, 100)
            -100.0
        """
        return quantity if side == OrderSide.BUY else -quantity

    def _is_reducing_order(self, current_qty: float, order_qty_delta: float) -&gt; bool:
        """Check if order reduces existing position.

        A reducing order is one that moves the position closer to flat (zero).

        Args:
            current_qty: Current position quantity (positive=long, negative=short)
            order_qty_delta: Order quantity delta (positive=buy, negative=sell)

        Returns:
            True if order reduces position, False if opens/adds

        Examples:
            Reducing orders:
                &gt;&gt;&gt; gatekeeper._is_reducing_order(100, -50)  # Long 100, sell 50
                True
                &gt;&gt;&gt; gatekeeper._is_reducing_order(-100, 50)  # Short 100, buy 50
                True
                &gt;&gt;&gt; gatekeeper._is_reducing_order(100, -100)  # Closing
                True

            Opening/Adding orders:
                &gt;&gt;&gt; gatekeeper._is_reducing_order(0, 100)    # No position, buy
                False
                &gt;&gt;&gt; gatekeeper._is_reducing_order(100, 50)   # Long 100, buy more
                False
                &gt;&gt;&gt; gatekeeper._is_reducing_order(100, -150) # Reversal (long-&gt;short)
                False  # Not just reducing, this reverses position!

        Note:
            Position reversals (e.g., long 100 -&gt; short 50) are NOT reducing orders
            because they require opening a new short position. These must be validated.
        """
        if current_qty == 0.0:
            # No position - this is opening, not reducing
            return False

        # Check if order and position have opposite signs
        if current_qty &gt; 0 and order_qty_delta &lt; 0:
            # Long position, sell order - reducing if not reversing
            new_qty = current_qty + order_qty_delta
            return new_qty &gt;= 0  # True if still long or flat, False if reverses to short
        elif current_qty &lt; 0 and order_qty_delta &gt; 0:
            # Short position, buy order - reducing if not reversing
            new_qty = current_qty + order_qty_delta
            return new_qty &lt;= 0  # True if still short or flat, False if reverses to long
        else:
            # Same sign - this is adding to position, not reducing
            return False
]]>
    </file>
    <file path="ml4t/backtest/accounting/policy.py">
      <![CDATA["""Account policy implementations for different account types.

This module defines the AccountPolicy interface and implementations for cash
and margin accounts, enabling flexible constraint enforcement based on account type.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..types import Position


class AccountPolicy(ABC):
    """Abstract base class for account-specific trading constraints.

    Different account types (cash, margin, portfolio margin) have different rules
    for what trades are allowed. This interface defines the contract that all
    account policies must implement.

    The policy pattern allows the engine to support multiple account types without
    complex conditional logic or parallel systems.
    """

    @abstractmethod
    def calculate_buying_power(self, cash: float, positions: dict[str, Position]) -&gt; float:
        """Calculate available buying power for new long positions.

        Args:
            cash: Current cash balance (can be negative for margin accounts)
            positions: Dictionary of current positions {asset: Position}

        Returns:
            Available buying power in dollars. Must be &gt;= 0.

        Note:
            This is used to determine if a new BUY order can be placed.
            For cash accounts: buying_power = max(0, cash)
            For margin accounts: buying_power = (NLV - MM) / initial_margin_rate
        """
        pass

    @abstractmethod
    def allows_short_selling(self) -&gt; bool:
        """Whether this account type allows short selling.

        Returns:
            True if short selling is allowed, False otherwise.

        Note:
            Cash accounts: False (cannot short)
            Margin accounts: True (can short with margin requirements)
        """
        pass

    @abstractmethod
    def validate_new_position(
        self,
        asset: str,
        quantity: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -&gt; tuple[bool, str]:
        """Validate whether a new position can be opened.

        This is the core validation method called by the Gatekeeper before
        executing any order.

        Args:
            asset: Asset identifier (e.g., "AAPL")
            quantity: Desired position size (positive=long, negative=short)
            price: Expected fill price
            current_positions: Current positions {asset: Position}
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple:
                - is_valid: True if order can proceed, False if rejected
                - reason: Human-readable explanation (empty if valid)

        Examples:
            Cash account rejecting short:
                (False, "Short selling not allowed in cash account")

            Cash account rejecting insufficient funds:
                (False, "Insufficient cash: need $10,000, have $5,000")

            Margin account allowing trade:
                (True, "")

        Note:
            This method must be fast (called on every order). Keep validation
            logic simple and avoid unnecessary calculations.
        """
        pass

    @abstractmethod
    def validate_position_change(
        self,
        asset: str,
        current_quantity: float,
        quantity_delta: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -&gt; tuple[bool, str]:
        """Validate a change to an existing position.

        This handles adding to or reducing existing positions, including
        position reversals (long -&gt; short or short -&gt; long).

        Args:
            asset: Asset identifier
            current_quantity: Current position size (0 if no position)
            quantity_delta: Change in position (positive=buy, negative=sell)
            price: Expected fill price
            current_positions: All current positions
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple

        Examples:
            Adding to long position: current=100, delta=+50
            Closing long position: current=100, delta=-100
            Reversing position: current=100, delta=-200 (cash account rejects)

        Note:
            Position reversals (sign change) are particularly important for
            cash accounts, which must reject them.
        """
        pass


class CashAccountPolicy(AccountPolicy):
    """Account policy for cash accounts (no leverage, no shorts).

    Cash accounts are the simplest account type:
    - Cannot go negative (no borrowing)
    - Cannot short sell (no borrowing shares)
    - Buying power = available cash only
    - Position reversals not allowed (must close, then re-open)

    This is appropriate for:
    - Retail investors with no margin approval
    - Tax-advantaged accounts (IRA, 401k)
    - Conservative risk management
    """

    def calculate_buying_power(self, cash: float, positions: dict[str, Position]) -&gt; float:
        """Cash account buying power is simply positive cash balance.

        Args:
            cash: Current cash balance
            positions: Ignored for cash accounts

        Returns:
            max(0, cash) - Cannot use margin
        """
        return max(0.0, cash)

    def allows_short_selling(self) -&gt; bool:
        """Cash accounts cannot short sell.

        Returns:
            False - Short selling not allowed
        """
        return False

    def validate_new_position(
        self,
        asset: str,
        quantity: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -&gt; tuple[bool, str]:
        """Validate new position for cash account.

        Checks:
        1. No short positions (quantity must be &gt; 0)
        2. Sufficient cash to cover purchase

        Args:
            asset: Asset identifier
            quantity: Desired position size
            price: Expected fill price
            current_positions: Current positions (unused)
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple
        """
        # Check 1: No short selling
        if quantity &lt; 0:
            return False, "Short selling not allowed in cash account"

        # Check 2: Sufficient cash
        order_cost = quantity * price
        if order_cost &gt; cash:
            return (
                False,
                f"Insufficient cash: need ${order_cost:.2f}, have ${cash:.2f}",
            )

        return True, ""

    def validate_position_change(
        self,
        asset: str,
        current_quantity: float,
        quantity_delta: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -&gt; tuple[bool, str]:
        """Validate position change for cash account.

        Checks:
        1. No position reversals (sign change)
        2. For increases: sufficient cash
        3. For decreases: not exceeding current position

        Args:
            asset: Asset identifier
            current_quantity: Current position size (0 if none)
            quantity_delta: Change in position
            price: Expected fill price
            current_positions: All current positions
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple
        """
        new_quantity = current_quantity + quantity_delta

        # Check 1: No position reversals (long -&gt; short or short -&gt; long)
        if current_quantity != 0 and (
            (current_quantity &gt; 0 and new_quantity &lt; 0)
            or (current_quantity &lt; 0 and new_quantity &gt; 0)
        ):
            return (
                False,
                f"Position reversal not allowed in cash account "
                f"(current: {current_quantity:.2f}, delta: {quantity_delta:.2f})",
            )

        # Check 2: No short positions
        if new_quantity &lt; 0:
            return False, "Short positions not allowed in cash account"

        # Check 3: For increases (buying), check cash
        if quantity_delta &gt; 0:
            order_cost = quantity_delta * price
            if order_cost &gt; cash:
                return (
                    False,
                    f"Insufficient cash: need ${order_cost:.2f}, have ${cash:.2f}",
                )

        # Check 4: For decreases (selling), check position size
        if quantity_delta &lt; 0 and abs(quantity_delta) &gt; abs(current_quantity):
            return (
                False,
                f"Cannot sell {abs(quantity_delta):.2f}, only have {abs(current_quantity):.2f}",
            )

        return True, ""


class MarginAccountPolicy(AccountPolicy):
    """Account policy for margin accounts (leverage enabled, shorts allowed).

    Margin accounts enable more sophisticated trading strategies:
    - Can use leverage (borrow cash to increase buying power)
    - Can short sell (borrow shares to sell)
    - Buying power calculated from Net Liquidation Value and margin requirements
    - Subject to initial margin (IM) and maintenance margin (MM) requirements

    Key Formulas:
        NLV = cash + sum(position.market_value)
        MM = sum(abs(position.market_value) × maintenance_margin_rate)
        BP = (NLV - MM) / initial_margin_rate

    This is appropriate for:
    - Experienced traders with margin approval
    - Hedge funds and institutional accounts
    - Strategies requiring leverage or short selling
    - Market-neutral and pairs trading strategies

    Args:
        initial_margin: Initial margin requirement (default 0.5 = 50% = Reg T)
        maintenance_margin: Maintenance margin requirement (default 0.25 = 25%)

    Examples:
        &gt;&gt;&gt; # Standard Reg T margin (50% initial, 25% maintenance)
        &gt;&gt;&gt; policy = MarginAccountPolicy(initial_margin=0.5, maintenance_margin=0.25)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Conservative margin (100% initial = no leverage)
        &gt;&gt;&gt; policy = MarginAccountPolicy(initial_margin=1.0, maintenance_margin=0.5)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Aggressive margin (lower requirements)
        &gt;&gt;&gt; policy = MarginAccountPolicy(initial_margin=0.25, maintenance_margin=0.15)
    """

    def __init__(self, initial_margin: float = 0.5, maintenance_margin: float = 0.25) -&gt; None:
        """Initialize margin account policy.

        Args:
            initial_margin: Initial margin requirement (0.0-1.0)
                - 0.5 = 50% = Reg T standard (2x leverage)
                - 1.0 = 100% = no leverage
                - Lower values = more leverage (higher risk)

            maintenance_margin: Maintenance margin requirement (0.0-1.0)
                - 0.25 = 25% = Reg T standard
                - Must be &lt; initial_margin
                - Below this triggers margin call

        Raises:
            ValueError: If margin parameters are invalid
        """
        if not 0.0 &lt; initial_margin &lt;= 1.0:
            raise ValueError(f"Initial margin must be in (0.0, 1.0], got {initial_margin}")
        if not 0.0 &lt; maintenance_margin &lt;= 1.0:
            raise ValueError(f"Maintenance margin must be in (0.0, 1.0], got {maintenance_margin}")
        if maintenance_margin &gt;= initial_margin:
            raise ValueError(
                f"Maintenance margin ({maintenance_margin}) must be &lt; "
                f"initial margin ({initial_margin})"
            )

        self.initial_margin = initial_margin
        self.maintenance_margin = maintenance_margin

    def calculate_buying_power(self, cash: float, positions: dict[str, Position]) -&gt; float:
        """Calculate buying power for margin account.

        Formula:
            NLV = cash + sum(position.market_value for all positions)
            MM = sum(abs(position.market_value) × maintenance_margin for all positions)
            BP = (NLV - MM) / initial_margin

        Args:
            cash: Current cash balance (can be negative)
            positions: Dictionary of current positions {asset: Position}

        Returns:
            Available buying power in dollars. Can be negative if account is
            underwater (below maintenance margin).

        Examples:
            Cash only account (no positions):
                cash=$100k, positions={}
                NLV = $100k, MM = $0
                BP = ($100k - $0) / 0.5 = $200k (2x leverage)

            Long position:
                cash=$50k, long 1000 shares @ $100 = $100k market value
                NLV = $50k + $100k = $150k
                MM = $100k × 0.25 = $25k
                BP = ($150k - $25k) / 0.5 = $250k

            Short position:
                cash=$150k, short 1000 shares @ $100 = -$100k market value
                NLV = $150k + (-$100k) = $50k
                MM = |-$100k| × 0.25 = $25k
                BP = ($50k - $25k) / 0.5 = $50k

            Underwater account (margin call):
                cash=-$10k, long 1000 shares @ $50 = $50k market value
                NLV = -$10k + $50k = $40k
                MM = $50k × 0.25 = $12.5k
                BP = ($40k - $12.5k) / 0.5 = $55k
                (Still has buying power, but NLV &lt; initial investment)

        Note:
            Buying power can be negative if the account is severely underwater,
            indicating that positions must be liquidated to meet margin requirements.
        """
        # Calculate Net Liquidation Value (NLV)
        total_market_value = sum(pos.market_value for pos in positions.values())
        nlv = cash + total_market_value

        # Calculate Maintenance Margin requirement (MM)
        # Use absolute value because short positions have negative market value
        maintenance_margin_requirement = sum(
            abs(pos.market_value) * self.maintenance_margin for pos in positions.values()
        )

        # Calculate Buying Power (BP)
        # Available equity above maintenance margin, leveraged by initial margin
        buying_power = (nlv - maintenance_margin_requirement) / self.initial_margin

        return buying_power

    def allows_short_selling(self) -&gt; bool:
        """Margin accounts allow short selling.

        Returns:
            True - Short selling is allowed with appropriate margin
        """
        return True

    def validate_new_position(
        self,
        asset: str,
        quantity: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -&gt; tuple[bool, str]:
        """Validate new position for margin account.

        Checks:
        1. Sufficient buying power for the order
        2. Order doesn't create excessive leverage

        Args:
            asset: Asset identifier
            quantity: Desired position size (positive=long, negative=short)
            price: Expected fill price
            current_positions: Current positions
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple

        Note:
            Unlike cash accounts, margin accounts allow:
            - Short positions (negative quantity)
            - Negative cash (borrowing)
            - Multiple positions simultaneously
        """
        # Calculate order cost (positive for both long and short)
        order_cost = abs(quantity * price)

        # Calculate current buying power
        buying_power = self.calculate_buying_power(cash, current_positions)

        # Check: Sufficient buying power
        if order_cost &gt; buying_power:
            return (
                False,
                f"Insufficient buying power: need ${order_cost:.2f}, "
                f"have ${buying_power:.2f} (IM={self.initial_margin:.1%})",
            )

        return True, ""

    def validate_position_change(
        self,
        asset: str,
        current_quantity: float,
        quantity_delta: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -&gt; tuple[bool, str]:
        """Validate position change for margin account.

        Margin accounts are more permissive than cash accounts:
        - Allow position reversals (long -&gt; short, short -&gt; long)
        - Allow adding to short positions
        - Only constraint is buying power

        Args:
            asset: Asset identifier
            current_quantity: Current position size (0 if none)
            quantity_delta: Change in position
            price: Expected fill price
            current_positions: All current positions
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple

        Examples:
            Adding to long: current=100, delta=+50 -&gt; OK if BP sufficient
            Closing long: current=100, delta=-100 -&gt; Always OK (reduces risk)
            Reversing long-&gt;short: current=100, delta=-200 -&gt; OK if BP sufficient
            Adding to short: current=-100, delta=-50 -&gt; OK if BP sufficient
        """
        new_quantity = current_quantity + quantity_delta

        # Determine if this is increasing or reducing risk
        is_closing = (current_quantity &gt; 0 and quantity_delta &lt; 0) or (
            current_quantity &lt; 0 and quantity_delta &gt; 0
        )

        # For closing trades, check we're not over-closing
        if is_closing and abs(new_quantity) &lt; abs(current_quantity):
            # Partial close - always allowed (reduces risk)
            return True, ""
            # Position reversal or over-close - validate new portion

        # For opening or reversing, check buying power
        # Calculate the portion that increases risk
        if current_quantity == 0:
            # Opening new position
            risk_increase = abs(quantity_delta * price)
        elif (current_quantity &gt; 0 and new_quantity &gt; current_quantity) or (
            current_quantity &lt; 0 and new_quantity &lt; current_quantity
        ):
            # Adding to existing position
            risk_increase = abs(quantity_delta * price)
        else:
            # Reversing position - need margin for the new opposite position
            # Example: long 100 -&gt; short 100 requires margin for short 100
            risk_increase = abs(new_quantity * price)

        # Calculate buying power
        buying_power = self.calculate_buying_power(cash, current_positions)

        # Validate sufficient buying power
        if risk_increase &gt; buying_power:
            return (
                False,
                f"Insufficient buying power: need ${risk_increase:.2f}, "
                f"have ${buying_power:.2f} (IM={self.initial_margin:.1%})",
            )

        return True, ""
]]>
    </file>
    <file path="ml4t/backtest/analytics/__init__.py">
      <![CDATA["""Analytics module for backtest performance analysis."""

from .equity import EquityCurve
from .metrics import (
    cagr,
    calmar_ratio,
    max_drawdown,
    sharpe_ratio,
    sortino_ratio,
    volatility,
)
from .trades import TradeAnalyzer

__all__ = [
    "EquityCurve",
    "TradeAnalyzer",
    "sharpe_ratio",
    "sortino_ratio",
    "calmar_ratio",
    "max_drawdown",
    "cagr",
    "volatility",
]
]]>
    </file>
    <file path="ml4t/backtest/analytics/equity.py">
      <![CDATA["""Equity curve tracking and analysis."""

from dataclasses import dataclass, field
from datetime import datetime

import numpy as np

from .metrics import (
    TRADING_DAYS_PER_YEAR,
    cagr,
    calmar_ratio,
    max_drawdown,
    returns_from_values,
    sharpe_ratio,
    sortino_ratio,
    volatility,
)


@dataclass
class EquityCurve:
    """Track portfolio equity over time with computed metrics.

    Attributes:
        timestamps: List of timestamps
        values: Portfolio values at each timestamp
    """

    timestamps: list[datetime] = field(default_factory=list)
    values: list[float] = field(default_factory=list)

    def append(self, timestamp: datetime, value: float) -&gt; None:
        """Add a data point."""
        self.timestamps.append(timestamp)
        self.values.append(value)

    def __len__(self) -&gt; int:
        return len(self.values)

    @property
    def returns(self) -&gt; np.ndarray:
        """Daily returns."""
        if len(self.values) &lt; 2:
            return np.array([])
        return returns_from_values(self.values)

    @property
    def cumulative_returns(self) -&gt; np.ndarray:
        """Cumulative returns from start."""
        if len(self.values) &lt; 1:
            return np.array([])
        initial = self.values[0]
        return np.array(self.values) / initial - 1

    @property
    def initial_value(self) -&gt; float:
        """Starting portfolio value."""
        return self.values[0] if self.values else 0.0

    @property
    def final_value(self) -&gt; float:
        """Ending portfolio value."""
        return self.values[-1] if self.values else 0.0

    @property
    def total_return(self) -&gt; float:
        """Total return as decimal."""
        if not self.values or self.values[0] == 0:
            return 0.0
        return self.values[-1] / self.values[0] - 1

    @property
    def years(self) -&gt; float:
        """Duration in years based on trading days."""
        return len(self.values) / TRADING_DAYS_PER_YEAR if self.values else 0.0

    def sharpe(self, risk_free_rate: float = 0.0) -&gt; float:
        """Annualized Sharpe ratio."""
        return sharpe_ratio(self.returns, risk_free_rate)

    def sortino(self, risk_free_rate: float = 0.0) -&gt; float:
        """Annualized Sortino ratio."""
        return sortino_ratio(self.returns, risk_free_rate)

    def max_drawdown_info(self) -&gt; tuple[float, int, int]:
        """Maximum drawdown with peak/trough indices."""
        return max_drawdown(self.values)

    @property
    def max_dd(self) -&gt; float:
        """Maximum drawdown as negative decimal."""
        dd, _, _ = self.max_drawdown_info()
        return dd

    @property
    def cagr(self) -&gt; float:
        """Compound Annual Growth Rate."""
        return cagr(self.initial_value, self.final_value, self.years)

    @property
    def calmar(self) -&gt; float:
        """Calmar ratio (CAGR / Max Drawdown)."""
        return calmar_ratio(self.cagr, self.max_dd)

    @property
    def volatility(self) -&gt; float:
        """Annualized volatility."""
        return volatility(self.returns)

    def drawdown_series(self) -&gt; np.ndarray:
        """Drawdown at each point (for underwater chart)."""
        if len(self.values) &lt; 2:
            return np.array([])
        arr = np.array(self.values)
        running_max = np.maximum.accumulate(arr)
        return (arr - running_max) / running_max

    def to_dict(self) -&gt; dict:
        """Export metrics as dictionary."""
        return {
            "initial_value": self.initial_value,
            "final_value": self.final_value,
            "total_return": self.total_return,
            "cagr": self.cagr,
            "sharpe": self.sharpe(),
            "sortino": self.sortino(),
            "max_drawdown": self.max_dd,
            "calmar": self.calmar,
            "volatility": self.volatility,
            "trading_days": len(self.values),
            "years": self.years,
        }
]]>
    </file>
    <file path="ml4t/backtest/analytics/metrics.py">
      <![CDATA["""Performance metrics for backtest evaluation."""

import math
from collections.abc import Sequence

import numpy as np

# Type for arrays that can be returns/values
ReturnsLike = Sequence[float] | np.ndarray

# Annualization factors
TRADING_DAYS_PER_YEAR = 252


def returns_from_values(values: Sequence[float]) -&gt; np.ndarray:
    """Calculate returns from a series of portfolio values."""
    arr = np.array(values)
    return np.diff(arr) / arr[:-1]


def volatility(returns: ReturnsLike, annualize: bool = True) -&gt; float:
    """Calculate volatility (standard deviation of returns).

    Args:
        returns: Sequence of period returns
        annualize: If True, annualize assuming daily returns

    Returns:
        Volatility as decimal (0.15 = 15%)
    """
    arr = np.array(returns)
    if len(arr) &lt; 2:
        return 0.0
    vol = np.std(arr, ddof=1)
    if annualize:
        vol *= math.sqrt(TRADING_DAYS_PER_YEAR)
    return float(vol)


def sharpe_ratio(
    returns: ReturnsLike,
    risk_free_rate: float = 0.0,
    annualize: bool = True,
) -&gt; float:
    """Calculate Sharpe ratio.

    Args:
        returns: Sequence of period returns
        risk_free_rate: Annual risk-free rate (default 0)
        annualize: If True, annualize assuming daily returns

    Returns:
        Sharpe ratio
    """
    arr = np.array(returns)
    if len(arr) &lt; 2:
        return 0.0

    # Convert annual risk-free to daily if annualizing
    if annualize:
        daily_rf = (1 + risk_free_rate) ** (1 / TRADING_DAYS_PER_YEAR) - 1
        excess_returns = arr - daily_rf
    else:
        excess_returns = arr - risk_free_rate

    mean_excess = np.mean(excess_returns)
    std = np.std(arr, ddof=1)

    if std == 0:
        return 0.0

    sharpe = mean_excess / std
    if annualize:
        sharpe *= math.sqrt(TRADING_DAYS_PER_YEAR)
    return float(sharpe)


def sortino_ratio(
    returns: ReturnsLike,
    risk_free_rate: float = 0.0,
    annualize: bool = True,
) -&gt; float:
    """Calculate Sortino ratio (uses downside deviation).

    Args:
        returns: Sequence of period returns
        risk_free_rate: Annual risk-free rate (default 0)
        annualize: If True, annualize assuming daily returns

    Returns:
        Sortino ratio
    """
    arr = np.array(returns)
    if len(arr) &lt; 2:
        return 0.0

    # Convert annual risk-free to daily if annualizing
    if annualize:
        daily_rf = (1 + risk_free_rate) ** (1 / TRADING_DAYS_PER_YEAR) - 1
        excess_returns = arr - daily_rf
    else:
        excess_returns = arr - risk_free_rate

    mean_excess = np.mean(excess_returns)

    # Downside deviation: std of returns below target (0)
    downside = arr[arr &lt; 0]
    if len(downside) &lt; 2:
        return float("inf") if mean_excess &gt; 0 else 0.0

    downside_std = np.std(downside, ddof=1)
    if downside_std == 0:
        return float("inf") if mean_excess &gt; 0 else 0.0

    sortino = mean_excess / downside_std
    if annualize:
        sortino *= math.sqrt(TRADING_DAYS_PER_YEAR)
    return float(sortino)


def max_drawdown(values: Sequence[float]) -&gt; tuple[float, int, int]:
    """Calculate maximum drawdown from portfolio values.

    Args:
        values: Sequence of portfolio values (not returns)

    Returns:
        Tuple of (max_drawdown_pct, peak_idx, trough_idx)
        max_drawdown_pct is negative (e.g., -0.20 for 20% drawdown)
    """
    arr = np.array(values)
    if len(arr) &lt; 2:
        return 0.0, 0, 0

    # Running maximum
    running_max = np.maximum.accumulate(arr)
    drawdowns = (arr - running_max) / running_max

    trough_idx = int(np.argmin(drawdowns))
    peak_idx = int(np.argmax(arr[: trough_idx + 1])) if trough_idx &gt; 0 else 0

    return float(drawdowns[trough_idx]), peak_idx, trough_idx


def cagr(
    initial_value: float,
    final_value: float,
    years: float,
) -&gt; float:
    """Calculate Compound Annual Growth Rate.

    Args:
        initial_value: Starting portfolio value
        final_value: Ending portfolio value
        years: Number of years

    Returns:
        CAGR as decimal (0.15 = 15% annual return)
    """
    if initial_value &lt;= 0 or years &lt;= 0:
        return 0.0
    if final_value &lt;= 0:
        return -1.0  # Total loss

    return (final_value / initial_value) ** (1 / years) - 1


def calmar_ratio(cagr_value: float, max_dd: float) -&gt; float:
    """Calculate Calmar ratio (CAGR / Max Drawdown).

    Args:
        cagr_value: Compound Annual Growth Rate
        max_dd: Maximum drawdown (should be negative)

    Returns:
        Calmar ratio (higher is better)
    """
    if max_dd &gt;= 0:
        return float("inf") if cagr_value &gt; 0 else 0.0
    return cagr_value / abs(max_dd)
]]>
    </file>
    <file path="ml4t/backtest/analytics/trades.py">
      <![CDATA["""Trade analysis and statistics."""

from collections.abc import Sequence
from dataclasses import dataclass
from typing import TYPE_CHECKING

import numpy as np

if TYPE_CHECKING:
    from ..types import Trade


@dataclass
class TradeAnalyzer:
    """Analyze a collection of trades for performance statistics."""

    trades: Sequence["Trade"]

    def __post_init__(self):
        self._pnls = np.array([t.pnl for t in self.trades]) if self.trades else np.array([])
        self._returns = (
            np.array([t.pnl_percent for t in self.trades]) if self.trades else np.array([])
        )

    @property
    def num_trades(self) -&gt; int:
        """Total number of trades."""
        return len(self.trades)

    @property
    def num_winners(self) -&gt; int:
        """Number of winning trades (pnl &gt; 0)."""
        return int(np.sum(self._pnls &gt; 0))

    @property
    def num_losers(self) -&gt; int:
        """Number of losing trades (pnl &lt; 0)."""
        return int(np.sum(self._pnls &lt; 0))

    @property
    def win_rate(self) -&gt; float:
        """Percentage of winning trades."""
        if self.num_trades == 0:
            return 0.0
        return self.num_winners / self.num_trades

    @property
    def gross_profit(self) -&gt; float:
        """Sum of all winning trade PnLs."""
        winners = self._pnls[self._pnls &gt; 0]
        return float(np.sum(winners)) if len(winners) &gt; 0 else 0.0

    @property
    def gross_loss(self) -&gt; float:
        """Sum of all losing trade PnLs (negative)."""
        losers = self._pnls[self._pnls &lt; 0]
        return float(np.sum(losers)) if len(losers) &gt; 0 else 0.0

    @property
    def net_profit(self) -&gt; float:
        """Total profit/loss."""
        return float(np.sum(self._pnls)) if len(self._pnls) &gt; 0 else 0.0

    @property
    def profit_factor(self) -&gt; float:
        """Gross profit / |Gross loss|. Higher is better."""
        if self.gross_loss == 0:
            return float("inf") if self.gross_profit &gt; 0 else 0.0
        return self.gross_profit / abs(self.gross_loss)

    @property
    def avg_win(self) -&gt; float:
        """Average winning trade PnL."""
        winners = self._pnls[self._pnls &gt; 0]
        return float(np.mean(winners)) if len(winners) &gt; 0 else 0.0

    @property
    def avg_loss(self) -&gt; float:
        """Average losing trade PnL (negative)."""
        losers = self._pnls[self._pnls &lt; 0]
        return float(np.mean(losers)) if len(losers) &gt; 0 else 0.0

    @property
    def avg_trade(self) -&gt; float:
        """Average trade PnL (expectancy per trade)."""
        return float(np.mean(self._pnls)) if len(self._pnls) &gt; 0 else 0.0

    @property
    def expectancy(self) -&gt; float:
        """Mathematical expectancy: (win_rate * avg_win) + ((1 - win_rate) * avg_loss)."""
        return self.win_rate * self.avg_win + (1 - self.win_rate) * self.avg_loss

    @property
    def largest_win(self) -&gt; float:
        """Largest single winning trade."""
        winners = self._pnls[self._pnls &gt; 0]
        return float(np.max(winners)) if len(winners) &gt; 0 else 0.0

    @property
    def largest_loss(self) -&gt; float:
        """Largest single losing trade (most negative)."""
        losers = self._pnls[self._pnls &lt; 0]
        return float(np.min(losers)) if len(losers) &gt; 0 else 0.0

    @property
    def avg_return(self) -&gt; float:
        """Average return per trade (as decimal)."""
        return float(np.mean(self._returns)) if len(self._returns) &gt; 0 else 0.0

    @property
    def avg_bars_held(self) -&gt; float:
        """Average number of bars positions were held."""
        if not self.trades:
            return 0.0
        bars = [t.bars_held for t in self.trades if hasattr(t, "bars_held")]
        return float(np.mean(bars)) if bars else 0.0

    @property
    def total_commission(self) -&gt; float:
        """Total commission paid across all trades."""
        return sum(t.commission for t in self.trades)

    @property
    def total_slippage(self) -&gt; float:
        """Total slippage cost across all trades."""
        return sum(t.slippage for t in self.trades)

    def by_side(self, side: str) -&gt; "TradeAnalyzer":
        """Filter trades by side ('long' or 'short')."""
        filtered = [t for t in self.trades if t.side == side]
        return TradeAnalyzer(filtered)

    def by_asset(self, asset: str) -&gt; "TradeAnalyzer":
        """Filter trades by asset."""
        filtered = [t for t in self.trades if t.asset == asset]
        return TradeAnalyzer(filtered)

    # MFE/MAE Analysis Methods

    @property
    def avg_mfe(self) -&gt; float:
        """Average maximum favorable excursion across trades."""
        if not self.trades:
            return 0.0
        mfes = [t.max_favorable_excursion for t in self.trades]
        return float(np.mean(mfes))

    @property
    def avg_mae(self) -&gt; float:
        """Average maximum adverse excursion across trades."""
        if not self.trades:
            return 0.0
        maes = [t.max_adverse_excursion for t in self.trades]
        return float(np.mean(maes))

    @property
    def mfe_capture_ratio(self) -&gt; float:
        """Average ratio of realized return to MFE.

        Values close to 1.0 indicate exits near peak profit.
        Values close to 0.0 indicate exits gave back most gains.
        """
        if not self.trades:
            return 0.0
        ratios = []
        for t in self.trades:
            if t.max_favorable_excursion &gt; 0:
                ratios.append(t.pnl_percent / t.max_favorable_excursion)
        return float(np.mean(ratios)) if ratios else 0.0

    @property
    def mae_recovery_ratio(self) -&gt; float:
        """Average ratio showing how much of MAE was recovered.

        Calculated as (MAE - final_loss) / MAE for losing trades.
        Higher values indicate better recovery from drawdowns.
        """
        if not self.trades:
            return 0.0
        ratios = []
        for t in self.trades:
            if t.max_adverse_excursion &lt; 0 and t.pnl_percent &lt; 0:
                # Both negative: MAE was -10%, final was -5% = recovered 50%
                recovery = (t.max_adverse_excursion - t.pnl_percent) / abs(t.max_adverse_excursion)
                ratios.append(recovery)
        return float(np.mean(ratios)) if ratios else 0.0

    def to_dict(self) -&gt; dict:
        """Export statistics as dictionary."""
        return {
            "num_trades": self.num_trades,
            "num_winners": self.num_winners,
            "num_losers": self.num_losers,
            "win_rate": self.win_rate,
            "gross_profit": self.gross_profit,
            "gross_loss": self.gross_loss,
            "net_profit": self.net_profit,
            "profit_factor": self.profit_factor,
            "avg_win": self.avg_win,
            "avg_loss": self.avg_loss,
            "avg_trade": self.avg_trade,
            "expectancy": self.expectancy,
            "largest_win": self.largest_win,
            "largest_loss": self.largest_loss,
            "avg_return": self.avg_return,
            "avg_bars_held": self.avg_bars_held,
            "total_commission": self.total_commission,
            "total_slippage": self.total_slippage,
            # MFE/MAE metrics
            "avg_mfe": self.avg_mfe,
            "avg_mae": self.avg_mae,
            "mfe_capture_ratio": self.mfe_capture_ratio,
            "mae_recovery_ratio": self.mae_recovery_ratio,
        }
]]>
    </file>
    <file path="ml4t/backtest/broker.py">
      <![CDATA["""Broker for order execution and position management."""

from datetime import datetime
from typing import Any

from .models import CommissionModel, NoCommission, NoSlippage, SlippageModel
from .types import (
    ContractSpec,
    ExecutionMode,
    Fill,
    Order,
    OrderSide,
    OrderStatus,
    OrderType,
    Position,
    StopFillMode,
    StopLevelBasis,
    Trade,
)


class Broker:
    """Broker interface - same for backtest and live trading."""

    def __init__(
        self,
        initial_cash: float = 100000.0,
        commission_model: CommissionModel | None = None,
        slippage_model: SlippageModel | None = None,
        execution_mode: ExecutionMode = ExecutionMode.SAME_BAR,
        stop_fill_mode: StopFillMode = StopFillMode.STOP_PRICE,
        stop_level_basis: StopLevelBasis = StopLevelBasis.FILL_PRICE,
        account_type: str = "cash",
        initial_margin: float = 0.5,
        maintenance_margin: float = 0.25,
        execution_limits=None,
        market_impact_model=None,
        contract_specs: dict[str, ContractSpec] | None = None,
    ):
        # Import accounting classes here to avoid circular imports
        from .accounting import (
            AccountState,
            CashAccountPolicy,
            Gatekeeper,
            MarginAccountPolicy,
        )

        self.initial_cash = initial_cash
        self.cash = initial_cash
        self.commission_model = commission_model or NoCommission()
        self.slippage_model = slippage_model or NoSlippage()
        self.execution_mode = execution_mode
        self.stop_fill_mode = stop_fill_mode
        self.stop_level_basis = stop_level_basis

        # Create AccountState with appropriate policy
        from .accounting.policy import AccountPolicy

        policy: AccountPolicy
        if account_type == "cash":
            policy = CashAccountPolicy()
        elif account_type == "margin":
            policy = MarginAccountPolicy(
                initial_margin=initial_margin, maintenance_margin=maintenance_margin
            )
        else:
            raise ValueError(f"Unknown account_type: '{account_type}'. Must be 'cash' or 'margin'")

        self.account = AccountState(initial_cash=initial_cash, policy=policy)
        self.account_type = account_type
        self.initial_margin = initial_margin
        self.maintenance_margin = maintenance_margin

        # Create Gatekeeper for order validation
        self.gatekeeper = Gatekeeper(self.account, self.commission_model)

        self.positions: dict[str, Position] = {}
        self.orders: list[Order] = []
        self.pending_orders: list[Order] = []
        self.fills: list[Fill] = []
        self.trades: list[Trade] = []
        self._order_counter = 0
        self._current_time: datetime | None = None
        self._current_prices: dict[str, float] = {}  # close prices
        self._current_opens: dict[str, float] = {}  # open prices for next-bar execution
        self._current_highs: dict[str, float] = {}  # high prices for limit/stop checks
        self._current_lows: dict[str, float] = {}  # low prices for limit/stop checks
        self._current_volumes: dict[str, float] = {}
        self._current_signals: dict[str, dict[str, float]] = {}
        self._orders_this_bar: list[Order] = []  # Orders placed this bar (for next-bar mode)

        # Risk management
        self._position_rules: Any = None  # Global position rules
        self._position_rules_by_asset: dict[str, Any] = {}  # Per-asset rules
        self._pending_exits: dict[str, dict] = {}  # asset -&gt; {reason, pct} for NEXT_BAR_OPEN mode

        # Execution model (volume limits and market impact)
        self.execution_limits = execution_limits  # ExecutionLimits instance
        self.market_impact_model = market_impact_model  # MarketImpactModel instance
        self._partial_orders: dict[str, float] = {}  # order_id -&gt; remaining quantity
        self._filled_this_bar: set[str] = set()  # order_ids that had fills this bar

        # Contract specifications (for futures and other derivatives)
        self._contract_specs: dict[str, ContractSpec] = contract_specs or {}

    def get_contract_spec(self, asset: str) -&gt; ContractSpec | None:
        """Get contract specification for an asset."""
        return self._contract_specs.get(asset)

    def get_multiplier(self, asset: str) -&gt; float:
        """Get contract multiplier for an asset (1.0 for equities)."""
        spec = self._contract_specs.get(asset)
        return spec.multiplier if spec else 1.0

    def get_position(self, asset: str) -&gt; Position | None:
        return self.positions.get(asset)

    def get_cash(self) -&gt; float:
        return self.cash

    def get_account_value(self) -&gt; float:
        """Calculate total account value (cash + position values)."""
        value = self.cash
        for asset, pos in self.positions.items():
            price = self._current_prices.get(asset, pos.entry_price)
            multiplier = self.get_multiplier(asset)
            value += pos.quantity * price * multiplier
        return value

    # === Risk Management ===

    def set_position_rules(self, rules, asset: str | None = None) -&gt; None:
        """Set position rules globally or per-asset.

        Args:
            rules: PositionRule or RuleChain to apply
            asset: If provided, apply only to this asset; otherwise global
        """
        if asset:
            self._position_rules_by_asset[asset] = rules
        else:
            self._position_rules = rules

    def update_position_context(self, asset: str, context: dict) -&gt; None:
        """Update context data for a position (used by signal-based rules).

        Args:
            asset: Asset symbol
            context: Dict of signal/indicator values (e.g., {'exit_signal': -0.5, 'atr': 2.5})
        """
        pos = self.positions.get(asset)
        if pos:
            pos.context.update(context)

    def _get_position_rules(self, asset: str):
        """Get applicable rules for an asset (per-asset or global)."""
        return self._position_rules_by_asset.get(asset) or self._position_rules

    def _build_position_state(self, pos: Position, current_price: float):
        """Build PositionState from Position for rule evaluation."""
        # Import here to avoid circular imports
        from .risk.types import PositionState

        asset = pos.asset

        # Merge stop configuration into context for rules to access
        context = {
            **pos.context,
            "stop_fill_mode": self.stop_fill_mode,
            "stop_level_basis": self.stop_level_basis,
        }

        return PositionState(
            asset=asset,
            side=pos.side,
            entry_price=pos.entry_price,
            current_price=current_price,
            quantity=abs(int(pos.quantity)),
            initial_quantity=abs(int(pos.initial_quantity))
            if pos.initial_quantity
            else abs(int(pos.quantity)),
            unrealized_pnl=pos.unrealized_pnl(current_price),
            unrealized_return=pos.pnl_percent(current_price),
            bars_held=pos.bars_held,
            high_water_mark=pos.high_water_mark
            if pos.high_water_mark is not None
            else pos.entry_price,
            low_water_mark=pos.low_water_mark
            if pos.low_water_mark is not None
            else pos.entry_price,
            # Bar OHLC for intrabar stop/limit detection
            bar_open=self._current_opens.get(asset),
            bar_high=self._current_highs.get(asset),
            bar_low=self._current_lows.get(asset),
            max_favorable_excursion=pos.max_favorable_excursion,
            max_adverse_excursion=pos.max_adverse_excursion,
            entry_time=pos.entry_time,
            current_time=self._current_time,
            context=context,
        )

    def evaluate_position_rules(self) -&gt; list[Order]:
        """Evaluate position rules for all open positions.

        Called by Engine before processing orders. Returns list of exit orders.
        Handles defer_fill=True by storing pending exits for next bar.
        """
        from .risk.types import ActionType

        exit_orders = []

        for asset, pos in list(self.positions.items()):
            rules = self._get_position_rules(asset)
            if rules is None:
                continue

            price = self._current_prices.get(asset)
            if price is None:
                continue

            # Build state and evaluate
            state = self._build_position_state(pos, price)
            action = rules.evaluate(state)

            if action.action == ActionType.EXIT_FULL:
                if action.defer_fill:
                    # NEXT_BAR_OPEN mode: defer exit to next bar
                    # Store pending exit info (will be processed at next bar's open)
                    self._pending_exits[asset] = {
                        "reason": action.reason,
                        "pct": 1.0,
                        "quantity": pos.quantity,
                    }
                else:
                    # Generate full exit order immediately
                    order = self.submit_order(asset, -pos.quantity, order_type=OrderType.MARKET)
                    if order:
                        order._risk_exit_reason = action.reason
                        # Store fill price for stop/limit triggered exits
                        # This is the price at which the stop/limit was triggered
                        order._risk_fill_price = action.fill_price
                        exit_orders.append(order)

            elif action.action == ActionType.EXIT_PARTIAL:
                if action.defer_fill:
                    # NEXT_BAR_OPEN mode: defer partial exit to next bar
                    exit_qty = int(abs(pos.quantity) * action.pct)
                    if exit_qty &gt; 0:
                        self._pending_exits[asset] = {
                            "reason": action.reason,
                            "pct": action.pct,
                            "quantity": exit_qty if pos.quantity &gt; 0 else -exit_qty,
                        }
                else:
                    # Generate partial exit order immediately
                    exit_qty = int(abs(pos.quantity) * action.pct)
                    if exit_qty &gt; 0:
                        actual_qty = -exit_qty if pos.quantity &gt; 0 else exit_qty
                        order = self.submit_order(asset, actual_qty, order_type=OrderType.MARKET)
                        if order:
                            order._risk_exit_reason = action.reason
                            order._risk_fill_price = action.fill_price
                            exit_orders.append(order)

        return exit_orders

    def submit_order(
        self,
        asset: str,
        quantity: float,
        side: OrderSide | None = None,
        order_type: OrderType = OrderType.MARKET,
        limit_price: float | None = None,
        stop_price: float | None = None,
        trail_amount: float | None = None,
    ) -&gt; Order:
        if side is None:
            side = OrderSide.BUY if quantity &gt; 0 else OrderSide.SELL
            quantity = abs(quantity)

        self._order_counter += 1
        order = Order(
            asset=asset,
            side=side,
            quantity=quantity,
            order_type=order_type,
            limit_price=limit_price,
            stop_price=stop_price,
            trail_amount=trail_amount,
            order_id=f"ORD-{self._order_counter}",
            created_at=self._current_time,
        )

        # Capture signal price (close at order time) for stop level calculation
        # This is used when stop_level_basis is SIGNAL_PRICE (Backtrader behavior)
        order._signal_price = self._current_prices.get(asset)

        self.orders.append(order)
        self.pending_orders.append(order)

        # Track orders placed this bar for next-bar execution mode
        if self.execution_mode == ExecutionMode.NEXT_BAR:
            self._orders_this_bar.append(order)

        return order

    def submit_bracket(
        self,
        asset: str,
        quantity: float,
        take_profit: float,
        stop_loss: float,
        entry_type: OrderType = OrderType.MARKET,
        entry_limit: float | None = None,
    ) -&gt; tuple[Order, Order, Order]:
        """Submit entry with take-profit and stop-loss."""
        entry = self.submit_order(asset, quantity, order_type=entry_type, limit_price=entry_limit)

        tp = self.submit_order(
            asset, quantity, OrderSide.SELL, OrderType.LIMIT, limit_price=take_profit
        )
        tp.parent_id = entry.order_id

        sl = self.submit_order(
            asset, quantity, OrderSide.SELL, OrderType.STOP, stop_price=stop_loss
        )
        sl.parent_id = entry.order_id

        return entry, tp, sl

    def update_order(self, order_id: str, **kwargs) -&gt; bool:
        """Update pending order parameters (stop_price, limit_price, quantity, trail_amount)."""
        for order in self.pending_orders:
            if order.order_id == order_id:
                for key, value in kwargs.items():
                    if hasattr(order, key):
                        setattr(order, key, value)
                return True
        return False

    def cancel_order(self, order_id: str) -&gt; bool:
        for order in self.pending_orders:
            if order.order_id == order_id:
                order.status = OrderStatus.CANCELLED
                self.pending_orders.remove(order)
                return True
        return False

    def close_position(self, asset: str) -&gt; Order | None:
        pos = self.positions.get(asset)
        if pos and pos.quantity != 0:
            side = OrderSide.SELL if pos.quantity &gt; 0 else OrderSide.BUY
            return self.submit_order(asset, abs(pos.quantity), side)
        return None

    def get_order(self, order_id: str) -&gt; Order | None:
        """Get order by ID."""
        for order in self.orders:
            if order.order_id == order_id:
                return order
        return None

    def get_pending_orders(self, asset: str | None = None) -&gt; list[Order]:
        """Get pending orders, optionally filtered by asset."""
        if asset is None:
            return list(self.pending_orders)
        return [o for o in self.pending_orders if o.asset == asset]

    def _is_exit_order(self, order: Order) -&gt; bool:
        """Check if order is an exit (reducing existing position).

        Exit orders are:
        - SELL when we have a long position (reducing long)
        - BUY when we have a short position (covering short)
        - Does NOT reverse the position

        Args:
            order: Order to check

        Returns:
            True if order is reducing an existing position, False otherwise
        """
        pos = self.positions.get(order.asset)
        if pos is None or pos.quantity == 0:
            return False  # No position, so this is entry, not exit

        # Calculate signed quantity delta
        signed_qty = order.quantity if order.side == OrderSide.BUY else -order.quantity

        # Check if opposite sign (reducing) and doesn't reverse
        if pos.quantity &gt; 0 and signed_qty &lt; 0:
            # Long position, sell order
            new_qty = pos.quantity + signed_qty
            return new_qty &gt;= 0  # Exit if still long or flat, not reversal
        elif pos.quantity &lt; 0 and signed_qty &gt; 0:
            # Short position, buy order
            new_qty = pos.quantity + signed_qty
            return new_qty &lt;= 0  # Exit if still short or flat, not reversal
        else:
            # Same sign - adding to position, not exiting
            return False

    def _process_pending_exits(self) -&gt; list[Order]:
        """Process pending exits from NEXT_BAR_OPEN mode.

        Called at the start of a new bar to fill deferred exits at open price.
        Returns list of exit orders that were created and will be filled at open.
        """
        exit_orders = []

        for asset, pending in list(self._pending_exits.items()):
            pos = self.positions.get(asset)
            if pos is None:
                # Position no longer exists (shouldn't happen normally)
                del self._pending_exits[asset]
                continue

            open_price = self._current_opens.get(asset)
            if open_price is None:
                # No open price available, skip this bar
                continue

            # Create exit order with fill price = open price
            exit_qty = pending["quantity"]
            order = self.submit_order(asset, -exit_qty, order_type=OrderType.MARKET)
            if order:
                order._risk_exit_reason = pending["reason"]
                # Fill at current bar's open (this is the "next bar" from when stop triggered)
                order._risk_fill_price = open_price
                exit_orders.append(order)

            # Remove from pending
            del self._pending_exits[asset]

        return exit_orders

    def _update_time(
        self,
        timestamp: datetime,
        prices: dict[str, float],
        opens: dict[str, float],
        highs: dict[str, float],
        lows: dict[str, float],
        volumes: dict[str, float],
        signals: dict[str, dict],
    ):
        self._current_time = timestamp
        self._current_prices = prices
        self._current_opens = opens
        self._current_highs = highs
        self._current_lows = lows
        self._current_volumes = volumes
        self._current_signals = signals

        # Clear per-bar tracking at start of new bar
        self._filled_this_bar.clear()

        # In next-bar mode, move orders from this bar to pending for next bar
        if self.execution_mode == ExecutionMode.NEXT_BAR:
            # Orders placed last bar are now eligible for execution
            pass  # They're already in pending_orders
            # Clear orders placed this bar (will be processed next bar)
            self._orders_this_bar = []

        for asset, pos in self.positions.items():
            pos.bars_held += 1
            # Update water marks for risk tracking
            if asset in prices:
                pos.update_water_marks(prices[asset])

    def _process_orders(self, use_open: bool = False):
        """Process pending orders against current prices with exit-first sequencing.

        Exit-first sequencing ensures capital efficiency:
        1. Process all exit orders first (closing positions frees capital)
        2. Update account equity after exits
        3. Process all entry orders with updated buying power

        This prevents rejecting entry orders when we have pending exits that
        would free up capital.

        Args:
            use_open: If True, use open prices (for next-bar mode at bar start)
        """
        # Split orders into exits and entries
        exit_orders = []
        entry_orders = []

        for order in self.pending_orders[:]:
            # In next-bar mode, skip orders placed this bar
            if self.execution_mode == ExecutionMode.NEXT_BAR and order in self._orders_this_bar:
                continue

            if self._is_exit_order(order):
                exit_orders.append(order)
            else:
                entry_orders.append(order)

        filled_orders = []

        # Phase 1: Process exit orders (always allowed - frees capital)
        for order in exit_orders:
            # Get execution price based on mode
            if use_open and self.execution_mode == ExecutionMode.NEXT_BAR:
                price = self._current_opens.get(order.asset)
            else:
                price = self._current_prices.get(order.asset)

            if price is None:
                continue

            fill_price = self._check_fill(order, price)
            if fill_price is not None:
                fully_filled = self._execute_fill(order, fill_price)
                if fully_filled:
                    filled_orders.append(order)
                    # Clean up partial tracking
                    self._partial_orders.pop(order.order_id, None)
                else:
                    # Update order quantity to remaining
                    self._update_partial_order(order)

        # Phase 2: Update account equity after exits
        self.account.mark_to_market(self._current_prices)

        # Phase 3: Process entry orders (validated via Gatekeeper)
        for order in entry_orders:
            # Get execution price based on mode
            if use_open and self.execution_mode == ExecutionMode.NEXT_BAR:
                price = self._current_opens.get(order.asset)
            else:
                price = self._current_prices.get(order.asset)

            if price is None:
                continue

            fill_price = self._check_fill(order, price)
            if fill_price is not None:
                # CRITICAL: Validate order before executing
                valid, rejection_reason = self.gatekeeper.validate_order(order, fill_price)

                if valid:
                    fully_filled = self._execute_fill(order, fill_price)
                    if fully_filled:
                        filled_orders.append(order)
                        # Clean up partial tracking
                        self._partial_orders.pop(order.order_id, None)
                    else:
                        # Update order quantity to remaining
                        self._update_partial_order(order)
                else:
                    # Reject order
                    order.status = OrderStatus.REJECTED
                    # Note: rejection_reason could be logged here if needed

        # Remove filled/rejected orders from pending (only fully filled ones)
        for order in filled_orders:
            if order in self.pending_orders:
                self.pending_orders.remove(order)
            if order in self._orders_this_bar:
                self._orders_this_bar.remove(order)

        # Also remove rejected orders
        for order in self.pending_orders[:]:
            if order.status == OrderStatus.REJECTED:
                self.pending_orders.remove(order)

    def _get_effective_quantity(self, order: Order) -&gt; float:
        """Get effective order quantity (considering partial fills).

        For orders with partial fills in progress, returns the remaining quantity.
        """
        remaining = self._partial_orders.get(order.order_id)
        if remaining is not None:
            return remaining
        return order.quantity

    def _update_partial_order(self, order: Order) -&gt; None:
        """Update order quantity after partial fill for next bar."""
        remaining = self._partial_orders.get(order.order_id)
        if remaining is not None:
            order.quantity = remaining

    def _check_fill(self, order: Order, price: float) -&gt; float | None:
        """Check if order should fill, return fill price or None.

        Uses High/Low data to properly check if limit/stop prices were traded through.
        For limit orders: fill at limit price if bar's range touched it
        For stop orders: fill at stop price (or worse) if bar's range triggered it
        For risk-triggered market orders: fill at the stop/target price (intrabar execution)
        """
        high = self._current_highs.get(order.asset, price)
        low = self._current_lows.get(order.asset, price)

        if order.order_type == OrderType.MARKET:
            # Check if this is a risk-triggered exit with a specific fill price
            # (e.g., stop-loss or take-profit that was triggered intrabar)
            risk_fill_price = getattr(order, "_risk_fill_price", None)
            if risk_fill_price is not None:
                # Use the stop/target price as the base fill price
                # Slippage will be applied on top by the caller
                return risk_fill_price
            return price

        elif order.order_type == OrderType.LIMIT and order.limit_price is not None:
            # Limit buy fills if Low &lt;= limit_price (price dipped to our level)
            # Limit sell fills if High &gt;= limit_price (price rose to our level)
            if (
                order.side == OrderSide.BUY
                and low &lt;= order.limit_price
                or order.side == OrderSide.SELL
                and high &gt;= order.limit_price
            ):
                return order.limit_price

        elif order.order_type == OrderType.STOP and order.stop_price is not None:
            # Stop buy triggers if High &gt;= stop_price (price rose to trigger)
            # Stop sell triggers if Low &lt;= stop_price (price fell to trigger)
            if order.side == OrderSide.BUY and high &gt;= order.stop_price:
                # Fill at stop price or worse (could gap through)
                return max(order.stop_price, low)  # At least stop price
            elif order.side == OrderSide.SELL and low &lt;= order.stop_price:
                # Fill at stop price or worse (could gap through)
                return min(order.stop_price, high)  # At most stop price

        elif order.order_type == OrderType.TRAILING_STOP and order.side == OrderSide.SELL:
            # Update trailing stop based on high water mark
            if order.trail_amount is not None:
                new_stop = high - order.trail_amount
                if order.stop_price is None or new_stop &gt; order.stop_price:
                    order.stop_price = new_stop
            # Check if triggered
            if order.stop_price is not None and low &lt;= order.stop_price:
                return min(order.stop_price, high)

        return None

    def _execute_fill(self, order: Order, base_price: float) -&gt; bool:
        """Execute a fill and update positions.

        Returns:
            True if order is fully filled, False if partially filled (remainder pending)
        """
        # Ensure we have a current time (should always be set during backtest)
        assert self._current_time is not None, "Cannot execute fill without current time"
        current_time = self._current_time

        volume = self._current_volumes.get(order.asset)

        # Get effective quantity (considering partial fills from previous bars)
        effective_quantity = self._get_effective_quantity(order)
        fill_quantity = effective_quantity

        # Apply execution limits (volume participation)
        if self.execution_limits is not None:
            # Skip if already filled this bar (for volume limits)
            if order.order_id in self._filled_this_bar:
                return False

            exec_result = self.execution_limits.calculate(effective_quantity, volume, base_price)
            fill_quantity = exec_result.fillable_quantity

            if fill_quantity &lt;= 0:
                # Can't fill any this bar - keep order pending
                return False

            # Mark as filled this bar (to prevent double fills in same_bar mode)
            self._filled_this_bar.add(order.order_id)

            if exec_result.remaining_quantity &gt; 0:
                # Partial fill - track remaining for future bars
                self._partial_orders[order.order_id] = exec_result.remaining_quantity
            else:
                # Fully filled - remove from partial tracking
                self._partial_orders.pop(order.order_id, None)

        # Apply market impact
        impact = 0.0
        if self.market_impact_model is not None:
            is_buy = order.side == OrderSide.BUY
            impact = self.market_impact_model.calculate(fill_quantity, base_price, volume, is_buy)
            base_price = base_price + impact  # Impact adjusts the base price

        # Calculate slippage (on top of market impact)
        slippage = self.slippage_model.calculate(order.asset, fill_quantity, base_price, volume)
        fill_price = base_price + slippage if order.side == OrderSide.BUY else base_price - slippage

        # Calculate commission
        commission = self.commission_model.calculate(order.asset, fill_quantity, fill_price)

        fill = Fill(
            order_id=order.order_id,
            asset=order.asset,
            side=order.side,
            quantity=fill_quantity,
            price=fill_price,
            timestamp=current_time,
            commission=commission,
            slippage=slippage,
        )
        self.fills.append(fill)

        # Determine if order is fully filled or partial
        is_partial = order.order_id in self._partial_orders
        if is_partial:
            # Update order for partial fill (will continue next bar)
            order.filled_quantity = (order.filled_quantity or 0) + fill_quantity
            # Don't change status - still pending for remainder
        else:
            order.status = OrderStatus.FILLED
            order.filled_at = current_time
            order.filled_price = fill_price
            order.filled_quantity = fill_quantity

        # Update position
        pos = self.positions.get(order.asset)
        signed_qty = fill_quantity if order.side == OrderSide.BUY else -fill_quantity

        if pos is None:
            if signed_qty != 0:
                # Create new position with signal_price in context for stop level calculation
                signal_price = getattr(order, "_signal_price", None)
                context = {"signal_price": signal_price} if signal_price is not None else {}
                self.positions[order.asset] = Position(
                    asset=order.asset,
                    quantity=signed_qty,
                    entry_price=fill_price,
                    entry_time=current_time,
                    context=context,
                    multiplier=self.get_multiplier(order.asset),
                )
        else:
            old_qty = pos.quantity
            new_qty = old_qty + signed_qty

            if new_qty == 0:
                # Position closed
                pnl = (fill_price - pos.entry_price) * old_qty - commission
                trade = Trade(
                    asset=order.asset,
                    entry_time=pos.entry_time,
                    exit_time=current_time,
                    entry_price=pos.entry_price,
                    exit_price=fill_price,
                    quantity=old_qty,  # Preserve sign: positive=long, negative=short
                    pnl=pnl,
                    pnl_percent=(fill_price - pos.entry_price) / pos.entry_price
                    if pos.entry_price
                    else 0,
                    bars_held=pos.bars_held,
                    commission=commission,
                    slippage=slippage,
                    entry_signals=self._current_signals.get(order.asset, {}),
                    exit_signals=self._current_signals.get(order.asset, {}),
                    max_favorable_excursion=pos.max_favorable_excursion,
                    max_adverse_excursion=pos.max_adverse_excursion,
                )
                self.trades.append(trade)
                del self.positions[order.asset]
            elif (old_qty &gt; 0) != (new_qty &gt; 0):
                # Position flipped
                pnl = (fill_price - pos.entry_price) * old_qty - commission
                self.trades.append(
                    Trade(
                        asset=order.asset,
                        entry_time=pos.entry_time,
                        exit_time=current_time,
                        entry_price=pos.entry_price,
                        exit_price=fill_price,
                        quantity=old_qty,  # Preserve sign: positive=long, negative=short
                        pnl=pnl,
                        pnl_percent=(fill_price - pos.entry_price) / pos.entry_price
                        if pos.entry_price
                        else 0,
                        bars_held=pos.bars_held,
                        commission=commission,
                        slippage=slippage,
                        max_favorable_excursion=pos.max_favorable_excursion,
                        max_adverse_excursion=pos.max_adverse_excursion,
                    )
                )
                # Create new position with signal_price in context
                signal_price = getattr(order, "_signal_price", None)
                context = {"signal_price": signal_price} if signal_price is not None else {}
                self.positions[order.asset] = Position(
                    asset=order.asset,
                    quantity=new_qty,
                    entry_price=fill_price,
                    entry_time=current_time,
                    context=context,
                    multiplier=self.get_multiplier(order.asset),
                )
            else:
                # Position scaled
                if abs(new_qty) &gt; abs(old_qty):
                    total_cost = pos.entry_price * abs(old_qty) + fill_price * abs(signed_qty)
                    pos.entry_price = total_cost / abs(new_qty)
                pos.quantity = new_qty

        # Update cash
        cash_change = -signed_qty * fill_price - commission
        self.cash += cash_change

        # Sync position to AccountState (uses unified Position from types)
        broker_pos = self.positions.get(order.asset)
        if broker_pos is None:
            # Position was closed, remove from account
            if order.asset in self.account.positions:
                del self.account.positions[order.asset]
        else:
            # Update or create position in account
            self.account.positions[order.asset] = Position(
                asset=broker_pos.asset,
                quantity=broker_pos.quantity,
                entry_price=broker_pos.entry_price,
                current_price=self._current_prices.get(order.asset, broker_pos.entry_price),
                entry_time=broker_pos.entry_time,
                bars_held=broker_pos.bars_held,
            )

        # Update account cash
        self.account.cash = self.cash

        # Cancel sibling bracket orders on fill (only for full fills)
        if order.parent_id and not is_partial:
            for o in self.pending_orders[:]:
                if o.parent_id == order.parent_id and o.order_id != order.order_id:
                    o.status = OrderStatus.CANCELLED
                    self.pending_orders.remove(o)

        # Return True for full fill, False for partial (order stays pending)
        return not is_partial
]]>
    </file>
    <file path="ml4t/backtest/calendar.py">
      <![CDATA["""Exchange calendar integration using pandas_market_calendars.

This module provides a Polars-native interface to exchange calendars,
following the recommendation from the calendar_libraries.md analysis.

Key features:
- Trading schedule retrieval as Polars DataFrames
- Support for all major exchanges (NYSE, CME, LSE, etc.)
- Product-specific calendars for futures (CME_Equity, CME_Bond, etc.)
- Intraday break support (CME maintenance breaks)
- Trading day validation and date range generation

Example usage:
    from ml4t.backtest.calendar import (
        get_calendar,
        get_schedule,
        get_trading_days,
        is_trading_day,
    )

    # Get NYSE trading schedule for 2024
    schedule = get_schedule("XNYS", date(2024, 1, 1), date(2024, 12, 31))

    # Get trading days only
    trading_days = get_trading_days("XNYS", date(2024, 1, 1), date(2024, 12, 31))

    # Check if a specific date is a trading day
    if is_trading_day("XNYS", date(2024, 7, 4)):
        print("Market is open")
"""

from datetime import date, datetime
from functools import lru_cache

import pandas as pd
import polars as pl

# Import pandas_market_calendars with lazy loading to avoid import overhead
_mcal = None


def _get_mcal():
    """Lazy load pandas_market_calendars."""
    global _mcal
    if _mcal is None:
        import pandas_market_calendars as mcal

        _mcal = mcal
    return _mcal


# Common calendar aliases for convenience
CALENDAR_ALIASES = {
    # US Equities
    "NYSE": "XNYS",
    "NASDAQ": "NASDAQ",  # pandas_market_calendars uses "NASDAQ" directly
    "AMEX": "NYSE",  # AMEX follows NYSE calendar
    # US Futures (product-specific via pandas_market_calendars)
    "CME": "CME_Equity",  # Default to equity futures
    "CME_EQUITY": "CME_Equity",
    "CME_BOND": "CME_Bond",
    "CME_AGRICULTURE": "CME_Agriculture",
    "CBOT": "CME_Bond",  # CBOT is now CME
    "NYMEX": "CME_Equity",  # Energy futures
    "COMEX": "CME_Equity",  # Metals
    "ICE": "IEPA",
    # Europe
    "LSE": "XLON",
    "EUREX": "EUREX",
    "XETRA": "XFRA",
    # Asia-Pacific
    "TSE": "JPX",  # Tokyo - uses JPX in pandas_market_calendars
    "HKEX": "XHKG",
    "SSE": "XSHG",  # Shanghai
    "SZSE": "XSHE",  # Shenzhen
    "ASX": "XASX",
    "NSE": "XNSE",  # India
    # Americas
    "TSX": "XTSE",  # Toronto
    "BMV": "XMEX",  # Mexico
    "B3": "BVMF",  # Brazil
    # Crypto (24/7)
    "CRYPTO": "24/7",
}


@lru_cache(maxsize=32)
def get_calendar(calendar_id: str):
    """Get a market calendar instance.

    Args:
        calendar_id: Exchange MIC code (e.g., 'XNYS') or alias (e.g., 'NYSE').
            See CALENDAR_ALIASES for common aliases.

    Returns:
        pandas_market_calendars calendar instance

    Examples:
        &gt;&gt;&gt; cal = get_calendar("NYSE")  # NYSE via alias
        &gt;&gt;&gt; cal = get_calendar("XNYS")  # NYSE via MIC code
        &gt;&gt;&gt; cal = get_calendar("CME_Equity")  # CME equity futures
    """
    mcal = _get_mcal()

    # Resolve alias to MIC code
    resolved_id = CALENDAR_ALIASES.get(calendar_id.upper(), calendar_id)

    return mcal.get_calendar(resolved_id)


def get_schedule(
    calendar_id: str,
    start_date: date | datetime | str,
    end_date: date | datetime | str,
    *,
    include_breaks: bool = False,
    include_extended_hours: bool = False,
) -&gt; pl.DataFrame:
    """Get trading schedule as a Polars DataFrame.

    This is the primary function for retrieving exchange schedules.
    Uses the efficient pandas -&gt; pyarrow -&gt; polars conversion path.

    Args:
        calendar_id: Exchange MIC code or alias (e.g., 'NYSE', 'XNYS', 'CME_Equity')
        start_date: Start date of the schedule range
        end_date: End date of the schedule range
        include_breaks: If True, include break_start/break_end columns for
            exchanges with intraday breaks (e.g., CME maintenance break)
        include_extended_hours: If True, include pre_market/post_market columns

    Returns:
        Polars DataFrame with columns:
        - session_date: Date of the trading session
        - market_open: UTC datetime when market opens
        - market_close: UTC datetime when market closes
        - timezone: Exchange timezone (e.g., 'America/New_York')
        - (optional) break_start, break_end: Intraday break times
        - (optional) pre_market, post_market: Extended hours

    Examples:
        &gt;&gt;&gt; schedule = get_schedule("NYSE", date(2024, 1, 1), date(2024, 12, 31))
        &gt;&gt;&gt; schedule.head()
        shape: (5, 4)
        ┌──────────────┬─────────────────────────┬─────────────────────────┬──────────────────┐
        │ session_date ┆ market_open             ┆ market_close            ┆ timezone         │
        │ ---          ┆ ---                     ┆ ---                     ┆ ---              │
        │ date         ┆ datetime[μs, UTC]       ┆ datetime[μs, UTC]       ┆ str              │
        ╞══════════════╪═════════════════════════╪═════════════════════════╪══════════════════╡
        │ 2024-01-02   ┆ 2024-01-02 14:30:00 UTC ┆ 2024-01-02 21:00:00 UTC ┆ America/New_York │
        │ 2024-01-03   ┆ 2024-01-03 14:30:00 UTC ┆ 2024-01-03 21:00:00 UTC ┆ America/New_York │
        │ ...          ┆ ...                     ┆ ...                     ┆ ...              │
        └──────────────┴─────────────────────────┴─────────────────────────┴──────────────────┘
    """
    calendar = get_calendar(calendar_id)

    # Generate schedule using pandas_market_calendars
    schedule_pd = calendar.schedule(start_date=start_date, end_date=end_date)

    if schedule_pd.empty:
        # Return empty DataFrame with correct schema
        return pl.DataFrame(
            schema={
                "session_date": pl.Date,
                "market_open": pl.Datetime("us", "UTC"),
                "market_close": pl.Datetime("us", "UTC"),
                "timezone": pl.Utf8,
            }
        )

    # Convert to Polars via pyarrow (efficient zero-copy path)
    schedule_pl = pl.from_pandas(schedule_pd.reset_index())

    # Rename columns to standardized names
    rename_map = {
        "index": "session_date",
        "market_open": "market_open",
        "market_close": "market_close",
    }

    # Handle optional columns
    if include_breaks and "break_start" in schedule_pl.columns:
        rename_map["break_start"] = "break_start"
        rename_map["break_end"] = "break_end"

    if include_extended_hours:
        if "pre" in schedule_pl.columns:
            rename_map["pre"] = "pre_market"
        if "post" in schedule_pl.columns:
            rename_map["post"] = "post_market"

    # Apply renames for columns that exist
    existing_renames = {k: v for k, v in rename_map.items() if k in schedule_pl.columns}
    schedule_pl = schedule_pl.rename(existing_renames)

    # Select and structure output columns
    output_columns = ["session_date", "market_open", "market_close"]

    if include_breaks and "break_start" in schedule_pl.columns:
        output_columns.extend(["break_start", "break_end"])

    if include_extended_hours:
        if "pre_market" in schedule_pl.columns:
            output_columns.append("pre_market")
        if "post_market" in schedule_pl.columns:
            output_columns.append("post_market")

    # Get timezone string
    tz_key = str(calendar.tz) if hasattr(calendar, "tz") else "UTC"

    # Build final DataFrame
    result = schedule_pl.select(
        [col for col in output_columns if col in schedule_pl.columns]
    ).with_columns(
        pl.col("session_date").cast(pl.Date),
        pl.lit(tz_key).alias("timezone"),
    )

    return result


def get_trading_days(
    calendar_id: str,
    start_date: date | datetime | str,
    end_date: date | datetime | str,
) -&gt; pl.Series:
    """Get list of trading days as a Polars Series.

    This is useful for filtering data to only trading days or
    generating date ranges for backtesting.

    Args:
        calendar_id: Exchange MIC code or alias
        start_date: Start date of the range
        end_date: End date of the range

    Returns:
        Polars Series of dates (pl.Date dtype)

    Examples:
        &gt;&gt;&gt; trading_days = get_trading_days("NYSE", date(2024, 1, 1), date(2024, 1, 31))
        &gt;&gt;&gt; len(trading_days)
        21  # NYSE had 21 trading days in Jan 2024
    """
    calendar = get_calendar(calendar_id)
    valid_days = calendar.valid_days(start_date=start_date, end_date=end_date)

    # Convert pandas DatetimeIndex to Polars Series
    return pl.Series("trading_day", valid_days.date)


def is_trading_day(calendar_id: str, check_date: date | datetime | str) -&gt; bool:
    """Check if a specific date is a trading day.

    Args:
        calendar_id: Exchange MIC code or alias
        check_date: Date to check

    Returns:
        True if the date is a trading day, False otherwise

    Examples:
        &gt;&gt;&gt; is_trading_day("NYSE", date(2024, 7, 4))  # Independence Day
        False
        &gt;&gt;&gt; is_trading_day("NYSE", date(2024, 7, 5))  # Regular Friday
        True
    """
    calendar = get_calendar(calendar_id)

    # Convert to pandas Timestamp for comparison
    if isinstance(check_date, str | date | datetime):
        check_date = pd.Timestamp(check_date)

    valid_days = calendar.valid_days(start_date=check_date, end_date=check_date)
    return len(valid_days) &gt; 0


def is_market_open(
    calendar_id: str,
    check_datetime: datetime,
) -&gt; bool:
    """Check if the market is open at a specific datetime.

    This accounts for:
    - Regular trading hours
    - Intraday breaks (e.g., CME maintenance break 4-5 PM CT)
    - Early closes

    Args:
        calendar_id: Exchange MIC code or alias
        check_datetime: Datetime to check (should be timezone-aware or UTC)

    Returns:
        True if market is open, False otherwise

    Examples:
        &gt;&gt;&gt; from datetime import datetime, timezone
        &gt;&gt;&gt; dt = datetime(2024, 7, 5, 15, 30, tzinfo=timezone.utc)  # 11:30 AM ET
        &gt;&gt;&gt; is_market_open("NYSE", dt)
        True
    """
    calendar = get_calendar(calendar_id)

    # Convert to pandas Timestamp
    ts = pd.Timestamp(check_datetime)

    # Get schedule for that day
    schedule = calendar.schedule(start_date=ts.date(), end_date=ts.date())

    if schedule.empty:
        return False

    market_open = schedule.iloc[0]["market_open"]
    market_close = schedule.iloc[0]["market_close"]

    # Check if within regular hours
    if not (market_open &lt;= ts &lt;= market_close):
        return False

    # Check for intraday breaks if available
    if "break_start" in schedule.columns and pd.notna(schedule.iloc[0]["break_start"]):
        break_start = schedule.iloc[0]["break_start"]
        break_end = schedule.iloc[0]["break_end"]
        if break_start &lt;= ts &lt;= break_end:
            return False

    return True


def next_trading_day(
    calendar_id: str,
    from_date: date | datetime | str,
    n: int = 1,
) -&gt; date:
    """Get the next N trading day(s) after a given date.

    Args:
        calendar_id: Exchange MIC code or alias
        from_date: Starting date
        n: Number of trading days to advance (default 1)

    Returns:
        The nth trading day after from_date

    Examples:
        &gt;&gt;&gt; next_trading_day("NYSE", date(2024, 7, 3))  # Wed before July 4th
        date(2024, 7, 5)  # Skips Thursday holiday
    """
    calendar = get_calendar(calendar_id)

    # Convert to pandas Timestamp
    if isinstance(from_date, str):
        from_date = pd.Timestamp(from_date).date()
    elif isinstance(from_date, datetime):
        from_date = from_date.date()

    # Get enough future days to find n trading days
    # Worst case: 2 weeks of holidays, so look 30 days ahead per n
    end_date = pd.Timestamp(from_date) + pd.Timedelta(days=max(30, n * 5))

    valid_days = calendar.valid_days(start_date=from_date, end_date=end_date)

    # Filter to days strictly after from_date
    future_days = [d.date() for d in valid_days if d.date() &gt; from_date]

    if len(future_days) &lt; n:
        raise ValueError(f"Could not find {n} trading days after {from_date}")

    return future_days[n - 1]


def previous_trading_day(
    calendar_id: str,
    from_date: date | datetime | str,
    n: int = 1,
) -&gt; date:
    """Get the previous N trading day(s) before a given date.

    Args:
        calendar_id: Exchange MIC code or alias
        from_date: Starting date
        n: Number of trading days to go back (default 1)

    Returns:
        The nth trading day before from_date

    Examples:
        &gt;&gt;&gt; previous_trading_day("NYSE", date(2024, 7, 5))  # Fri after July 4th
        date(2024, 7, 3)  # Skips Thursday holiday
    """
    calendar = get_calendar(calendar_id)

    # Convert to pandas Timestamp
    if isinstance(from_date, str):
        from_date = pd.Timestamp(from_date).date()
    elif isinstance(from_date, datetime):
        from_date = from_date.date()

    # Look back enough days
    start_date = pd.Timestamp(from_date) - pd.Timedelta(days=max(30, n * 5))

    valid_days = calendar.valid_days(start_date=start_date, end_date=from_date)

    # Filter to days strictly before from_date
    past_days = [d.date() for d in valid_days if d.date() &lt; from_date]

    if len(past_days) &lt; n:
        raise ValueError(f"Could not find {n} trading days before {from_date}")

    return past_days[-n]


def list_calendars() -&gt; list[str]:
    """List all available calendar identifiers.

    Returns:
        List of available calendar MIC codes

    Examples:
        &gt;&gt;&gt; calendars = list_calendars()
        &gt;&gt;&gt; "XNYS" in calendars
        True
    """
    mcal = _get_mcal()
    return mcal.get_calendar_names()


def get_holidays(
    calendar_id: str,
    start_date: date | datetime | str,
    end_date: date | datetime | str,
) -&gt; pl.DataFrame:
    """Get holidays for an exchange within a date range.

    Args:
        calendar_id: Exchange MIC code or alias
        start_date: Start date of the range
        end_date: End date of the range

    Returns:
        Polars DataFrame with columns:
        - date: Holiday date
        - name: Holiday name (if available)

    Examples:
        &gt;&gt;&gt; holidays = get_holidays("NYSE", date(2024, 1, 1), date(2024, 12, 31))
        &gt;&gt;&gt; holidays
        shape: (9, 2)
        ┌────────────┬────────────────────┐
        │ date       ┆ name               │
        │ ---        ┆ ---                │
        │ date       ┆ str                │
        ╞════════════╪════════════════════╡
        │ 2024-01-01 ┆ New Year's Day     │
        │ 2024-01-15 ┆ MLK Day            │
        │ ...        ┆ ...                │
        └────────────┴────────────────────┘
    """
    calendar = get_calendar(calendar_id)

    # Get all dates in range
    start = pd.Timestamp(start_date)
    end = pd.Timestamp(end_date)

    # Generate all calendar days in range
    all_days = pd.date_range(start=start, end=end, freq="D")

    # Get trading days
    trading_days = calendar.valid_days(start_date=start, end_date=end)

    # Holidays are weekdays that are not trading days
    weekdays = all_days[all_days.dayofweek &lt; 5]  # Mon-Fri
    holidays = weekdays.difference(trading_days)

    # Build DataFrame
    return pl.DataFrame(
        {
            "date": [h.date() for h in holidays],
            "name": [None] * len(holidays),  # Names not easily available
        }
    )


def filter_to_trading_days(
    df: pl.DataFrame,
    calendar_id: str,
    timestamp_col: str = "timestamp",
) -&gt; pl.DataFrame:
    """Filter a DataFrame to only include rows on trading days.

    Use this for DAILY bars where you only need to filter by date.
    For intraday data, use `filter_to_trading_hours()` instead.

    Args:
        df: Polars DataFrame with a timestamp column
        calendar_id: Exchange MIC code or alias
        timestamp_col: Name of the timestamp column

    Returns:
        DataFrame filtered to trading days only

    Examples:
        &gt;&gt;&gt; # Filter daily price data to NYSE trading days
        &gt;&gt;&gt; daily_prices = filter_to_trading_days(daily_prices, "NYSE")
    """
    # Get date range from data
    dates = df.select(pl.col(timestamp_col).cast(pl.Date).alias("__date"))
    min_date = dates.min().item()
    max_date = dates.max().item()

    # Get trading days as a Polars Series with proper Date dtype
    calendar = get_calendar(calendar_id)
    valid_days = calendar.valid_days(start_date=min_date, end_date=max_date)

    # Convert to Polars Series with Date dtype
    trading_days = pl.Series("trading_day", [d.date() for d in valid_days], dtype=pl.Date)

    # Filter to trading days
    return df.filter(pl.col(timestamp_col).cast(pl.Date).is_in(trading_days))


def filter_to_trading_sessions(
    df: pl.DataFrame,
    calendar_id: str,
    timestamp_col: str = "timestamp",
    *,
    naive_tz: str = "UTC",
    include_breaks: bool = False,
) -&gt; pl.DataFrame:
    """Filter a DataFrame to only include rows during trading sessions.

    Use this for INTRADAY data (minute bars, tick data, trade bars).
    Filters out:
    - Non-trading days (weekends, holidays)
    - Pre-market hours
    - Post-market hours
    - Intraday breaks (optional, e.g., CME maintenance break)

    Works with any irregular timestamp data - doesn't require fixed frequency.
    Uses efficient Polars join_asof for interval matching.

    Args:
        df: Polars DataFrame with a timestamp column
        calendar_id: Exchange MIC code or alias
        timestamp_col: Name of the timestamp column
        naive_tz: Timezone to assume for naive datetimes (default: "UTC").
            Set this to match your data source (e.g., "America/New_York" for
            US equity data that's already in ET).
        include_breaks: If False (default), also filter out intraday breaks

    Returns:
        DataFrame filtered to trading sessions only

    Examples:
        &gt;&gt;&gt; # Filter minute bars to NYSE trading sessions (data in UTC)
        &gt;&gt;&gt; minute_bars = filter_to_trading_sessions(minute_bars, "NYSE")

        &gt;&gt;&gt; # Data with naive timestamps that are actually in ET
        &gt;&gt;&gt; bars = filter_to_trading_sessions(bars, "NYSE", naive_tz="America/New_York")

        &gt;&gt;&gt; # Keep data during intraday breaks
        &gt;&gt;&gt; data = filter_to_trading_sessions(data, "CME_Equity", include_breaks=True)
    """
    if df.is_empty():
        return df

    # Get date range from data - handle both tz-aware and naive
    ts_col = df[timestamp_col]
    ts_dtype = ts_col.dtype

    # Coerce to UTC for consistent comparison
    if isinstance(ts_dtype, pl.Datetime):
        if ts_dtype.time_zone is None:
            # Naive datetime - use specified timezone, then convert to UTC
            df = df.with_columns(
                pl.col(timestamp_col)
                .dt.replace_time_zone(naive_tz)
                .dt.convert_time_zone("UTC")
                .alias(timestamp_col)
            )
        elif ts_dtype.time_zone != "UTC":
            # Convert to UTC
            df = df.with_columns(
                pl.col(timestamp_col).dt.convert_time_zone("UTC").alias(timestamp_col)
            )

    # Get date range
    min_date = df.select(pl.col(timestamp_col).dt.date().min()).item()
    max_date = df.select(pl.col(timestamp_col).dt.date().max()).item()

    # Get schedule for the date range
    calendar = get_calendar(calendar_id)
    schedule_pd = calendar.schedule(start_date=min_date, end_date=max_date)

    if schedule_pd.empty:
        return df.clear()  # No trading days in range

    # Build sessions list, handling breaks
    sessions = []
    for _, row in schedule_pd.iterrows():
        market_open = row["market_open"]
        market_close = row["market_close"]

        if (
            not include_breaks
            and "break_start" in schedule_pd.columns
            and pd.notna(row.get("break_start"))
        ):
            # Split into pre-break and post-break sessions
            break_start = row["break_start"]
            break_end = row["break_end"]
            sessions.append((market_open, break_start))
            sessions.append((break_end, market_close))
        else:
            sessions.append((market_open, market_close))

    # Create sessions DataFrame with proper UTC dtype
    sessions_df = (
        pl.DataFrame(
            {
                "session_open": [s[0].to_pydatetime() for s in sessions],
                "session_close": [s[1].to_pydatetime() for s in sessions],
            }
        )
        .with_columns(
            pl.col("session_open").cast(pl.Datetime("us", "UTC")),
            pl.col("session_close").cast(pl.Datetime("us", "UTC")),
        )
        .sort("session_open")
    )

    # Use join_asof to find the session that starts at or before each timestamp
    # Then filter to rows where timestamp &lt;= session_close
    result = (
        df.lazy()
        .sort(timestamp_col)
        .join_asof(
            sessions_df.lazy(),
            left_on=timestamp_col,
            right_on="session_open",
            strategy="backward",  # Find session that starts at or before timestamp
        )
        .filter(
            # Timestamp must be within the matched session
            pl.col(timestamp_col) &lt;= pl.col("session_close")
        )
        .drop(["session_open", "session_close"])
        .collect()
    )

    return result


def generate_trading_minutes(
    calendar_id: str,
    start_date: date | datetime | str,
    end_date: date | datetime | str,
    *,
    freq: str = "1m",
    include_close: bool = True,
) -&gt; pl.Series:
    """Generate a series of trading minute timestamps.

    Useful for creating a time index for minute-frequency backtests
    or for resampling irregular data to regular minute bars.

    Args:
        calendar_id: Exchange MIC code or alias
        start_date: Start date
        end_date: End date
        freq: Frequency string ('1m', '5m', '15m', '30m', '1h')
        include_close: If True, include the market close timestamp

    Returns:
        Polars Series of datetime timestamps

    Examples:
        &gt;&gt;&gt; # Generate 1-minute timestamps for NYSE
        &gt;&gt;&gt; minutes = generate_trading_minutes("NYSE", date(2024, 1, 2), date(2024, 1, 2))
        &gt;&gt;&gt; len(minutes)
        391  # 9:30 AM to 4:00 PM = 6.5 hours = 390 minutes + close

        &gt;&gt;&gt; # Generate 5-minute bars
        &gt;&gt;&gt; bars_5m = generate_trading_minutes("NYSE", date(2024, 1, 2), date(2024, 1, 5), freq="5m")
    """
    # Parse frequency
    freq_map = {"1m": 1, "5m": 5, "15m": 15, "30m": 30, "1h": 60}
    if freq not in freq_map:
        raise ValueError(f"Unsupported frequency: {freq}. Use one of {list(freq_map.keys())}")
    freq_minutes = freq_map[freq]

    # Get schedule
    calendar = get_calendar(calendar_id)
    schedule_pd = calendar.schedule(start_date=start_date, end_date=end_date)

    if schedule_pd.empty:
        return pl.Series("timestamp", [], dtype=pl.Datetime("us", "UTC"))

    # Generate timestamps for each session
    all_timestamps = []

    for _, row in schedule_pd.iterrows():
        market_open = row["market_open"]
        market_close = row["market_close"]

        # Generate minute timestamps
        current = market_open
        while current &lt; market_close:
            all_timestamps.append(current)
            current = current + pd.Timedelta(minutes=freq_minutes)

        # Optionally include close
        if include_close and (not all_timestamps or all_timestamps[-1] != market_close):
            all_timestamps.append(market_close)

    return pl.Series("timestamp", all_timestamps)


def get_early_closes(
    calendar_id: str,
    start_date: date | datetime | str,
    end_date: date | datetime | str,
) -&gt; pl.DataFrame:
    """Get early close days for an exchange within a date range.

    Args:
        calendar_id: Exchange MIC code or alias
        start_date: Start date of the range
        end_date: End date of the range

    Returns:
        Polars DataFrame with columns:
        - date: Early close date
        - close_time: Early close time (local)

    Examples:
        &gt;&gt;&gt; early_closes = get_early_closes("NYSE", date(2024, 1, 1), date(2024, 12, 31))
        &gt;&gt;&gt; early_closes
        shape: (4, 2)
        ┌────────────┬────────────┐
        │ date       ┆ close_time │
        │ ---        ┆ ---        │
        │ date       ┆ time       │
        ╞════════════╪════════════╡
        │ 2024-07-03 ┆ 13:00:00   │  # Day before July 4th
        │ 2024-11-29 ┆ 13:00:00   │  # Day after Thanksgiving
        │ 2024-12-24 ┆ 13:00:00   │  # Christmas Eve
        └────────────┴────────────┘
    """
    # Get full schedule
    schedule = get_schedule(calendar_id, start_date, end_date)

    if schedule.is_empty():
        return pl.DataFrame(schema={"date": pl.Date, "close_time": pl.Time})

    calendar = get_calendar(calendar_id)

    # Standard close time for this exchange
    regular_close = calendar.close_time

    # Find days where close is earlier than regular
    # This requires converting UTC close to local time
    tz = str(calendar.tz)

    early_closes = schedule.with_columns(
        pl.col("market_close").dt.convert_time_zone(tz).dt.time().alias("close_time_local")
    ).filter(pl.col("close_time_local") &lt; pl.lit(regular_close))

    return early_closes.select(
        pl.col("session_date").alias("date"),
        pl.col("close_time_local").alias("close_time"),
    )
]]>
    </file>
    <file path="ml4t/backtest/config.py">
      <![CDATA["""
Backtest Configuration

Centralized configuration for all backtesting behavior. This allows:
1. Consistent behavior across all backtests
2. Easy replication of other frameworks (Backtrader, VectorBT, Zipline)
3. Clear documentation of all configurable behaviors
4. No code changes needed - just swap configuration files

Usage:
    from ml4t.backtest import BacktestConfig

    # Load default config
    config = BacktestConfig()

    # Load preset (e.g., backtrader-compatible)
    config = BacktestConfig.from_preset("backtrader")

    # Load from file
    config = BacktestConfig.from_yaml("my_config.yaml")
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from pathlib import Path

import yaml


class FillTiming(str, Enum):
    """When orders are filled relative to signal generation."""

    SAME_BAR = "same_bar"  # Fill on same bar as signal (look-ahead bias risk)
    NEXT_BAR_OPEN = "next_bar_open"  # Fill at next bar's open (most realistic)
    NEXT_BAR_CLOSE = "next_bar_close"  # Fill at next bar's close


class ExecutionPrice(str, Enum):
    """Price used for order execution."""

    CLOSE = "close"  # Use bar's close price
    OPEN = "open"  # Use bar's open price
    VWAP = "vwap"  # Volume-weighted average price (requires volume data)
    MID = "mid"  # (high + low) / 2


class ShareType(str, Enum):
    """Type of share quantities allowed."""

    FRACTIONAL = "fractional"  # Allow fractional shares (0.5, 1.234, etc.)
    INTEGER = "integer"  # Round down to whole shares (like most real brokers)


class SizingMethod(str, Enum):
    """How position size is calculated."""

    PERCENT_OF_PORTFOLIO = "percent_of_portfolio"  # % of total portfolio value
    PERCENT_OF_CASH = "percent_of_cash"  # % of available cash only
    FIXED_VALUE = "fixed_value"  # Fixed dollar amount per position
    FIXED_SHARES = "fixed_shares"  # Fixed number of shares


class SignalProcessing(str, Enum):
    """How signals are processed relative to existing positions."""

    CHECK_POSITION = "check_position"  # Only act if no existing position (event-driven)
    PROCESS_ALL = "process_all"  # Process all signals regardless (vectorized)


class CommissionModel(str, Enum):
    """Commission calculation method."""

    NONE = "none"  # No commission
    PERCENTAGE = "percentage"  # % of trade value
    PER_SHARE = "per_share"  # Fixed amount per share
    PER_TRADE = "per_trade"  # Fixed amount per trade
    TIERED = "tiered"  # Volume-based tiers


class SlippageModel(str, Enum):
    """Slippage calculation method."""

    NONE = "none"  # No slippage
    PERCENTAGE = "percentage"  # % of price
    FIXED = "fixed"  # Fixed dollar amount
    VOLUME_BASED = "volume_based"  # Based on trade size vs volume


class DataFrequency(str, Enum):
    """Data frequency for the backtest."""

    DAILY = "daily"  # Daily bars (EOD)
    MINUTE_1 = "1m"  # 1-minute bars
    MINUTE_5 = "5m"  # 5-minute bars
    MINUTE_15 = "15m"  # 15-minute bars
    MINUTE_30 = "30m"  # 30-minute bars
    HOURLY = "1h"  # Hourly bars
    IRREGULAR = "irregular"  # Trade bars, tick aggregations (no fixed frequency)


@dataclass
class BacktestConfig:
    """
    Complete configuration for backtesting behavior.

    All behavioral differences between frameworks are captured here.
    Load presets to match specific frameworks exactly.
    """

    # === Execution Timing ===
    fill_timing: FillTiming = FillTiming.NEXT_BAR_OPEN
    execution_price: ExecutionPrice = ExecutionPrice.CLOSE

    # === Position Sizing ===
    share_type: ShareType = ShareType.FRACTIONAL
    sizing_method: SizingMethod = SizingMethod.PERCENT_OF_PORTFOLIO
    default_position_pct: float = 0.10  # 10% of portfolio per position

    # === Signal Processing ===
    signal_processing: SignalProcessing = SignalProcessing.CHECK_POSITION
    accumulate_positions: bool = False  # Allow adding to existing positions

    # === Commission ===
    commission_model: CommissionModel = CommissionModel.PERCENTAGE
    commission_rate: float = 0.001  # 0.1% per trade
    commission_per_share: float = 0.0  # $ per share (if per_share model)
    commission_per_trade: float = 0.0  # $ per trade (if per_trade model)
    commission_minimum: float = 0.0  # Minimum commission per trade

    # === Slippage ===
    slippage_model: SlippageModel = SlippageModel.PERCENTAGE
    slippage_rate: float = 0.001  # 0.1%
    slippage_fixed: float = 0.0  # $ per share (if fixed model)

    # === Cash Management ===
    initial_cash: float = 100000.0
    allow_negative_cash: bool = False
    cash_buffer_pct: float = 0.0  # Reserve this % of cash (0 = use all)

    # === Order Handling ===
    reject_on_insufficient_cash: bool = True
    partial_fills_allowed: bool = False

    # === Account Type ===
    account_type: str = "cash"  # "cash" or "margin"
    margin_requirement: float = 0.5  # 50% margin requirement

    # === Calendar &amp; Timezone ===
    calendar: str | None = None  # Exchange calendar (e.g., "NYSE", "CME_Equity", "LSE")
    timezone: str = "UTC"  # Default timezone for naive datetimes
    data_frequency: DataFrequency = DataFrequency.DAILY  # Data frequency

    # === Metadata ===
    preset_name: str | None = None  # Name of preset this was loaded from

    def to_dict(self) -&gt; dict:
        """Convert config to dictionary for serialization."""
        return {
            "execution": {
                "fill_timing": self.fill_timing.value,
                "execution_price": self.execution_price.value,
            },
            "position_sizing": {
                "share_type": self.share_type.value,
                "sizing_method": self.sizing_method.value,
                "default_position_pct": self.default_position_pct,
            },
            "signals": {
                "signal_processing": self.signal_processing.value,
                "accumulate_positions": self.accumulate_positions,
            },
            "commission": {
                "model": self.commission_model.value,
                "rate": self.commission_rate,
                "per_share": self.commission_per_share,
                "per_trade": self.commission_per_trade,
                "minimum": self.commission_minimum,
            },
            "slippage": {
                "model": self.slippage_model.value,
                "rate": self.slippage_rate,
                "fixed": self.slippage_fixed,
            },
            "cash": {
                "initial": self.initial_cash,
                "allow_negative": self.allow_negative_cash,
                "buffer_pct": self.cash_buffer_pct,
            },
            "orders": {
                "reject_on_insufficient_cash": self.reject_on_insufficient_cash,
                "partial_fills_allowed": self.partial_fills_allowed,
            },
            "account": {
                "type": self.account_type,
                "margin_requirement": self.margin_requirement,
            },
        }

    @classmethod
    def from_dict(cls, data: dict, preset_name: str | None = None) -&gt; BacktestConfig:
        """Create config from dictionary."""
        exec_cfg = data.get("execution", {})
        sizing_cfg = data.get("position_sizing", {})
        signal_cfg = data.get("signals", {})
        comm_cfg = data.get("commission", {})
        slip_cfg = data.get("slippage", {})
        cash_cfg = data.get("cash", {})
        order_cfg = data.get("orders", {})
        acct_cfg = data.get("account", {})

        return cls(
            # Execution
            fill_timing=FillTiming(exec_cfg.get("fill_timing", "next_bar_open")),
            execution_price=ExecutionPrice(exec_cfg.get("execution_price", "close")),
            # Sizing
            share_type=ShareType(sizing_cfg.get("share_type", "fractional")),
            sizing_method=SizingMethod(sizing_cfg.get("sizing_method", "percent_of_portfolio")),
            default_position_pct=sizing_cfg.get("default_position_pct", 0.10),
            # Signals
            signal_processing=SignalProcessing(
                signal_cfg.get("signal_processing", "check_position")
            ),
            accumulate_positions=signal_cfg.get("accumulate_positions", False),
            # Commission
            commission_model=CommissionModel(comm_cfg.get("model", "percentage")),
            commission_rate=comm_cfg.get("rate", 0.001),
            commission_per_share=comm_cfg.get("per_share", 0.0),
            commission_per_trade=comm_cfg.get("per_trade", 0.0),
            commission_minimum=comm_cfg.get("minimum", 0.0),
            # Slippage
            slippage_model=SlippageModel(slip_cfg.get("model", "percentage")),
            slippage_rate=slip_cfg.get("rate", 0.001),
            slippage_fixed=slip_cfg.get("fixed", 0.0),
            # Cash
            initial_cash=cash_cfg.get("initial", 100000.0),
            allow_negative_cash=cash_cfg.get("allow_negative", False),
            cash_buffer_pct=cash_cfg.get("buffer_pct", 0.0),
            # Orders
            reject_on_insufficient_cash=order_cfg.get("reject_on_insufficient_cash", True),
            partial_fills_allowed=order_cfg.get("partial_fills_allowed", False),
            # Account
            account_type=acct_cfg.get("type", "cash"),
            margin_requirement=acct_cfg.get("margin_requirement", 0.5),
            # Metadata
            preset_name=preset_name,
        )

    def to_yaml(self, path: str | Path) -&gt; None:
        """Save config to YAML file."""
        path = Path(path)
        with open(path, "w") as f:
            yaml.dump(self.to_dict(), f, default_flow_style=False, sort_keys=False)

    @classmethod
    def from_yaml(cls, path: str | Path) -&gt; BacktestConfig:
        """Load config from YAML file."""
        path = Path(path)
        with open(path) as f:
            data = yaml.safe_load(f)
        return cls.from_dict(data, preset_name=path.stem)

    @classmethod
    def from_preset(cls, preset: str) -&gt; BacktestConfig:
        """
        Load a predefined configuration preset.

        Available presets:
        - "default": Sensible defaults for general use
        - "backtrader": Match Backtrader's default behavior
        - "vectorbt": Match VectorBT's default behavior
        - "zipline": Match Zipline's default behavior
        - "realistic": Conservative settings for realistic simulation
        """
        presets = {
            "default": cls._default_preset(),
            "backtrader": cls._backtrader_preset(),
            "vectorbt": cls._vectorbt_preset(),
            "zipline": cls._zipline_preset(),
            "realistic": cls._realistic_preset(),
        }

        if preset not in presets:
            available = ", ".join(presets.keys())
            raise ValueError(f"Unknown preset '{preset}'. Available: {available}")

        config = presets[preset]
        config.preset_name = preset
        return config

    @classmethod
    def _default_preset(cls) -&gt; BacktestConfig:
        """Default configuration - balanced between realism and ease of use."""
        return cls(
            fill_timing=FillTiming.NEXT_BAR_OPEN,
            execution_price=ExecutionPrice.OPEN,
            share_type=ShareType.FRACTIONAL,
            sizing_method=SizingMethod.PERCENT_OF_PORTFOLIO,
            default_position_pct=0.10,
            signal_processing=SignalProcessing.CHECK_POSITION,
            accumulate_positions=False,
            commission_model=CommissionModel.PERCENTAGE,
            commission_rate=0.001,
            slippage_model=SlippageModel.PERCENTAGE,
            slippage_rate=0.001,
            initial_cash=100000.0,
            allow_negative_cash=False,
            cash_buffer_pct=0.0,
            reject_on_insufficient_cash=True,
            partial_fills_allowed=False,
        )

    @classmethod
    def _backtrader_preset(cls) -&gt; BacktestConfig:
        """
        Match Backtrader's default behavior.

        Key characteristics:
        - INTEGER shares (rounds down to whole shares)
        - Next-bar execution (COO disabled by default)
        - Check position state before acting
        - Percentage commission
        """
        return cls(
            fill_timing=FillTiming.NEXT_BAR_OPEN,
            execution_price=ExecutionPrice.OPEN,
            share_type=ShareType.INTEGER,  # Key difference!
            sizing_method=SizingMethod.PERCENT_OF_PORTFOLIO,
            default_position_pct=0.10,
            signal_processing=SignalProcessing.CHECK_POSITION,
            accumulate_positions=False,
            commission_model=CommissionModel.PERCENTAGE,
            commission_rate=0.001,
            slippage_model=SlippageModel.PERCENTAGE,
            slippage_rate=0.001,
            initial_cash=100000.0,
            allow_negative_cash=False,
            cash_buffer_pct=0.0,
            reject_on_insufficient_cash=True,
            partial_fills_allowed=False,
        )

    @classmethod
    def _vectorbt_preset(cls) -&gt; BacktestConfig:
        """
        Match VectorBT's default behavior.

        Key characteristics:
        - FRACTIONAL shares
        - Same-bar execution (vectorized)
        - Process ALL signals (no position state check)
        - Percentage fees
        """
        return cls(
            fill_timing=FillTiming.SAME_BAR,  # Vectorized = same bar
            execution_price=ExecutionPrice.CLOSE,
            share_type=ShareType.FRACTIONAL,
            sizing_method=SizingMethod.PERCENT_OF_PORTFOLIO,
            default_position_pct=0.10,
            signal_processing=SignalProcessing.PROCESS_ALL,  # Key difference!
            accumulate_positions=False,  # Use accumulate=False
            commission_model=CommissionModel.PERCENTAGE,
            commission_rate=0.001,
            slippage_model=SlippageModel.PERCENTAGE,
            slippage_rate=0.001,
            initial_cash=100000.0,
            allow_negative_cash=False,
            cash_buffer_pct=0.0,
            reject_on_insufficient_cash=False,  # VectorBT is more permissive
            partial_fills_allowed=True,
        )

    @classmethod
    def _zipline_preset(cls) -&gt; BacktestConfig:
        """
        Match Zipline's default behavior.

        Key characteristics:
        - Next-bar execution (order on bar N, fill on bar N+1)
        - Integer shares
        - Per-share commission (IB-style)
        - Volume-based slippage
        """
        return cls(
            fill_timing=FillTiming.NEXT_BAR_OPEN,
            execution_price=ExecutionPrice.OPEN,
            share_type=ShareType.INTEGER,
            sizing_method=SizingMethod.PERCENT_OF_PORTFOLIO,
            default_position_pct=0.10,
            signal_processing=SignalProcessing.CHECK_POSITION,
            accumulate_positions=False,
            commission_model=CommissionModel.PER_SHARE,  # Zipline uses per-share
            commission_rate=0.0,
            commission_per_share=0.005,  # $0.005 per share (IB-style)
            commission_minimum=1.0,  # $1 minimum
            slippage_model=SlippageModel.VOLUME_BASED,  # Key difference!
            slippage_rate=0.1,  # 10% of bar volume
            initial_cash=100000.0,
            allow_negative_cash=False,
            cash_buffer_pct=0.0,
            reject_on_insufficient_cash=True,
            partial_fills_allowed=True,  # Volume-based = partial fills
        )

    @classmethod
    def _realistic_preset(cls) -&gt; BacktestConfig:
        """
        Conservative settings for realistic simulation.

        Key characteristics:
        - Integer shares (like real brokers)
        - Next-bar execution (no look-ahead)
        - Higher costs (more conservative)
        - Cash buffer (margin of safety)
        """
        return cls(
            fill_timing=FillTiming.NEXT_BAR_OPEN,
            execution_price=ExecutionPrice.OPEN,
            share_type=ShareType.INTEGER,
            sizing_method=SizingMethod.PERCENT_OF_PORTFOLIO,
            default_position_pct=0.05,  # Smaller positions
            signal_processing=SignalProcessing.CHECK_POSITION,
            accumulate_positions=False,
            commission_model=CommissionModel.PERCENTAGE,
            commission_rate=0.002,  # Higher commission
            slippage_model=SlippageModel.PERCENTAGE,
            slippage_rate=0.002,  # Higher slippage
            initial_cash=100000.0,
            allow_negative_cash=False,
            cash_buffer_pct=0.02,  # 2% cash buffer
            reject_on_insufficient_cash=True,
            partial_fills_allowed=False,
        )

    def describe(self) -&gt; str:
        """Return human-readable description of configuration."""
        lines = [
            f"BacktestConfig (preset: {self.preset_name or 'custom'})",
            "=" * 50,
            "",
            "Execution:",
            f"  Fill timing: {self.fill_timing.value}",
            f"  Execution price: {self.execution_price.value}",
            "",
            "Position Sizing:",
            f"  Share type: {self.share_type.value}",
            f"  Sizing method: {self.sizing_method.value}",
            f"  Default position: {self.default_position_pct:.1%}",
            "",
            "Signal Processing:",
            f"  Processing: {self.signal_processing.value}",
            f"  Accumulate: {self.accumulate_positions}",
            "",
            "Costs:",
            f"  Commission: {self.commission_model.value} @ {self.commission_rate:.2%}",
            f"  Slippage: {self.slippage_model.value} @ {self.slippage_rate:.2%}",
            "",
            "Cash:",
            f"  Initial: ${self.initial_cash:,.0f}",
            f"  Buffer: {self.cash_buffer_pct:.1%}",
            f"  Reject insufficient: {self.reject_on_insufficient_cash}",
        ]
        return "\n".join(lines)


# Export presets directory path for users who want to load custom YAML files
PRESETS_DIR = Path(__file__).parent / "presets"
]]>
    </file>
    <file path="ml4t/backtest/datafeed.py">
      <![CDATA["""Polars-based multi-asset data feed with O(1) timestamp lookups.

Memory-efficient implementation that stores partitioned DataFrames
and converts to dicts lazily at iteration time.
"""

from datetime import datetime
from typing import Any

import polars as pl


class DataFeed:
    """Polars-based multi-asset data feed with signals and context.

    Pre-partitions data by timestamp at initialization for O(1) lookups
    during iteration. DataFrames are stored in their native format and
    converted to dicts only at iteration time, reducing memory usage ~10x
    for large datasets.

    Memory Efficiency:
        - 1M bars: ~100 MB (was ~1 GB with pre-converted dicts)
        - 10M bars: ~1 GB (vs ~10+ GB with dicts)

    Usage:
        feed = DataFeed(prices_df=prices, signals_df=signals)
        for timestamp, assets_data, context in feed:
            # assets_data: {"AAPL": {"close": 150.0, "signals": {...}}, ...}
            process(timestamp, assets_data)
    """

    def __init__(
        self,
        prices_path: str | None = None,
        signals_path: str | None = None,
        context_path: str | None = None,
        prices_df: pl.DataFrame | None = None,
        signals_df: pl.DataFrame | None = None,
        context_df: pl.DataFrame | None = None,
    ):
        self.prices = (
            prices_df
            if prices_df is not None
            else (pl.scan_parquet(prices_path).collect() if prices_path else None)
        )
        self.signals = (
            signals_df
            if signals_df is not None
            else (pl.scan_parquet(signals_path).collect() if signals_path else None)
        )
        self.context = (
            context_df
            if context_df is not None
            else (pl.scan_parquet(context_path).collect() if context_path else None)
        )

        if self.prices is None:
            raise ValueError("prices_path or prices_df required")

        # Pre-partition data by timestamp for O(1) lookups
        # Store DataFrames (memory efficient) instead of dicts (memory explosion)
        self._prices_by_ts = self._partition_by_timestamp(self.prices)
        self._signals_by_ts = (
            self._partition_by_timestamp(self.signals) if self.signals is not None else {}
        )
        self._context_by_ts = (
            self._partition_by_timestamp(self.context) if self.context is not None else {}
        )

        self._timestamps = self._get_timestamps()
        self._idx = 0

    def _partition_by_timestamp(self, df: pl.DataFrame) -&gt; dict[datetime, pl.DataFrame]:
        """Partition DataFrame into dict keyed by timestamp for O(1) access.

        Uses Polars partition_by which is highly optimized and maintains
        data in columnar format (minimal memory overhead).
        """
        result: dict[datetime, pl.DataFrame] = {}
        for ts_df in df.partition_by("timestamp", maintain_order=True):
            ts = ts_df["timestamp"][0]
            result[ts] = ts_df
        return result

    def _get_timestamps(self) -&gt; list[datetime]:
        """Get sorted list of all timestamps across all data sources."""
        all_ts = set(self._prices_by_ts.keys())
        all_ts.update(self._signals_by_ts.keys())
        all_ts.update(self._context_by_ts.keys())
        return sorted(all_ts)

    def __iter__(self):
        self._idx = 0
        return self

    def __len__(self) -&gt; int:
        return len(self._timestamps)

    @property
    def n_bars(self) -&gt; int:
        """Number of unique timestamps/bars."""
        return len(self._timestamps)

    def __next__(self) -&gt; tuple[datetime, dict[str, dict], dict[str, Any]]:
        if self._idx &gt;= len(self._timestamps):
            raise StopIteration

        ts = self._timestamps[self._idx]
        self._idx += 1

        # O(1) lookup + lazy conversion to dicts (only for current bar)
        assets_data: dict[str, dict[str, Any]] = {}

        # Convert price DataFrame slice to dicts (lazy, only current bar)
        price_df = self._prices_by_ts.get(ts)
        if price_df is not None:
            for row in price_df.iter_rows(named=True):
                asset = row["asset"]
                assets_data[asset] = {
                    "open": row.get("open"),
                    "high": row.get("high"),
                    "low": row.get("low"),
                    "close": row.get("close"),
                    "volume": row.get("volume"),
                    "signals": {},
                }

        # Add signals for each asset - lazy conversion
        signal_df = self._signals_by_ts.get(ts)
        if signal_df is not None:
            for row in signal_df.iter_rows(named=True):
                asset = row["asset"]
                if asset in assets_data:
                    for k, v in row.items():
                        if k not in ("timestamp", "asset"):
                            assets_data[asset]["signals"][k] = v

        # Get context at this timestamp - lazy conversion
        context_data: dict[str, Any] = {}
        ctx_df = self._context_by_ts.get(ts)
        if ctx_df is not None and len(ctx_df) &gt; 0:
            row = ctx_df.row(0, named=True)
            for k, v in row.items():
                if k != "timestamp":
                    context_data[k] = v

        return ts, assets_data, context_data
]]>
    </file>
    <file path="ml4t/backtest/engine.py">
      <![CDATA["""Backtesting engine orchestration."""

from __future__ import annotations

from datetime import datetime
from typing import TYPE_CHECKING

import polars as pl

from .analytics import EquityCurve, TradeAnalyzer
from .broker import Broker
from .datafeed import DataFeed
from .models import CommissionModel, PercentageCommission, PercentageSlippage, SlippageModel
from .strategy import Strategy
from .types import ContractSpec, ExecutionMode, StopFillMode, StopLevelBasis

if TYPE_CHECKING:
    from .config import BacktestConfig


class Engine:
    """Backtesting engine."""

    def __init__(
        self,
        feed: DataFeed,
        strategy: Strategy,
        initial_cash: float = 100000.0,
        commission_model: CommissionModel | None = None,
        slippage_model: SlippageModel | None = None,
        execution_mode: ExecutionMode = ExecutionMode.SAME_BAR,
        stop_fill_mode: StopFillMode = StopFillMode.STOP_PRICE,
        stop_level_basis: StopLevelBasis = StopLevelBasis.FILL_PRICE,
        account_type: str = "cash",
        initial_margin: float = 0.5,
        maintenance_margin: float = 0.25,
        config: BacktestConfig | None = None,
        execution_limits=None,
        market_impact_model=None,
        contract_specs: dict[str, ContractSpec] | None = None,
    ):
        self.feed = feed
        self.strategy = strategy
        self.execution_mode = execution_mode
        self.stop_fill_mode = stop_fill_mode
        self.stop_level_basis = stop_level_basis
        self.config = config  # Store config for strategy access
        self.broker = Broker(
            initial_cash=initial_cash,
            commission_model=commission_model,
            slippage_model=slippage_model,
            execution_mode=execution_mode,
            stop_fill_mode=stop_fill_mode,
            stop_level_basis=stop_level_basis,
            account_type=account_type,
            initial_margin=initial_margin,
            maintenance_margin=maintenance_margin,
            execution_limits=execution_limits,
            market_impact_model=market_impact_model,
            contract_specs=contract_specs,
        )
        self.equity_curve: list[tuple[datetime, float]] = []

    def run(self) -&gt; dict:
        """Run backtest and return results."""
        self.strategy.on_start(self.broker)

        for timestamp, assets_data, context in self.feed:
            prices = {a: d["close"] for a, d in assets_data.items() if d.get("close")}
            opens = {a: d.get("open", d.get("close")) for a, d in assets_data.items()}
            highs = {a: d.get("high", d.get("close")) for a, d in assets_data.items()}
            lows = {a: d.get("low", d.get("close")) for a, d in assets_data.items()}
            volumes = {a: d.get("volume", 0) for a, d in assets_data.items()}
            signals = {a: d.get("signals", {}) for a, d in assets_data.items()}

            self.broker._update_time(timestamp, prices, opens, highs, lows, volumes, signals)

            # Process pending exits from NEXT_BAR_OPEN mode (fills at open)
            # This must happen BEFORE evaluate_position_rules() to clear deferred exits
            self.broker._process_pending_exits()

            # Evaluate position rules (stops, trails, etc.) - generates exit orders
            self.broker.evaluate_position_rules()

            if self.execution_mode == ExecutionMode.NEXT_BAR:
                # Next-bar mode: process pending orders at open price
                self.broker._process_orders(use_open=True)
                # Strategy generates new orders
                self.strategy.on_data(timestamp, assets_data, context, self.broker)
                # New orders will be processed next bar
            else:
                # Same-bar mode: process before and after strategy
                self.broker._process_orders()
                self.strategy.on_data(timestamp, assets_data, context, self.broker)
                self.broker._process_orders()

            self.equity_curve.append((timestamp, self.broker.get_account_value()))

        self.strategy.on_end(self.broker)
        return self._generate_results()

    def _generate_results(self) -&gt; dict:
        """Generate backtest results with full analytics."""
        if not self.equity_curve:
            return {}

        # Build EquityCurve from raw data
        equity = EquityCurve()
        for ts, value in self.equity_curve:
            equity.append(ts, value)

        # Build TradeAnalyzer
        trade_analyzer = TradeAnalyzer(self.broker.trades)

        # Combine into results (backward compatible + new metrics)
        return {
            # Core metrics (backward compatible)
            "initial_cash": equity.initial_value,
            "final_value": equity.final_value,
            "total_return": equity.total_return,
            "total_return_pct": equity.total_return * 100,
            "max_drawdown": abs(equity.max_dd),  # Keep as positive for backward compat
            "max_drawdown_pct": abs(equity.max_dd) * 100,
            "num_trades": trade_analyzer.num_trades,
            "winning_trades": trade_analyzer.num_winners,
            "losing_trades": trade_analyzer.num_losers,
            "win_rate": trade_analyzer.win_rate,
            # Commission/slippage from fills (includes open positions)
            "total_commission": sum(f.commission for f in self.broker.fills),
            "total_slippage": sum(f.slippage for f in self.broker.fills),
            # Raw data
            "trades": self.broker.trades,
            "equity_curve": self.equity_curve,
            "fills": self.broker.fills,
            # NEW: Analytics objects for detailed analysis
            "equity": equity,
            "trade_analyzer": trade_analyzer,
            # NEW: Additional metrics
            "sharpe": equity.sharpe(),
            "sortino": equity.sortino(),
            "calmar": equity.calmar,
            "cagr": equity.cagr,
            "volatility": equity.volatility,
            "profit_factor": trade_analyzer.profit_factor,
            "expectancy": trade_analyzer.expectancy,
            "avg_trade": trade_analyzer.avg_trade,
            "avg_win": trade_analyzer.avg_win,
            "avg_loss": trade_analyzer.avg_loss,
            "largest_win": trade_analyzer.largest_win,
            "largest_loss": trade_analyzer.largest_loss,
        }

    @classmethod
    def from_config(
        cls,
        feed: DataFeed,
        strategy: Strategy,
        config: BacktestConfig,
    ) -&gt; Engine:
        """
        Create an Engine instance from a BacktestConfig.

        This is the recommended way to create an engine when you want
        to replicate specific framework behavior (Backtrader, VectorBT, etc.).

        Example:
            from ml4t.backtest import Engine, BacktestConfig, DataFeed, Strategy

            # Use Backtrader-compatible settings
            config = BacktestConfig.from_preset("backtrader")
            engine = Engine.from_config(feed, strategy, config)
            results = engine.run()

        Args:
            feed: DataFeed with price data
            strategy: Strategy to execute
            config: BacktestConfig with all behavioral settings

        Returns:
            Configured Engine instance
        """
        from .config import CommissionModel as CommModelEnum
        from .config import FillTiming
        from .config import SlippageModel as SlipModelEnum

        # Map config fill timing to ExecutionMode
        if config.fill_timing == FillTiming.SAME_BAR:
            execution_mode = ExecutionMode.SAME_BAR
        else:
            # NEXT_BAR_OPEN or NEXT_BAR_CLOSE both use NEXT_BAR mode
            execution_mode = ExecutionMode.NEXT_BAR

        # Build commission model from config
        commission_model: CommissionModel | None = None
        if config.commission_model == CommModelEnum.PERCENTAGE:
            commission_model = PercentageCommission(
                rate=config.commission_rate,
            )
        elif config.commission_model == CommModelEnum.PER_SHARE:
            from .models import PerShareCommission

            commission_model = PerShareCommission(
                per_share=config.commission_per_share,
                minimum=config.commission_minimum,
            )
        elif config.commission_model == CommModelEnum.PER_TRADE:
            from .models import NoCommission

            # For per-trade, we'd need a new model, use NoCommission for now
            commission_model = NoCommission()
        # NONE or unrecognized -&gt; None (will use NoCommission in Broker)

        # Build slippage model from config
        slippage_model: SlippageModel | None = None
        if config.slippage_model == SlipModelEnum.PERCENTAGE:
            slippage_model = PercentageSlippage(rate=config.slippage_rate)
        elif config.slippage_model == SlipModelEnum.FIXED:
            from .models import FixedSlippage

            slippage_model = FixedSlippage(amount=config.slippage_fixed)
        # NONE, VOLUME_BASED, or unrecognized -&gt; None (will use NoSlippage)

        return cls(
            feed=feed,
            strategy=strategy,
            initial_cash=config.initial_cash,
            commission_model=commission_model,
            slippage_model=slippage_model,
            execution_mode=execution_mode,
            account_type=config.account_type,
            initial_margin=config.margin_requirement,
            maintenance_margin=config.margin_requirement * 0.5,  # Standard ratio
            config=config,  # Store config for strategy access
        )


# === Convenience Function ===


def run_backtest(
    prices: pl.DataFrame | str,
    strategy: Strategy,
    signals: pl.DataFrame | str | None = None,
    context: pl.DataFrame | str | None = None,
    config: BacktestConfig | str | None = None,
    # Legacy parameters (used if config is None)
    initial_cash: float = 100000.0,
    commission_model: CommissionModel | None = None,
    slippage_model: SlippageModel | None = None,
    execution_mode: ExecutionMode = ExecutionMode.SAME_BAR,
) -&gt; dict:
    """
    Run a backtest with minimal setup.

    Args:
        prices: Price DataFrame or path to parquet file
        strategy: Strategy instance to execute
        signals: Optional signals DataFrame or path
        context: Optional context DataFrame or path
        config: BacktestConfig instance, preset name (str), or None for legacy params
        initial_cash: Starting cash (legacy, ignored if config provided)
        commission_model: Commission model (legacy, ignored if config provided)
        slippage_model: Slippage model (legacy, ignored if config provided)
        execution_mode: Execution mode (legacy, ignored if config provided)

    Returns:
        Results dictionary with metrics, trades, equity curve

    Example:
        # Using config preset
        results = run_backtest(prices_df, strategy, config="backtrader")

        # Using custom config
        config = BacktestConfig.from_preset("backtrader")
        config.commission_rate = 0.002  # Higher commission
        results = run_backtest(prices_df, strategy, config=config)
    """
    feed = DataFeed(
        prices_path=prices if isinstance(prices, str) else None,
        signals_path=signals if isinstance(signals, str) else None,
        context_path=context if isinstance(context, str) else None,
        prices_df=prices if isinstance(prices, pl.DataFrame) else None,
        signals_df=signals if isinstance(signals, pl.DataFrame) else None,
        context_df=context if isinstance(context, pl.DataFrame) else None,
    )

    # Handle config parameter
    if config is not None:
        from .config import BacktestConfig as ConfigCls

        if isinstance(config, str):
            config = ConfigCls.from_preset(config)
        return Engine.from_config(feed, strategy, config).run()

    # Legacy path: use individual parameters
    engine = Engine(
        feed,
        strategy,
        initial_cash,
        commission_model=commission_model,
        slippage_model=slippage_model,
        execution_mode=execution_mode,
    )
    return engine.run()


# Backward compatibility: BacktestEngine was renamed to Engine in v0.2.0
BacktestEngine = Engine
]]>
    </file>
    <file path="ml4t/backtest/execution/__init__.py">
      <![CDATA["""Execution model for realistic order fills.

This module provides:
- Volume participation limits (max % of bar volume)
- Partial fills (fill what's possible, queue remainder)
- Market impact modeling (price impact based on size vs volume)
- Portfolio rebalancing utilities (target weight → orders)
"""

from .impact import (
    LinearImpact,
    MarketImpactModel,
    NoImpact,
    SquareRootImpact,
)
from .limits import (
    ExecutionLimits,
    NoLimits,
    VolumeParticipationLimit,
)
from .rebalancer import (
    RebalanceConfig,
    TargetWeightExecutor,
)
from .result import ExecutionResult

__all__ = [
    # Limits
    "ExecutionLimits",
    "NoLimits",
    "VolumeParticipationLimit",
    # Impact
    "MarketImpactModel",
    "NoImpact",
    "LinearImpact",
    "SquareRootImpact",
    # Rebalancing
    "RebalanceConfig",
    "TargetWeightExecutor",
    # Result
    "ExecutionResult",
]
]]>
    </file>
    <file path="ml4t/backtest/execution/impact.py">
      <![CDATA["""Market impact models for realistic execution costs."""

import math
from abc import ABC, abstractmethod
from dataclasses import dataclass


class MarketImpactModel(ABC):
    """Base class for market impact models.

    Market impact models estimate how order execution affects price.
    Larger orders relative to volume cause more adverse price movement.
    """

    @abstractmethod
    def calculate(
        self,
        quantity: float,
        price: float,
        volume: float | None,
        is_buy: bool,
    ) -&gt; float:
        """Calculate price impact.

        Args:
            quantity: Order quantity (positive)
            price: Current market price
            volume: Bar volume (None if unavailable)
            is_buy: True for buy orders, False for sell

        Returns:
            Impact in price units (positive = adverse, negative = favorable)
            For buys: price increases; for sells: price decreases
        """
        pass


@dataclass
class NoImpact(MarketImpactModel):
    """No market impact - fill at quoted price.

    Default for simple backtests. Appropriate for small orders
    relative to market volume.
    """

    def calculate(
        self,
        quantity: float,
        price: float,
        volume: float | None,
        is_buy: bool,
    ) -&gt; float:
        """No impact - return 0."""
        return 0.0


@dataclass
class LinearImpact(MarketImpactModel):
    """Linear market impact model.

    Impact = coefficient * (quantity / volume) * price

    Simple model where impact scales linearly with participation rate.
    Appropriate for liquid markets with moderate order sizes.

    Args:
        coefficient: Impact scaling factor (default 0.1)
                    Higher values = more impact per unit participation
        permanent_fraction: Fraction of impact that is permanent (0-1)
                           Remainder is temporary and reverts

    Example:
        model = LinearImpact(coefficient=0.1)
        # 10% participation at $100 price = $1.00 impact
    """

    coefficient: float = 0.1
    permanent_fraction: float = 0.5

    def calculate(
        self,
        quantity: float,
        price: float,
        volume: float | None,
        is_buy: bool,
    ) -&gt; float:
        """Calculate linear impact."""
        if volume is None or volume == 0:
            return 0.0

        participation = quantity / volume
        impact = self.coefficient * participation * price

        # Apply direction (buys push price up, sells push price down)
        return impact if is_buy else -impact


@dataclass
class SquareRootImpact(MarketImpactModel):
    """Square root market impact model (Almgren-Chriss style).

    Impact = coefficient * sigma * sqrt(quantity / ADV) * price

    Based on academic market microstructure research. Impact scales
    with the square root of order size, which matches empirical observations.

    Args:
        coefficient: Scaling factor (default 0.5, typical range 0.1-1.0)
        volatility: Daily volatility (sigma, default 0.02 = 2%)
        adv_factor: Average daily volume as multiple of bar volume
                   (default 1.0 for daily bars, 390 for minute bars)

    Example:
        model = SquareRootImpact(coefficient=0.5, volatility=0.02)
        # For order = 1% of ADV at 2% vol, $100 price:
        # Impact = 0.5 * 0.02 * sqrt(0.01) * 100 = $0.10
    """

    coefficient: float = 0.5
    volatility: float = 0.02
    adv_factor: float = 1.0

    def calculate(
        self,
        quantity: float,
        price: float,
        volume: float | None,
        is_buy: bool,
    ) -&gt; float:
        """Calculate square root impact."""
        if volume is None or volume == 0:
            return 0.0

        adv = volume * self.adv_factor
        participation = quantity / adv

        # Square root impact
        impact = self.coefficient * self.volatility * math.sqrt(participation) * price

        return impact if is_buy else -impact


@dataclass
class PowerLawImpact(MarketImpactModel):
    """Generalized power law impact model.

    Impact = coefficient * (quantity / volume)^exponent * price

    Flexible model that can represent various impact regimes.
    - exponent = 1.0: Linear (like LinearImpact)
    - exponent = 0.5: Square root (like SquareRootImpact)
    - exponent &lt; 0.5: Concave (impact flattens for large orders)
    - exponent &gt; 1.0: Convex (impact accelerates for large orders)

    Args:
        coefficient: Scaling factor (default 0.1)
        exponent: Power law exponent (default 0.5)
        min_impact: Minimum impact per trade (fixed cost, default 0)

    Example:
        model = PowerLawImpact(coefficient=0.1, exponent=0.6)
    """

    coefficient: float = 0.1
    exponent: float = 0.5
    min_impact: float = 0.0

    def calculate(
        self,
        quantity: float,
        price: float,
        volume: float | None,
        is_buy: bool,
    ) -&gt; float:
        """Calculate power law impact."""
        if volume is None or volume == 0:
            return self.min_impact if is_buy else -self.min_impact

        participation = quantity / volume

        # Power law impact
        impact = self.coefficient * (participation**self.exponent) * price
        impact = max(impact, self.min_impact)

        return impact if is_buy else -impact
]]>
    </file>
    <file path="ml4t/backtest/execution/limits.py">
      <![CDATA["""Volume participation limits for realistic execution."""

from abc import ABC, abstractmethod
from dataclasses import dataclass

from .result import ExecutionResult


class ExecutionLimits(ABC):
    """Base class for execution limits.

    Execution limits determine how much of an order can be filled
    in a single bar based on volume constraints.
    """

    @abstractmethod
    def calculate(
        self,
        order_quantity: float,
        bar_volume: float | None,
        price: float,
    ) -&gt; ExecutionResult:
        """Calculate executable quantity given volume constraints.

        Args:
            order_quantity: Total order quantity (positive)
            bar_volume: Bar's trading volume (None if unavailable)
            price: Current price for the asset

        Returns:
            ExecutionResult with fillable and remaining quantities
        """
        pass


@dataclass
class NoLimits(ExecutionLimits):
    """No volume limits - fill entire order immediately.

    This is the default behavior for simple backtests where
    market impact and liquidity are not a concern.
    """

    def calculate(
        self,
        order_quantity: float,
        bar_volume: float | None,
        price: float,
    ) -&gt; ExecutionResult:
        """Fill entire order with no restrictions."""
        return ExecutionResult(
            fillable_quantity=order_quantity,
            remaining_quantity=0.0,
            adjusted_price=price,
            impact_cost=0.0,
            participation_rate=0.0
            if bar_volume is None or bar_volume == 0
            else order_quantity / bar_volume,
        )


@dataclass
class VolumeParticipationLimit(ExecutionLimits):
    """Limit order fill to a percentage of bar volume.

    Common institutional constraint to avoid excessive market impact.
    Typical values: 5-20% of average daily volume.

    Args:
        max_participation: Maximum fraction of bar volume to fill (0.0-1.0)
                          Default 0.10 = 10% of bar volume
        min_volume: Minimum bar volume required to execute (default 0)
                   Orders won't fill on bars with volume below this

    Example:
        limit = VolumeParticipationLimit(max_participation=0.10)
        # If bar volume is 10,000 shares, max fill is 1,000 shares
        # Order for 2,500 shares fills 1,000, queues 1,500
    """

    max_participation: float = 0.10
    min_volume: float = 0.0

    def calculate(
        self,
        order_quantity: float,
        bar_volume: float | None,
        price: float,
    ) -&gt; ExecutionResult:
        """Calculate fillable quantity based on participation rate."""
        # No volume data - can't apply limit, fill entire order
        if bar_volume is None:
            return ExecutionResult(
                fillable_quantity=order_quantity,
                remaining_quantity=0.0,
                adjusted_price=price,
                participation_rate=0.0,
            )

        # Volume below minimum - no fill this bar
        if bar_volume &lt; self.min_volume:
            return ExecutionResult(
                fillable_quantity=0.0,
                remaining_quantity=order_quantity,
                adjusted_price=price,
                participation_rate=0.0,
            )

        # Calculate max fillable based on participation limit
        max_fillable = bar_volume * self.max_participation
        fillable = min(order_quantity, max_fillable)
        remaining = order_quantity - fillable

        participation_rate = fillable / bar_volume if bar_volume &gt; 0 else 0.0

        return ExecutionResult(
            fillable_quantity=fillable,
            remaining_quantity=remaining,
            adjusted_price=price,
            participation_rate=participation_rate,
        )


@dataclass
class AdaptiveParticipationLimit(ExecutionLimits):
    """Participation rate that adapts based on volatility/spread.

    More aggressive when conditions are favorable (tight spread, low vol),
    more conservative when conditions are unfavorable.

    Args:
        base_participation: Base participation rate (default 0.10)
        volatility_key: Key in context for current volatility
        spread_key: Key in context for current bid-ask spread
        max_participation: Upper bound on participation (default 0.25)
        min_participation: Lower bound on participation (default 0.02)

    Example:
        limit = AdaptiveParticipationLimit(base_participation=0.10)
        # Participation increases when volatility is low
        # Participation decreases when spread is wide
    """

    base_participation: float = 0.10
    volatility_factor: float = 0.5  # Reduce participation by this * normalized_vol
    max_participation: float = 0.25
    min_participation: float = 0.02
    avg_volatility: float = 0.02  # Baseline volatility for normalization

    def calculate(
        self,
        order_quantity: float,
        bar_volume: float | None,
        price: float,
        volatility: float | None = None,
    ) -&gt; ExecutionResult:
        """Calculate fillable with adaptive participation."""
        if bar_volume is None:
            return ExecutionResult(
                fillable_quantity=order_quantity,
                remaining_quantity=0.0,
                adjusted_price=price,
            )

        # Adjust participation based on volatility
        participation = self.base_participation

        if volatility is not None and self.avg_volatility &gt; 0:
            # Higher volatility = lower participation
            vol_ratio = volatility / self.avg_volatility
            adjustment = self.volatility_factor * (vol_ratio - 1.0)
            participation = participation * (1.0 - adjustment)

        # Clamp to bounds
        participation = max(self.min_participation, min(self.max_participation, participation))

        max_fillable = bar_volume * participation
        fillable = min(order_quantity, max_fillable)
        remaining = order_quantity - fillable

        return ExecutionResult(
            fillable_quantity=fillable,
            remaining_quantity=remaining,
            adjusted_price=price,
            participation_rate=fillable / bar_volume if bar_volume &gt; 0 else 0.0,
        )
]]>
    </file>
    <file path="ml4t/backtest/execution/rebalancer.py">
      <![CDATA["""Portfolio rebalancing utilities for target weight execution.

This module provides utilities for converting portfolio target weights to orders,
enabling integration with external portfolio optimizers like riskfolio-lib,
PyPortfolioOpt, or cvxpy.

Example:
    from ml4t.backtest import TargetWeightExecutor, RebalanceConfig

    executor = TargetWeightExecutor(config=RebalanceConfig(
        min_trade_value=500,
        allow_fractional=True,
    ))

    # In strategy.on_data():
    target_weights = {'AAPL': 0.3, 'GOOG': 0.3, 'MSFT': 0.35}  # 5% cash
    orders = executor.execute(target_weights, data, broker)
"""

from dataclasses import dataclass
from typing import TYPE_CHECKING, Protocol

if TYPE_CHECKING:
    from ..broker import Broker
    from ..types import Order

from ..types import OrderSide


class WeightProvider(Protocol):
    """Protocol for anything that produces target weights."""

    def get_weights(self, data: dict, broker: "Broker") -&gt; dict[str, float]:
        """Return target weights (asset -&gt; weight, should sum to &lt;= 1.0)."""
        ...


@dataclass
class RebalanceConfig:
    """Configuration for rebalancing behavior.

    Attributes:
        min_trade_value: Skip trades with absolute value smaller than this ($).
        min_weight_change: Skip if weight change is smaller than this (decimal).
        allow_fractional: Allow fractional shares (default: False, whole shares only).
        round_lots: Round to lot_size increments (e.g., 100-share lots).
        lot_size: Lot size for rounding (only used if round_lots=True).
        allow_short: Allow short positions via negative weights.
        max_single_weight: Maximum weight allowed for any single asset.
        cancel_before_rebalance: Cancel pending orders before rebalancing (safest).
        account_for_pending: Consider pending orders when calculating current weights.
    """

    # Trade thresholds
    min_trade_value: float = 100.0
    min_weight_change: float = 0.01

    # Share handling
    allow_fractional: bool = False
    round_lots: bool = False
    lot_size: int = 100

    # Position constraints
    allow_short: bool = False
    max_single_weight: float = 1.0

    # Order handling
    cancel_before_rebalance: bool = True
    account_for_pending: bool = True


class TargetWeightExecutor:
    """Convert target portfolio weights to orders.

    Handles the common pattern of rebalancing to target weights:
    - Computes required trades from current vs target positions
    - Accounts for pending orders to prevent double-allocation
    - Applies minimum trade thresholds
    - Handles lot rounding and fractional shares
    - Respects position limits

    Example:
        executor = TargetWeightExecutor(config=RebalanceConfig(
            min_trade_value=500,
            round_lots=True,
        ))

        # In strategy:
        target_weights = {'AAPL': 0.3, 'GOOG': 0.3, 'MSFT': 0.4}
        orders = executor.execute(target_weights, data, broker)
    """

    def __init__(self, config: RebalanceConfig | None = None):
        """Initialize the executor with optional configuration.

        Args:
            config: Rebalancing configuration. Uses defaults if not provided.
        """
        self.config = config or RebalanceConfig()

    def execute(
        self,
        target_weights: dict[str, float],
        data: dict[str, dict],
        broker: "Broker",
    ) -&gt; list["Order"]:
        """Execute rebalancing to target weights.

        Args:
            target_weights: Dict of asset -&gt; target weight (0.0 to 1.0).
                            Sum can be &lt; 1.0 to hold cash.
            data: Current bar data (for prices). Format: {asset: {'close': price, ...}}
            broker: Broker instance for order submission.

        Returns:
            List of submitted orders.
        """
        # 1. Cancel pending orders if configured (prevents double-allocation)
        if self.config.cancel_before_rebalance:
            for order in list(broker.pending_orders):
                broker.cancel_order(order.order_id)

        equity = broker.get_account_value()
        if equity &lt;= 0:
            return []

        orders: list["Order"] = []

        # 2. Get current weights (effective or actual based on config)
        if self.config.account_for_pending and not self.config.cancel_before_rebalance:
            current_weights = self._get_effective_weights(broker, data)
        else:
            current_weights = self._get_current_weights(broker, data)

        # 3. Validate total weight &lt;= 1.0 (allow cash targeting)
        total_target = sum(target_weights.values())
        if total_target &gt; 1.0 + 1e-6:
            # Scale down to prevent over-allocation
            scale = 1.0 / total_target
            target_weights = {k: v * scale for k, v in target_weights.items()}

        # 4. Process each target asset
        for asset, target_wt in target_weights.items():
            order = self._process_asset(
                asset, target_wt, current_weights, equity, data, broker
            )
            if order is not None:
                orders.append(order)

        # 5. Close positions not in target
        for asset in current_weights:
            if asset not in target_weights:
                pos = broker.get_position(asset)
                if pos and pos.quantity != 0:
                    order = broker.close_position(asset)
                    if order:
                        orders.append(order)

        return orders

    def _process_asset(
        self,
        asset: str,
        target_wt: float,
        current_weights: dict[str, float],
        equity: float,
        data: dict[str, dict],
        broker: "Broker",
    ) -&gt; "Order | None":
        """Process a single asset for rebalancing.

        Returns:
            Order if trade needed, None otherwise.
        """
        # Apply constraints
        target_wt = min(target_wt, self.config.max_single_weight)
        if target_wt &lt; 0 and not self.config.allow_short:
            target_wt = 0

        current_wt = current_weights.get(asset, 0.0)
        weight_delta = target_wt - current_wt

        # Skip small weight changes
        if abs(weight_delta) &lt; self.config.min_weight_change:
            return None

        # Get price
        price = data.get(asset, {}).get("close")
        if not price or price &lt;= 0:
            return None

        # Compute trade value
        delta_value = equity * weight_delta

        # Skip small trades
        if abs(delta_value) &lt; self.config.min_trade_value:
            return None

        # Compute shares
        shares = delta_value / price

        # Apply share rounding
        if self.config.round_lots:
            shares = round(shares / self.config.lot_size) * self.config.lot_size
        elif not self.config.allow_fractional:
            shares = int(shares)

        if shares == 0:
            return None

        # Submit order
        side = OrderSide.BUY if shares &gt; 0 else OrderSide.SELL
        return broker.submit_order(asset, abs(shares), side)

    def _get_current_weights(
        self, broker: "Broker", data: dict[str, dict]
    ) -&gt; dict[str, float]:
        """Get current portfolio weights from held positions only.

        Args:
            broker: Broker instance.
            data: Current bar data for prices.

        Returns:
            Dict of asset -&gt; current weight.
        """
        equity = broker.get_account_value()
        if equity &lt;= 0:
            return {}

        weights = {}
        for asset, pos in broker.positions.items():
            price = data.get(asset, {}).get("close", pos.entry_price)
            value = pos.quantity * price
            weights[asset] = value / equity

        return weights

    def _get_effective_weights(
        self, broker: "Broker", data: dict[str, dict]
    ) -&gt; dict[str, float]:
        """Get effective weights including pending orders.

        This prevents double-allocation when execute() is called multiple times
        before orders fill (e.g., with ExecutionMode.NEXT_BAR or LIMIT orders).

        Args:
            broker: Broker instance.
            data: Current bar data for prices.

        Returns:
            Dict of asset -&gt; effective weight (positions + pending orders).
        """
        equity = broker.get_account_value()
        if equity &lt;= 0:
            return {}

        # Start with actual positions
        effective_value: dict[str, float] = {}
        for asset, pos in broker.positions.items():
            price = data.get(asset, {}).get("close", pos.entry_price)
            effective_value[asset] = pos.quantity * price

        # Add net value of pending orders
        for order in broker.pending_orders:
            price = order.limit_price or data.get(order.asset, {}).get("close")
            if price:
                # BUY adds value, SELL subtracts
                sign = 1 if order.side == OrderSide.BUY else -1
                delta = order.quantity * price * sign
                effective_value[order.asset] = (
                    effective_value.get(order.asset, 0) + delta
                )

        return {k: v / equity for k, v in effective_value.items()}

    def preview(
        self,
        target_weights: dict[str, float],
        data: dict[str, dict],
        broker: "Broker",
    ) -&gt; list[dict]:
        """Preview trades without executing.

        Useful for debugging and understanding what trades would be generated.

        Args:
            target_weights: Dict of asset -&gt; target weight.
            data: Current bar data.
            broker: Broker instance.

        Returns:
            List of trade previews with asset, current_weight, target_weight,
            shares, value, and skip_reason (if applicable).
        """
        equity = broker.get_account_value()
        if equity &lt;= 0:
            return []

        if self.config.account_for_pending and not self.config.cancel_before_rebalance:
            current_weights = self._get_effective_weights(broker, data)
        else:
            current_weights = self._get_current_weights(broker, data)

        previews = []

        for asset, target_wt in target_weights.items():
            current_wt = current_weights.get(asset, 0.0)
            price = data.get(asset, {}).get("close", 0)
            weight_delta = target_wt - current_wt

            if price &gt; 0:
                delta_value = equity * weight_delta
                shares = delta_value / price

                # Determine if would be skipped
                skip_reason = None
                if abs(weight_delta) &lt; self.config.min_weight_change:
                    skip_reason = "weight_change_too_small"
                elif abs(delta_value) &lt; self.config.min_trade_value:
                    skip_reason = "trade_value_too_small"
                elif not self.config.allow_fractional and abs(int(shares)) == 0:
                    skip_reason = "rounds_to_zero_shares"

                previews.append(
                    {
                        "asset": asset,
                        "current_weight": current_wt,
                        "target_weight": target_wt,
                        "weight_delta": weight_delta,
                        "shares": shares,
                        "value": delta_value,
                        "skip_reason": skip_reason,
                    }
                )

        # Add positions not in target (will be closed)
        for asset in current_weights:
            if asset not in target_weights:
                pos = broker.get_position(asset)
                if pos and pos.quantity != 0:
                    price = data.get(asset, {}).get("close", pos.entry_price)
                    current_wt = current_weights.get(asset, 0.0)
                    previews.append(
                        {
                            "asset": asset,
                            "current_weight": current_wt,
                            "target_weight": 0.0,
                            "weight_delta": -current_wt,
                            "shares": -pos.quantity,
                            "value": -pos.quantity * price,
                            "skip_reason": None,
                            "action": "close_position",
                        }
                    )

        return previews
]]>
    </file>
    <file path="ml4t/backtest/execution/result.py">
      <![CDATA["""Execution result for partial fills."""

from dataclasses import dataclass


@dataclass
class ExecutionResult:
    """Result of execution limit/impact calculation.

    Attributes:
        fillable_quantity: Quantity that can be filled this bar
        remaining_quantity: Quantity that must wait for next bar
        adjusted_price: Price after market impact adjustment
        impact_cost: Cost of market impact (price difference * quantity)
        participation_rate: Actual participation rate (fillable / volume)
    """

    fillable_quantity: float
    remaining_quantity: float
    adjusted_price: float
    impact_cost: float = 0.0
    participation_rate: float = 0.0

    @property
    def is_partial(self) -&gt; bool:
        """True if order was partially filled."""
        return self.remaining_quantity &gt; 0

    @property
    def is_full(self) -&gt; bool:
        """True if entire order was filled."""
        return self.remaining_quantity == 0
]]>
    </file>
    <file path="ml4t/backtest/models.py">
      <![CDATA["""Pluggable commission and slippage models."""

from typing import Protocol, runtime_checkable

# === Protocols ===


@runtime_checkable
class CommissionModel(Protocol):
    """Protocol for commission calculation."""

    def calculate(self, asset: str, quantity: float, price: float) -&gt; float: ...


@runtime_checkable
class SlippageModel(Protocol):
    """Protocol for slippage/market impact calculation."""

    def calculate(
        self, asset: str, quantity: float, price: float, volume: float | None
    ) -&gt; float: ...


# === Commission Models ===


class NoCommission:
    """Zero commission."""

    def calculate(self, asset: str, quantity: float, price: float) -&gt; float:
        return 0.0


class PercentageCommission:
    """Commission as percentage of trade value."""

    def __init__(self, rate: float = 0.001):
        self.rate = rate

    def calculate(self, asset: str, quantity: float, price: float) -&gt; float:
        return abs(quantity * price * self.rate)


class PerShareCommission:
    """Fixed commission per share with optional minimum."""

    def __init__(self, per_share: float = 0.005, minimum: float = 1.0):
        self.per_share = per_share
        self.minimum = minimum

    def calculate(self, asset: str, quantity: float, price: float) -&gt; float:
        return max(abs(quantity) * self.per_share, self.minimum)


class TieredCommission:
    """Tiered commission based on trade value."""

    def __init__(self, tiers: list[tuple[float, float]]):
        # [(threshold, rate), ...] e.g. [(10000, 0.001), (50000, 0.0008), (inf, 0.0005)]
        self.tiers = sorted(tiers, key=lambda x: x[0])

    def calculate(self, asset: str, quantity: float, price: float) -&gt; float:
        value = abs(quantity * price)
        for threshold, rate in self.tiers:
            if value &lt;= threshold:
                return value * rate
        return value * self.tiers[-1][1]


class CombinedCommission:
    """Combined percentage + fixed commission per trade."""

    def __init__(self, percentage: float = 0.0, fixed: float = 0.0):
        self.percentage = percentage
        self.fixed = fixed

    def calculate(self, asset: str, quantity: float, price: float) -&gt; float:
        value = abs(quantity * price)
        return value * self.percentage + self.fixed


# === Slippage Models ===


class NoSlippage:
    """Zero slippage."""

    def calculate(self, asset: str, quantity: float, price: float, volume: float | None) -&gt; float:
        return 0.0


class FixedSlippage:
    """Fixed slippage per share."""

    def __init__(self, amount: float = 0.01):
        self.amount = amount

    def calculate(self, asset: str, quantity: float, price: float, volume: float | None) -&gt; float:
        return abs(quantity) * self.amount


class PercentageSlippage:
    """Slippage as percentage of price (per-unit price adjustment)."""

    def __init__(self, rate: float = 0.001):
        self.rate = rate

    def calculate(self, asset: str, quantity: float, price: float, volume: float | None) -&gt; float:
        # Return per-unit price adjustment (not total dollars)
        # Broker adds this to fill price: fill = base_price ± slippage
        return price * self.rate


class VolumeShareSlippage:
    """Slippage based on order size vs volume (market impact)."""

    def __init__(self, impact_factor: float = 0.1):
        self.impact_factor = impact_factor

    def calculate(self, asset: str, quantity: float, price: float, volume: float | None) -&gt; float:
        if volume is None or volume == 0:
            return 0.0
        volume_fraction = abs(quantity) / volume
        impact = volume_fraction * self.impact_factor
        # Return per-unit price adjustment (not total dollars)
        return price * impact
]]>
    </file>
    <file path="ml4t/backtest/risk/__init__.py">
      <![CDATA["""Risk management framework for ml4t-backtest.

Provides position-level and portfolio-level risk management including:
- Static exits (stop-loss, take-profit, time exit)
- Dynamic exits (trailing stop, tightening trail, scaled exit)
- Signal-based exits
- Rule composition (RuleChain, AllOf, AnyOf)
- Portfolio-level limits (drawdown, position count, exposure)
"""

# Portfolio-level risk
from .portfolio import (
    DailyLossLimit,
    GrossExposureLimit,
    MaxDrawdownLimit,
    MaxExposureLimit,
    MaxPositionsLimit,
    NetExposureLimit,
    PortfolioLimit,
    PortfolioState,
    RiskManager,
)

# Position rules
from .position import (
    AllOf,
    AnyOf,
    PositionRule,
    RuleChain,
    ScaledExit,
    SignalExit,
    StopLoss,
    TakeProfit,
    TighteningTrailingStop,
    TimeExit,
    TrailingStop,
)
from .types import ActionType, PositionAction, PositionState

__all__ = [
    # Types
    "ActionType",
    "PositionAction",
    "PositionState",
    # Protocol
    "PositionRule",
    # Static rules
    "StopLoss",
    "TakeProfit",
    "TimeExit",
    # Dynamic rules
    "TrailingStop",
    "TighteningTrailingStop",
    "ScaledExit",
    # Signal rules
    "SignalExit",
    # Composition
    "RuleChain",
    "AllOf",
    "AnyOf",
    # Portfolio risk
    "RiskManager",
    "PortfolioLimit",
    "PortfolioState",
    "MaxDrawdownLimit",
    "MaxPositionsLimit",
    "MaxExposureLimit",
    "DailyLossLimit",
    "GrossExposureLimit",
    "NetExposureLimit",
]
]]>
    </file>
    <file path="ml4t/backtest/risk/portfolio/__init__.py">
      <![CDATA["""Portfolio-level risk management.

This module provides portfolio-wide risk constraints and limits:
- Max drawdown limits (stop trading when drawdown exceeds threshold)
- Position limits (max positions, max per-asset exposure)
- Daily loss limits (halt trading after daily loss)
- Exposure limits (gross/net exposure limits)
"""

from .limits import (
    DailyLossLimit,
    GrossExposureLimit,
    LimitResult,
    MaxDrawdownLimit,
    MaxExposureLimit,
    MaxPositionsLimit,
    NetExposureLimit,
    PortfolioLimit,
    PortfolioState,
)
from .manager import RiskManager

__all__ = [
    "RiskManager",
    "PortfolioLimit",
    "PortfolioState",
    "LimitResult",
    "MaxDrawdownLimit",
    "MaxPositionsLimit",
    "MaxExposureLimit",
    "DailyLossLimit",
    "GrossExposureLimit",
    "NetExposureLimit",
]
]]>
    </file>
    <file path="ml4t/backtest/risk/portfolio/limits.py">
      <![CDATA["""Portfolio-level risk limits."""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import date, datetime


class PortfolioLimit(ABC):
    """Base class for portfolio-level risk limits."""

    @abstractmethod
    def check(self, state: "PortfolioState") -&gt; "LimitResult":
        """Check if limit is breached.

        Args:
            state: Current portfolio state

        Returns:
            LimitResult indicating if breached and any actions to take
        """
        pass


@dataclass
class LimitResult:
    """Result of a portfolio limit check.

    Attributes:
        breached: True if limit was breached
        action: Action to take ("none", "warn", "reduce", "halt")
        reason: Human-readable explanation
        reduction_pct: If action=="reduce", percentage to reduce by
    """

    breached: bool
    action: str = "none"  # "none", "warn", "reduce", "halt"
    reason: str = ""
    reduction_pct: float = 0.0

    @classmethod
    def ok(cls) -&gt; "LimitResult":
        return cls(breached=False)

    @classmethod
    def warn(cls, reason: str) -&gt; "LimitResult":
        return cls(breached=True, action="warn", reason=reason)

    @classmethod
    def reduce(cls, reason: str, pct: float) -&gt; "LimitResult":
        return cls(breached=True, action="reduce", reason=reason, reduction_pct=pct)

    @classmethod
    def halt(cls, reason: str) -&gt; "LimitResult":
        return cls(breached=True, action="halt", reason=reason)


@dataclass
class PortfolioState:
    """Current state of the portfolio for risk checks.

    Attributes:
        equity: Current portfolio equity value
        initial_equity: Starting equity value
        high_water_mark: Highest equity reached
        current_drawdown: Current drawdown from high water mark (0 to 1)
        num_positions: Number of open positions
        positions: Dict of asset -&gt; position value
        daily_pnl: P&amp;L since start of trading day
        gross_exposure: Sum of absolute position values
        net_exposure: Sum of signed position values
        timestamp: Current time
    """

    equity: float
    initial_equity: float
    high_water_mark: float
    current_drawdown: float  # 0.0 to 1.0
    num_positions: int
    positions: dict[str, float]  # asset -&gt; market value
    daily_pnl: float
    gross_exposure: float
    net_exposure: float
    timestamp: date | datetime | None = None


@dataclass
class MaxDrawdownLimit(PortfolioLimit):
    """Halt trading when drawdown exceeds threshold.

    Args:
        max_drawdown: Maximum allowed drawdown (0.0-1.0)
                     Default 0.20 = 20% max drawdown
        action: Action when breached ("warn", "reduce", "halt")
                Default "halt" - stops all new trades
        warn_threshold: Optional earlier threshold for warnings

    Example:
        limit = MaxDrawdownLimit(max_drawdown=0.20, warn_threshold=0.15)
        # Warns at 15% drawdown, halts at 20%
    """

    max_drawdown: float = 0.20
    action: str = "halt"
    warn_threshold: float | None = None

    def check(self, state: PortfolioState) -&gt; LimitResult:
        if state.current_drawdown &gt;= self.max_drawdown:
            return LimitResult(
                breached=True,
                action=self.action,
                reason=f"drawdown {state.current_drawdown:.1%} &gt;= {self.max_drawdown:.1%}",
            )

        if self.warn_threshold and state.current_drawdown &gt;= self.warn_threshold:
            return LimitResult.warn(
                f"drawdown {state.current_drawdown:.1%} &gt;= warn threshold {self.warn_threshold:.1%}"
            )

        return LimitResult.ok()


@dataclass
class MaxPositionsLimit(PortfolioLimit):
    """Limit maximum number of open positions.

    Args:
        max_positions: Maximum number of simultaneous positions
        action: Action when breached ("warn", "halt")

    Example:
        limit = MaxPositionsLimit(max_positions=10)
        # Prevents opening more than 10 positions
    """

    max_positions: int = 10
    action: str = "halt"

    def check(self, state: PortfolioState) -&gt; LimitResult:
        if state.num_positions &gt;= self.max_positions:
            return LimitResult(
                breached=True,
                action=self.action,
                reason=f"positions {state.num_positions} &gt;= max {self.max_positions}",
            )
        return LimitResult.ok()


@dataclass
class MaxExposureLimit(PortfolioLimit):
    """Limit maximum exposure to a single asset.

    Args:
        max_exposure_pct: Maximum position size as % of equity (0.0-1.0)
                         Default 0.10 = 10% max per asset
        action: Action when breached

    Example:
        limit = MaxExposureLimit(max_exposure_pct=0.10)
        # No single position can be &gt; 10% of portfolio
    """

    max_exposure_pct: float = 0.10
    action: str = "warn"

    def check(self, state: PortfolioState) -&gt; LimitResult:
        for asset, value in state.positions.items():
            exposure_pct = abs(value) / state.equity if state.equity &gt; 0 else 0
            if exposure_pct &gt; self.max_exposure_pct:
                return LimitResult(
                    breached=True,
                    action=self.action,
                    reason=f"{asset} exposure {exposure_pct:.1%} &gt; max {self.max_exposure_pct:.1%}",
                )
        return LimitResult.ok()


@dataclass
class DailyLossLimit(PortfolioLimit):
    """Halt trading when daily loss exceeds threshold.

    Args:
        max_daily_loss_pct: Maximum daily loss as % of equity (0.0-1.0)
                           Default 0.02 = 2% max daily loss
        action: Action when breached

    Example:
        limit = DailyLossLimit(max_daily_loss_pct=0.02)
        # Halt if down more than 2% today
    """

    max_daily_loss_pct: float = 0.02
    action: str = "halt"

    def check(self, state: PortfolioState) -&gt; LimitResult:
        if state.equity &gt; 0:
            daily_loss_pct = -state.daily_pnl / state.equity if state.daily_pnl &lt; 0 else 0
            if daily_loss_pct &gt; self.max_daily_loss_pct:
                return LimitResult(
                    breached=True,
                    action=self.action,
                    reason=f"daily loss {daily_loss_pct:.1%} &gt; max {self.max_daily_loss_pct:.1%}",
                )
        return LimitResult.ok()


@dataclass
class GrossExposureLimit(PortfolioLimit):
    """Limit total gross exposure (sum of absolute positions).

    Args:
        max_gross_exposure: Maximum gross exposure as multiple of equity
                           Default 1.0 = 100% gross exposure (no leverage)
        action: Action when breached

    Example:
        limit = GrossExposureLimit(max_gross_exposure=2.0)
        # Allow up to 2x leverage
    """

    max_gross_exposure: float = 1.0
    action: str = "halt"

    def check(self, state: PortfolioState) -&gt; LimitResult:
        if state.equity &gt; 0:
            gross_ratio = state.gross_exposure / state.equity
            if gross_ratio &gt; self.max_gross_exposure:
                return LimitResult(
                    breached=True,
                    action=self.action,
                    reason=f"gross exposure {gross_ratio:.1%} &gt; max {self.max_gross_exposure:.1%}",
                )
        return LimitResult.ok()


@dataclass
class NetExposureLimit(PortfolioLimit):
    """Limit net exposure (for market-neutral strategies).

    Args:
        max_net_exposure: Maximum net exposure as % of equity (-1.0 to 1.0)
        min_net_exposure: Minimum net exposure (for enforcing hedging)
        action: Action when breached

    Example:
        limit = NetExposureLimit(max_net_exposure=0.10, min_net_exposure=-0.10)
        # Stay within +/- 10% net exposure (near market-neutral)
    """

    max_net_exposure: float = 1.0
    min_net_exposure: float = -1.0
    action: str = "warn"

    def check(self, state: PortfolioState) -&gt; LimitResult:
        if state.equity &gt; 0:
            net_ratio = state.net_exposure / state.equity
            if net_ratio &gt; self.max_net_exposure:
                return LimitResult(
                    breached=True,
                    action=self.action,
                    reason=f"net exposure {net_ratio:.1%} &gt; max {self.max_net_exposure:.1%}",
                )
            if net_ratio &lt; self.min_net_exposure:
                return LimitResult(
                    breached=True,
                    action=self.action,
                    reason=f"net exposure {net_ratio:.1%} &lt; min {self.min_net_exposure:.1%}",
                )
        return LimitResult.ok()
]]>
    </file>
    <file path="ml4t/backtest/risk/portfolio/manager.py">
      <![CDATA["""RiskManager for portfolio-level risk management."""

from dataclasses import dataclass, field
from datetime import date, datetime

from .limits import LimitResult, PortfolioLimit, PortfolioState


@dataclass
class RiskManager:
    """Portfolio-level risk manager.

    Monitors portfolio-wide risk metrics and enforces limits.
    Integrates with Broker to prevent trades that would breach limits.

    Args:
        limits: List of PortfolioLimit rules to enforce

    Example:
        from ml4t.backtest.risk.portfolio import (
            RiskManager, MaxDrawdownLimit, MaxPositionsLimit
        )

        manager = RiskManager(limits=[
            MaxDrawdownLimit(max_drawdown=0.20),
            MaxPositionsLimit(max_positions=10),
        ])

        # In strategy or engine:
        if manager.can_open_position():
            broker.submit_order(...)
    """

    limits: list[PortfolioLimit] = field(default_factory=list)

    # Tracking state
    _initial_equity: float = 0.0
    _high_water_mark: float = 0.0
    _daily_start_equity: float = 0.0
    _last_date: date | None = None
    _halted: bool = False
    _halt_reason: str = ""
    _warnings: list[str] = field(default_factory=list)

    def initialize(self, initial_equity: float, timestamp: datetime | None = None) -&gt; None:
        """Initialize the risk manager with starting equity.

        Args:
            initial_equity: Starting portfolio value
            timestamp: Optional starting timestamp
        """
        self._initial_equity = initial_equity
        self._high_water_mark = initial_equity
        self._daily_start_equity = initial_equity
        self._last_date = timestamp.date() if timestamp else None
        self._halted = False
        self._halt_reason = ""
        self._warnings = []

    def update(
        self,
        equity: float,
        positions: dict[str, float],
        timestamp: datetime | None = None,
    ) -&gt; list[LimitResult]:
        """Update risk state and check all limits.

        Args:
            equity: Current portfolio equity
            positions: Dict of asset -&gt; position market value
            timestamp: Current timestamp

        Returns:
            List of LimitResult for any breached limits
        """
        # Update high water mark
        if equity &gt; self._high_water_mark:
            self._high_water_mark = equity

        # Check for new trading day
        if timestamp:
            current_date = timestamp.date()
            if self._last_date and current_date != self._last_date:
                # New day - reset daily P&amp;L tracking
                self._daily_start_equity = equity
                self._warnings = []  # Clear daily warnings
            self._last_date = current_date

        # Build portfolio state
        state = self._build_state(equity, positions, timestamp)

        # Check all limits
        results = []
        self._warnings = []

        for limit in self.limits:
            result = limit.check(state)
            if result.breached:
                results.append(result)

                if result.action == "halt":
                    self._halted = True
                    self._halt_reason = result.reason
                elif result.action == "warn":
                    self._warnings.append(result.reason)

        return results

    def _build_state(
        self,
        equity: float,
        positions: dict[str, float],
        timestamp: date | datetime | None,
    ) -&gt; PortfolioState:
        """Build PortfolioState from current data."""
        # Calculate drawdown
        if self._high_water_mark &gt; 0:
            drawdown = (self._high_water_mark - equity) / self._high_water_mark
        else:
            drawdown = 0.0

        # Calculate daily P&amp;L
        daily_pnl = equity - self._daily_start_equity

        # Calculate exposures
        gross_exposure = sum(abs(v) for v in positions.values())
        net_exposure = sum(positions.values())

        return PortfolioState(
            equity=equity,
            initial_equity=self._initial_equity,
            high_water_mark=self._high_water_mark,
            current_drawdown=max(0, drawdown),
            num_positions=len(positions),
            positions=positions,
            daily_pnl=daily_pnl,
            gross_exposure=gross_exposure,
            net_exposure=net_exposure,
            timestamp=timestamp,
        )

    def can_open_position(self) -&gt; bool:
        """Check if new positions can be opened.

        Returns:
            True if trading is allowed, False if halted
        """
        return not self._halted

    def can_increase_position(self, asset: str, amount: float) -&gt; tuple[bool, str]:
        """Check if a position increase is allowed.

        Args:
            asset: Asset symbol
            amount: Additional market value

        Returns:
            Tuple of (allowed, reason)
        """
        if self._halted:
            return False, self._halt_reason
        return True, ""

    @property
    def is_halted(self) -&gt; bool:
        """True if trading is halted due to risk limit breach."""
        return self._halted

    @property
    def halt_reason(self) -&gt; str:
        """Reason for halt, empty if not halted."""
        return self._halt_reason

    @property
    def warnings(self) -&gt; list[str]:
        """Current warning messages."""
        return self._warnings

    @property
    def current_drawdown(self) -&gt; float:
        """Current drawdown from high water mark (0 to 1)."""
        if self._high_water_mark &gt; 0:
            # This is a snapshot - actual drawdown needs current equity
            return 0.0
        return 0.0

    def reset_halt(self) -&gt; None:
        """Manually reset halt state (use with caution)."""
        self._halted = False
        self._halt_reason = ""

    def get_state(self, equity: float, positions: dict[str, float]) -&gt; PortfolioState:
        """Get current portfolio state for external inspection.

        Args:
            equity: Current portfolio equity
            positions: Dict of asset -&gt; position market value

        Returns:
            PortfolioState with all calculated metrics
        """
        return self._build_state(equity, positions, self._last_date)
]]>
    </file>
    <file path="ml4t/backtest/risk/position/__init__.py">
      <![CDATA["""Position-level risk rules."""

from .composite import AllOf, AnyOf, RuleChain
from .dynamic import ScaledExit, TighteningTrailingStop, TrailingStop
from .protocol import PositionRule
from .signal import SignalExit
from .static import StopLoss, TakeProfit, TimeExit

__all__ = [
    # Protocol
    "PositionRule",
    # Static rules
    "StopLoss",
    "TakeProfit",
    "TimeExit",
    # Dynamic rules
    "TrailingStop",
    "TighteningTrailingStop",
    "ScaledExit",
    # Signal rules
    "SignalExit",
    # Composition
    "RuleChain",
    "AllOf",
    "AnyOf",
]
]]>
    </file>
    <file path="ml4t/backtest/risk/position/composite.py">
      <![CDATA["""Composite rules for combining multiple position rules."""

from dataclasses import dataclass

from ..types import ActionType, PositionAction, PositionState
from .protocol import PositionRule


@dataclass
class RuleChain:
    """Evaluate rules in order, first non-HOLD action wins.

    This is the most common composition pattern - rules are checked
    in priority order and the first rule to trigger takes effect.

    Args:
        rules: List of rules to evaluate in order

    Example:
        chain = RuleChain([
            StopLoss(pct=0.05),           # Highest priority
            ScaledExit([(0.10, 0.5)]),    # Second priority
            TighteningTrailingStop([...]), # Third priority
            TimeExit(bars=20),             # Lowest priority
        ])
    """

    rules: list[PositionRule]

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Evaluate rules in order, return first non-HOLD action."""
        for rule in self.rules:
            action = rule.evaluate(state)
            if action.action != ActionType.HOLD:
                return action
        return PositionAction.hold()


@dataclass
class AllOf:
    """All rules must return non-HOLD for the action to trigger.

    Useful for requiring multiple conditions to be true before exiting.
    Returns the first rule's action details (pct, stop_price, etc.).

    Args:
        rules: List of rules that must all agree

    Example:
        # Exit only if both profitable AND held long enough
        rule = AllOf([
            TakeProfit(pct=0.0),   # Must be profitable
            TimeExit(bars=5),       # Must have held 5+ bars
        ])
    """

    rules: list[PositionRule]

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Return action only if ALL rules return non-HOLD."""
        actions = [rule.evaluate(state) for rule in self.rules]

        if all(a.action != ActionType.HOLD for a in actions):
            # All triggered - return first rule's action with combined reason
            reasons = [a.reason for a in actions if a.reason]
            first = actions[0]
            return PositionAction(
                action=first.action,
                pct=first.pct,
                stop_price=first.stop_price,
                reason=" AND ".join(reasons) if reasons else "",
            )

        return PositionAction.hold()


@dataclass
class AnyOf:
    """First rule to return non-HOLD wins (alias for RuleChain).

    Semantically equivalent to RuleChain but named for clarity
    when composing complex rule logic.

    Args:
        rules: List of rules where any can trigger

    Example:
        # Exit on stop-loss OR signal
        rule = AnyOf([
            StopLoss(pct=0.05),
            SignalExit(threshold=0.5),
        ])
    """

    rules: list[PositionRule]

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Return first non-HOLD action (same as RuleChain)."""
        for rule in self.rules:
            action = rule.evaluate(state)
            if action.action != ActionType.HOLD:
                return action
        return PositionAction.hold()
]]>
    </file>
    <file path="ml4t/backtest/risk/position/dynamic.py">
      <![CDATA["""Dynamic exit rules - thresholds that change based on position state."""

from dataclasses import dataclass, field

from ..types import PositionAction, PositionState


@dataclass
class TrailingStop:
    """Exit when price retraces from high water mark.

    For longs: Exit if price drops X% from highest price since entry
    For shorts: Exit if price rises X% from lowest price since entry

    Args:
        pct: Trail percentage as decimal (0.05 = 5% trail)

    Example:
        rule = TrailingStop(pct=0.05)  # 5% trailing stop
    """

    pct: float

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Exit if price retraces beyond trail."""
        if state.is_long:
            # Long: stop triggers when price drops below (high - trail%)
            stop_price = state.high_water_mark * (1 - self.pct)
            if state.current_price &lt;= stop_price:
                return PositionAction.exit_full(f"trailing_stop_{self.pct:.1%}")
        else:
            # Short: stop triggers when price rises above (low + trail%)
            stop_price = state.low_water_mark * (1 + self.pct)
            if state.current_price &gt;= stop_price:
                return PositionAction.exit_full(f"trailing_stop_{self.pct:.1%}")

        return PositionAction.hold()


@dataclass
class TighteningTrailingStop:
    """Trailing stop that tightens as profit increases.

    The trail percentage decreases at higher profit levels, locking in
    more gains as the position becomes more profitable.

    Args:
        schedule: List of (return_threshold, trail_pct) tuples.
                  Must be sorted by return_threshold ascending.

    Example:
        rule = TighteningTrailingStop([
            (0.0, 0.05),   # At 0% return: 5% trail
            (0.10, 0.03),  # At 10%+ return: 3% trail
            (0.20, 0.02),  # At 20%+ return: 2% trail
        ])
    """

    schedule: list[tuple[float, float]]

    def __post_init__(self):
        # Sort by return threshold descending for efficient lookup
        self._schedule = sorted(self.schedule, key=lambda x: x[0], reverse=True)

    def _get_trail_pct(self, unrealized_return: float) -&gt; float:
        """Get applicable trail percentage based on current return."""
        for threshold, trail_pct in self._schedule:
            if unrealized_return &gt;= threshold:
                return trail_pct
        # Default to last (loosest) trail if no threshold met
        return self._schedule[-1][1] if self._schedule else 0.05

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Exit if price retraces beyond dynamic trail."""
        trail_pct = self._get_trail_pct(state.unrealized_return)

        if state.is_long:
            stop_price = state.high_water_mark * (1 - trail_pct)
            if state.current_price &lt;= stop_price:
                return PositionAction.exit_full(
                    f"tightening_trail_{trail_pct:.1%}_at_{state.unrealized_return:.1%}"
                )
        else:
            stop_price = state.low_water_mark * (1 + trail_pct)
            if state.current_price &gt;= stop_price:
                return PositionAction.exit_full(
                    f"tightening_trail_{trail_pct:.1%}_at_{state.unrealized_return:.1%}"
                )

        return PositionAction.hold()


@dataclass
class ScaledExit:
    """Exit portions of position at profit targets.

    Allows scaling out of positions by exiting a percentage at each
    profit level. Tracks which levels have been triggered to avoid
    duplicate exits.

    Args:
        targets: List of (return_threshold, exit_pct) tuples.
                 exit_pct is relative to CURRENT position size.

    Example:
        rule = ScaledExit([
            (0.05, 0.25),  # At +5%: exit 25% of position
            (0.10, 0.33),  # At +10%: exit 33% of remaining
            (0.15, 0.50),  # At +15%: exit 50% of remaining
        ])

    Note:
        This rule tracks triggered levels internally. For proper operation
        in backtesting, create a new instance per position.
    """

    targets: list[tuple[float, float]]
    _triggered: set[float] = field(default_factory=set, repr=False)

    def __post_init__(self):
        # Sort by return threshold ascending
        self._targets = sorted(self.targets, key=lambda x: x[0])

    def reset(self):
        """Reset triggered levels (call when position closes)."""
        self._triggered = set()

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Check if any untriggered profit target is hit."""
        for threshold, exit_pct in self._targets:
            if threshold not in self._triggered and state.unrealized_return &gt;= threshold:
                self._triggered.add(threshold)
                return PositionAction.exit_partial(
                    exit_pct, f"scale_out_{threshold:.0%}_{exit_pct:.0%}"
                )
        return PositionAction.hold()
]]>
    </file>
    <file path="ml4t/backtest/risk/position/protocol.py">
      <![CDATA["""Protocol definition for position rules."""

from typing import Protocol, runtime_checkable

from ..types import PositionAction, PositionState


@runtime_checkable
class PositionRule(Protocol):
    """Protocol for position-level risk rules.

    All position rules must implement the evaluate() method which takes
    the current position state and returns an action.

    Rules are stateless by design - any state tracking (like triggered
    profit targets) should be stored on the Position object, not the rule.

    Example:
        class MyCustomRule:
            def __init__(self, threshold: float):
                self.threshold = threshold

            def evaluate(self, state: PositionState) -&gt; PositionAction:
                if state.unrealized_return &gt; self.threshold:
                    return PositionAction.exit_full("threshold_reached")
                return PositionAction.hold()
    """

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Evaluate rule against current position state.

        Args:
            state: Current position state with prices, P&amp;L, etc.

        Returns:
            PositionAction indicating what to do (HOLD, EXIT_FULL, etc.)
        """
        ...
]]>
    </file>
    <file path="ml4t/backtest/risk/position/signal.py">
      <![CDATA["""Signal-based exit rules - exits triggered by strategy signals."""

from dataclasses import dataclass

from ..types import PositionAction, PositionState


@dataclass
class SignalExit:
    """Exit when strategy provides an exit signal.

    Looks for a signal in the position's context dict. For long positions,
    exits on negative signals; for short positions, exits on positive signals.

    Args:
        signal_name: Key to look for in state.context
        threshold: Signal must exceed this threshold to trigger
                   (in absolute value terms)

    Example:
        # In strategy.on_data():
        broker.update_position_context("AAPL", {"exit_signal": -0.5})

        # Rule definition:
        rule = SignalExit(signal_name="exit_signal", threshold=0.3)
        # Long exits if exit_signal &lt; -0.3
        # Short exits if exit_signal &gt; 0.3
    """

    signal_name: str = "exit_signal"
    threshold: float = 0.0

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Exit if signal exceeds threshold."""
        signal = state.context.get(self.signal_name)
        if signal is None:
            return PositionAction.hold()

        if state.is_long:
            # Long position: exit on negative signal
            if signal &lt; -self.threshold:
                return PositionAction.exit_full(f"signal_exit_{signal:.2f}")
        else:
            # Short position: exit on positive signal
            if signal &gt; self.threshold:
                return PositionAction.exit_full(f"signal_exit_{signal:.2f}")

        return PositionAction.hold()


@dataclass
class VolatilityTrailingStop:
    """Trailing stop based on volatility (e.g., ATR).

    Trail distance is dynamically adjusted based on a volatility measure
    provided in the position context.

    Args:
        volatility_key: Key in context containing current volatility value
        multiplier: Trail = volatility * multiplier

    Example:
        # In strategy.on_data():
        broker.update_position_context("AAPL", {"atr": 2.50})

        # Rule definition:
        rule = VolatilityTrailingStop(volatility_key="atr", multiplier=2.0)
        # Trail distance = 2.50 * 2.0 = 5.0 price units
    """

    volatility_key: str = "atr"
    multiplier: float = 2.0

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Exit if price retraces beyond volatility-based trail."""
        vol = state.context.get(self.volatility_key)
        if vol is None or vol &lt;= 0:
            return PositionAction.hold()

        trail_distance = vol * self.multiplier

        if state.is_long:
            stop_price = state.high_water_mark - trail_distance
            if state.current_price &lt;= stop_price:
                return PositionAction.exit_full(f"vol_trail_{self.multiplier}x_{vol:.2f}")
        else:
            stop_price = state.low_water_mark + trail_distance
            if state.current_price &gt;= stop_price:
                return PositionAction.exit_full(f"vol_trail_{self.multiplier}x_{vol:.2f}")

        return PositionAction.hold()
]]>
    </file>
    <file path="ml4t/backtest/risk/position/static.py">
      <![CDATA["""Static exit rules - fixed thresholds that don't change."""

from dataclasses import dataclass

from ..types import PositionAction, PositionState


def _get_stop_fill_mode(context: dict):
    """Get StopFillMode from context, defaulting to STOP_PRICE."""
    from ml4t.backtest.types import StopFillMode

    return context.get("stop_fill_mode", StopFillMode.STOP_PRICE)


def _get_stop_base_price(state, context: dict) -&gt; float:
    """Get the base price for stop level calculation.

    If stop_level_basis is SIGNAL_PRICE and signal_price is available,
    use signal_price (Backtrader behavior). Otherwise use entry_price.
    """
    from ml4t.backtest.types import StopLevelBasis

    basis = context.get("stop_level_basis", StopLevelBasis.FILL_PRICE)
    if basis == StopLevelBasis.SIGNAL_PRICE:
        signal_price = context.get("signal_price")
        if signal_price is not None:
            return signal_price
    return state.entry_price


@dataclass
class StopLoss:
    """Exit when stop price is breached during the bar.

    Stop orders trigger when the bar's price range touches the stop level.
    Fill price depends on StopFillMode configuration:
    - STOP_PRICE: Fill at exact stop price (standard model, default)
    - BAR_EXTREME: Fill at bar's low (matches VectorBT Pro behavior)

    For long positions: stop triggers if bar_low &lt;= stop_price
    For short positions: stop triggers if bar_high &gt;= stop_price

    Args:
        pct: Maximum loss as decimal (0.05 = 5% loss triggers exit)

    Example:
        rule = StopLoss(pct=0.05)  # Exit at -5%
    """

    pct: float

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Exit if stop price was breached during the bar."""
        from ml4t.backtest.types import StopFillMode

        # Get base price for stop level calculation (entry_price or signal_price)
        base_price = _get_stop_base_price(state, state.context)

        # Calculate stop price from base
        if state.is_long:
            stop_price = base_price * (1 - self.pct)
            # Check if stop was triggered during bar (low touched stop level)
            triggered = (
                state.bar_low is not None and state.bar_low &lt;= stop_price
            ) or state.current_price &lt;= stop_price
        else:  # short
            stop_price = base_price * (1 + self.pct)
            # Check if stop was triggered during bar (high touched stop level)
            triggered = (
                state.bar_high is not None and state.bar_high &gt;= stop_price
            ) or state.current_price &gt;= stop_price

        if triggered:
            # Determine fill price based on mode
            fill_mode = _get_stop_fill_mode(state.context)
            if fill_mode == StopFillMode.NEXT_BAR_OPEN:
                # Zipline model: defer exit to next bar, fill at open
                return PositionAction.exit_full(
                    reason=f"stop_loss_{self.pct:.1%}",
                    defer_fill=True,  # Broker will fill at next bar's open
                )
            elif fill_mode == StopFillMode.CLOSE_PRICE:
                # VectorBT Pro close-only model: always fill at close price
                fill_price = state.current_price
            elif fill_mode == StopFillMode.BAR_EXTREME:
                # Conservative model: fill at bar's extreme (worst case)
                if state.is_long:
                    fill_price = state.bar_low if state.bar_low is not None else stop_price
                else:
                    fill_price = state.bar_high if state.bar_high is not None else stop_price
            else:
                # Standard model (STOP_PRICE): fill at exact stop price if within bar range
                # If bar gaps through stop, fill at open (gap behavior)
                if state.is_long:
                    # For long stops: check if bar opened below stop (gap down)
                    # or if stop is within bar range
                    if state.bar_open is not None and state.bar_open &lt;= stop_price:
                        # Bar opened below stop - fill at open (Backtrader gap behavior)
                        fill_price = state.bar_open
                    elif (
                        state.bar_low is not None
                        and state.bar_high is not None
                        and state.bar_low &lt;= stop_price &lt;= state.bar_high
                    ):
                        # Stop within bar range - fill at exact stop
                        fill_price = stop_price
                    else:
                        # Gap through (VBT behavior) - fill at close
                        fill_price = state.current_price
                else:
                    # For short stops: check if bar opened above stop (gap up)
                    if state.bar_open is not None and state.bar_open &gt;= stop_price:
                        # Bar opened above stop - fill at open (gap behavior)
                        fill_price = state.bar_open
                    elif (
                        state.bar_low is not None
                        and state.bar_high is not None
                        and state.bar_low &lt;= stop_price &lt;= state.bar_high
                    ):
                        # Stop within bar range - fill at exact stop
                        fill_price = stop_price
                    else:
                        # Gap through (VBT behavior) - fill at close
                        fill_price = state.current_price

            return PositionAction.exit_full(
                reason=f"stop_loss_{self.pct:.1%}",
                fill_price=fill_price,
            )
        return PositionAction.hold()


@dataclass
class TakeProfit:
    """Exit when target price is reached during the bar.

    Take-profit orders trigger when the bar's price range touches the target.
    Fill price depends on StopFillMode configuration:
    - STOP_PRICE: Fill at exact target price (standard model, default)
    - BAR_EXTREME: Fill at bar's high (matches VectorBT Pro behavior)

    For long positions: triggers if bar_high &gt;= target_price
    For short positions: triggers if bar_low &lt;= target_price

    Args:
        pct: Target profit as decimal (0.10 = 10% profit triggers exit)

    Example:
        rule = TakeProfit(pct=0.10)  # Exit at +10%
    """

    pct: float

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Exit if target price was reached during the bar."""
        from ml4t.backtest.types import StopFillMode

        # Get base price for target level calculation (entry_price or signal_price)
        base_price = _get_stop_base_price(state, state.context)

        # Calculate target price from base
        if state.is_long:
            target_price = base_price * (1 + self.pct)
            # Check if target was reached during bar (high touched target)
            triggered = (
                state.bar_high is not None and state.bar_high &gt;= target_price
            ) or state.current_price &gt;= target_price
        else:  # short
            target_price = base_price * (1 - self.pct)
            # Check if target was reached during bar (low touched target)
            triggered = (
                state.bar_low is not None and state.bar_low &lt;= target_price
            ) or state.current_price &lt;= target_price

        if triggered:
            # Determine fill price based on mode
            fill_mode = _get_stop_fill_mode(state.context)
            if fill_mode == StopFillMode.NEXT_BAR_OPEN:
                # Zipline model: defer exit to next bar, fill at open
                return PositionAction.exit_full(
                    reason=f"take_profit_{self.pct:.1%}",
                    defer_fill=True,  # Broker will fill at next bar's open
                )
            elif fill_mode == StopFillMode.CLOSE_PRICE:
                # VectorBT Pro close-only model: always fill at close price
                fill_price = state.current_price
            elif fill_mode == StopFillMode.BAR_EXTREME:
                # Optimistic model: fill at bar's extreme (best case for profits)
                if state.is_long:
                    fill_price = state.bar_high if state.bar_high is not None else target_price
                else:
                    fill_price = state.bar_low if state.bar_low is not None else target_price
            else:
                # Standard model (STOP_PRICE): fill at exact target price if within bar range
                # If bar gaps through target, fill at open/close (gap behavior)
                if state.is_long:
                    # For long targets: check if bar opened above target (price improvement)
                    # or if target is within bar range
                    if state.bar_open is not None and state.bar_open &gt;= target_price:
                        # Bar opened above target - fill at open (Backtrader behavior)
                        fill_price = state.bar_open
                    elif (
                        state.bar_low is not None
                        and state.bar_high is not None
                        and state.bar_low &lt;= target_price &lt;= state.bar_high
                    ):
                        # Target within bar range - fill at exact target
                        fill_price = target_price
                    else:
                        # Gap through - fill at close
                        fill_price = state.current_price
                else:
                    # For short targets: check if bar opened below target (price improvement)
                    if state.bar_open is not None and state.bar_open &lt;= target_price:
                        # Bar opened below target - fill at open (price improvement)
                        fill_price = state.bar_open
                    elif (
                        state.bar_low is not None
                        and state.bar_high is not None
                        and state.bar_low &lt;= target_price &lt;= state.bar_high
                    ):
                        # Target within bar range - fill at exact target
                        fill_price = target_price
                    else:
                        # Gap through - fill at close
                        fill_price = state.current_price

            return PositionAction.exit_full(
                reason=f"take_profit_{self.pct:.1%}",
                fill_price=fill_price,
            )
        return PositionAction.hold()


@dataclass
class TimeExit:
    """Exit after holding for a specified number of bars.

    Args:
        max_bars: Maximum bars to hold position

    Example:
        rule = TimeExit(max_bars=20)  # Exit after 20 bars
    """

    max_bars: int

    def evaluate(self, state: PositionState) -&gt; PositionAction:
        """Exit if held too long."""
        if state.bars_held &gt;= self.max_bars:
            # Time exits fill at current close price
            return PositionAction.exit_full(f"time_exit_{self.max_bars}bars")
        return PositionAction.hold()
]]>
    </file>
    <file path="ml4t/backtest/risk/types.py">
      <![CDATA["""Core types for risk management."""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto
from typing import Any


class ActionType(Enum):
    """Types of actions a position rule can return."""

    HOLD = auto()  # Do nothing
    EXIT_FULL = auto()  # Close entire position
    EXIT_PARTIAL = auto()  # Close portion of position
    ADJUST_STOP = auto()  # Move stop price


@dataclass
class PositionAction:
    """Action returned by a position rule.

    Attributes:
        action: Type of action to take
        pct: Percentage to exit (for EXIT_PARTIAL), 0-1
        stop_price: New stop price (for ADJUST_STOP)
        fill_price: Price at which to fill exit order (for stop/limit triggers)
        reason: Human-readable reason for action (for logging)
        defer_fill: If True, defer exit to next bar and fill at open price
                   (used for NEXT_BAR_OPEN mode to match Zipline behavior)
    """

    action: ActionType
    pct: float = 1.0
    stop_price: float | None = None
    fill_price: float | None = None  # Exit at this price (before slippage)
    reason: str = ""
    defer_fill: bool = False  # Defer exit to next bar's open

    @classmethod
    def hold(cls) -&gt; "PositionAction":
        """Convenience: return HOLD action."""
        return cls(ActionType.HOLD)

    @classmethod
    def exit_full(
        cls,
        reason: str = "",
        fill_price: float | None = None,
        defer_fill: bool = False,
    ) -&gt; "PositionAction":
        """Convenience: return EXIT_FULL action.

        Args:
            reason: Human-readable reason for exit
            fill_price: Price at which to fill (stop/limit price), slippage applied on top
            defer_fill: If True, defer exit to next bar and fill at open price
        """
        return cls(
            ActionType.EXIT_FULL, reason=reason, fill_price=fill_price, defer_fill=defer_fill
        )

    @classmethod
    def exit_partial(
        cls, pct: float, reason: str = "", fill_price: float | None = None
    ) -&gt; "PositionAction":
        """Convenience: return EXIT_PARTIAL action."""
        return cls(ActionType.EXIT_PARTIAL, pct=pct, reason=reason, fill_price=fill_price)

    @classmethod
    def adjust_stop(cls, price: float, reason: str = "") -&gt; "PositionAction":
        """Convenience: return ADJUST_STOP action."""
        return cls(ActionType.ADJUST_STOP, stop_price=price, reason=reason)


@dataclass
class PositionState:
    """Current state of a position for rule evaluation.

    This dataclass provides all the information rules need to make decisions.
    All monetary values are in the position's currency.

    Attributes:
        asset: Asset symbol
        side: "long" or "short"
        entry_price: Average entry price
        current_price: Current market price (close)
        bar_open: Current bar's open price (for intrabar detection)
        bar_high: Current bar's high price (for intrabar detection)
        bar_low: Current bar's low price (for intrabar detection)
        quantity: Current position size (absolute)
        initial_quantity: Original position size when opened
        unrealized_pnl: Current unrealized P&amp;L in currency
        unrealized_return: Current unrealized return as decimal (0.05 = 5%)
        bars_held: Number of bars since position opened
        high_water_mark: Highest price since entry (for longs)
        low_water_mark: Lowest price since entry (for shorts)
        max_favorable_excursion: Best unrealized return seen
        max_adverse_excursion: Worst unrealized return seen
        entry_time: When position was opened
        current_time: Current timestamp
        context: Optional strategy-provided context (signals, indicators, etc.)
    """

    asset: str
    side: str  # "long" or "short"
    entry_price: float
    current_price: float
    quantity: int
    initial_quantity: int
    unrealized_pnl: float
    unrealized_return: float
    bars_held: int
    high_water_mark: float
    low_water_mark: float
    # Bar OHLC for intrabar stop/limit detection
    bar_open: float | None = None
    bar_high: float | None = None
    bar_low: float | None = None
    max_favorable_excursion: float = 0.0
    max_adverse_excursion: float = 0.0
    entry_time: datetime | None = None
    current_time: datetime | None = None
    context: dict[str, Any] = field(default_factory=dict)

    @property
    def is_long(self) -&gt; bool:
        """True if long position."""
        return self.side == "long"

    @property
    def is_short(self) -&gt; bool:
        """True if short position."""
        return self.side == "short"

    @property
    def is_profitable(self) -&gt; bool:
        """True if position is currently profitable."""
        return self.unrealized_return &gt; 0

    @property
    def drawdown_from_peak(self) -&gt; float:
        """Current drawdown from max favorable excursion."""
        if self.max_favorable_excursion &lt;= 0:
            return 0.0
        return (self.max_favorable_excursion - self.unrealized_return) / (
            1 + self.max_favorable_excursion
        )
]]>
    </file>
    <file path="ml4t/backtest/strategy.py">
      <![CDATA["""Base strategy class for backtesting."""

from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any


class Strategy(ABC):
    """Base strategy class."""

    @abstractmethod
    def on_data(
        self,
        timestamp: datetime,
        data: dict[str, dict],
        context: dict[str, Any],
        broker: Any,  # Avoid circular import, use Any for broker type
    ) -&gt; None:
        """Called for each timestamp with all available data."""
        pass

    def on_start(self, broker: Any) -&gt; None:  # noqa: B027
        """Called before backtest starts."""
        pass

    def on_end(self, broker: Any) -&gt; None:  # noqa: B027
        """Called after backtest ends."""
        pass
]]>
    </file>
    <file path="ml4t/backtest/types.py">
      <![CDATA["""Core types for backtesting engine."""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

# === Enums ===


class OrderType(Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"
    TRAILING_STOP = "trailing_stop"


class OrderSide(Enum):
    BUY = "buy"
    SELL = "sell"


class OrderStatus(Enum):
    PENDING = "pending"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class ExecutionMode(Enum):
    """Order execution timing mode."""

    SAME_BAR = "same_bar"  # Orders fill at current bar's close (default)
    NEXT_BAR = "next_bar"  # Orders fill at next bar's open (like Backtrader)


class StopFillMode(Enum):
    """Stop/take-profit fill price mode.

    Different frameworks handle stop order fills differently:
    - STOP_PRICE: Fill at exact stop/target price (standard model, default)
                  Matches VectorBT Pro with OHLC and Backtrader behavior
    - CLOSE_PRICE: Fill at bar's close price when stop triggers
                   Matches VectorBT Pro with close-only data
    - BAR_EXTREME: Fill at bar's low (stop-loss) or high (take-profit)
                   Worst/best case model (conservative/optimistic)
    - NEXT_BAR_OPEN: Fill at next bar's open price when stop triggers
                     Matches Zipline behavior (strategy-level stops)
    """

    STOP_PRICE = "stop_price"  # Fill at exact stop/target price (default, VBT Pro OHLC, Backtrader)
    CLOSE_PRICE = "close_price"  # Fill at close price (VBT Pro close-only)
    BAR_EXTREME = "bar_extreme"  # Fill at bar's low/high (conservative/optimistic)
    NEXT_BAR_OPEN = "next_bar_open"  # Fill at next bar's open (Zipline)


class AssetClass(Enum):
    """Asset class for contract specification."""

    EQUITY = "equity"  # Stocks, ETFs (multiplier=1)
    FUTURE = "future"  # Futures contracts (multiplier varies)
    FOREX = "forex"  # FX pairs (pip value varies)


@dataclass
class ContractSpec:
    """Contract specification for an asset.

    Defines the characteristics that affect P&amp;L calculation and margin:
    - Equities: multiplier=1, tick_size=0.01
    - Futures: multiplier varies (ES=$50, CL=$1000, etc.)
    - Forex: pip value varies by pair and account currency

    Example:
        # E-mini S&amp;P 500 futures
        es_spec = ContractSpec(
            symbol="ES",
            asset_class=AssetClass.FUTURE,
            multiplier=50.0,      # $50 per point
            tick_size=0.25,       # Minimum move
            margin=15000.0,       # Initial margin per contract
        )

        # Apple stock
        aapl_spec = ContractSpec(
            symbol="AAPL",
            asset_class=AssetClass.EQUITY,
            # multiplier=1.0 (default)
            # tick_size=0.01 (default)
        )
    """

    symbol: str
    asset_class: AssetClass = AssetClass.EQUITY
    multiplier: float = 1.0  # Point value ($ per point move)
    tick_size: float = 0.01  # Minimum price increment
    margin: float | None = None  # Initial margin per contract (overrides account default)
    currency: str = "USD"


class StopLevelBasis(Enum):
    """Basis for calculating stop/take-profit levels.

    Different frameworks calculate stop levels from different reference prices:
    - FILL_PRICE: Calculate from actual entry fill price (ml4t default)
                  stop_level = fill_price * (1 - pct)
    - SIGNAL_PRICE: Calculate from signal close price at order time (Backtrader)
                    stop_level = signal_close * (1 - pct)

    In NEXT_BAR mode, fill_price is next bar's open while signal_price is
    current bar's close. This creates a small difference in stop levels.
    """

    FILL_PRICE = "fill_price"  # Use actual entry fill price (default)
    SIGNAL_PRICE = "signal_price"  # Use signal close price at order time (Backtrader)


# === Dataclasses ===


@dataclass
class Order:
    asset: str
    side: OrderSide
    quantity: float
    order_type: OrderType = OrderType.MARKET
    limit_price: float | None = None
    stop_price: float | None = None
    trail_amount: float | None = None
    parent_id: str | None = None
    order_id: str = ""
    status: OrderStatus = OrderStatus.PENDING
    created_at: datetime | None = None
    filled_at: datetime | None = None
    filled_price: float | None = None
    filled_quantity: float = 0.0
    # Internal risk management fields (set by broker)
    _signal_price: float | None = None  # Close price at order creation time
    _risk_exit_reason: str | None = None  # Reason for risk-triggered exit
    _risk_fill_price: float | None = None  # Stop/target price for risk exits


@dataclass
class Position:
    """Unified position tracking for strategy and accounting.

    Supports both long and short positions with:
    - Weighted average cost basis tracking
    - Mark-to-market price tracking
    - Risk metrics (MFE/MAE, water marks)
    - Contract multipliers for futures

    Attributes:
        asset: Asset identifier (e.g., "AAPL", "ES")
        quantity: Position size (positive=long, negative=short)
        entry_price: Weighted average entry price (cost basis)
        entry_time: Timestamp when position was first opened
        current_price: Latest mark-to-market price (updated each bar)
        bars_held: Number of bars this position has been held

    Examples:
        Long position:
            Position("AAPL", 100, 150.0, datetime.now())
            -&gt; quantity=100, unrealized_pnl depends on current_price

        Short position:
            Position("AAPL", -100, 150.0, datetime.now())
            -&gt; quantity=-100, profit if price drops
    """

    asset: str
    quantity: float  # Positive for long, negative for short
    entry_price: float  # Weighted average cost basis
    entry_time: datetime
    current_price: float | None = None  # Mark-to-market price (set each bar)
    bars_held: int = 0
    # Risk tracking fields
    high_water_mark: float | None = None  # Highest price since entry (for longs)
    low_water_mark: float | None = None  # Lowest price since entry (for shorts)
    max_favorable_excursion: float = 0.0  # Best unrealized return seen
    max_adverse_excursion: float = 0.0  # Worst unrealized return seen
    initial_quantity: float | None = None  # Original size when opened
    context: dict = field(default_factory=dict)  # Strategy-provided context
    multiplier: float = 1.0  # Contract multiplier (for futures)

    def __post_init__(self):
        # Initialize water marks to entry price
        if self.high_water_mark is None:
            self.high_water_mark = self.entry_price
        if self.low_water_mark is None:
            self.low_water_mark = self.entry_price
        if self.initial_quantity is None:
            self.initial_quantity = self.quantity
        if self.current_price is None:
            self.current_price = self.entry_price

    @property
    def avg_entry_price(self) -&gt; float:
        """Alias for entry_price (accounting compatibility)."""
        return self.entry_price

    @property
    def market_value(self) -&gt; float:
        """Current market value of the position.

        For long positions: positive value (asset on balance sheet)
        For short positions: negative value (liability on balance sheet)

        Returns:
            Market value = quantity × current_price
        """
        price = self.current_price if self.current_price is not None else self.entry_price
        return self.quantity * price * self.multiplier

    def unrealized_pnl(self, current_price: float | None = None) -&gt; float:
        """Calculate unrealized P&amp;L including contract multiplier.

        Args:
            current_price: Price to calculate P&amp;L at. If None, uses self.current_price.

        Returns:
            Unrealized P&amp;L = (current_price - entry_price) × quantity × multiplier
        """
        price = current_price if current_price is not None else self.current_price
        if price is None:
            price = self.entry_price
        return (price - self.entry_price) * self.quantity * self.multiplier

    def pnl_percent(self, current_price: float | None = None) -&gt; float:
        """Calculate percentage return on position.

        Args:
            current_price: Price to calculate return at. If None, uses self.current_price.
        """
        price = current_price if current_price is not None else self.current_price
        if price is None:
            price = self.entry_price
        if self.entry_price == 0:
            return 0.0
        return (price - self.entry_price) / self.entry_price

    def notional_value(self, current_price: float | None = None) -&gt; float:
        """Calculate notional value of position.

        Args:
            current_price: Price to calculate value at. If None, uses self.current_price.
        """
        price = current_price if current_price is not None else self.current_price
        if price is None:
            price = self.entry_price
        return abs(self.quantity) * price * self.multiplier

    def update_water_marks(self, current_price: float) -&gt; None:
        """Update high/low water marks and excursion tracking."""
        # Update current price
        self.current_price = current_price

        # Update water marks (guaranteed non-None after __post_init__)
        if self.high_water_mark is None or current_price &gt; self.high_water_mark:
            self.high_water_mark = current_price
        if self.low_water_mark is None or current_price &lt; self.low_water_mark:
            self.low_water_mark = current_price

        # Update MFE/MAE
        current_return = self.pnl_percent(current_price)
        if current_return &gt; self.max_favorable_excursion:
            self.max_favorable_excursion = current_return
        if current_return &lt; self.max_adverse_excursion:
            self.max_adverse_excursion = current_return

    @property
    def side(self) -&gt; str:
        """Return 'long' or 'short' based on quantity sign."""
        return "long" if self.quantity &gt; 0 else "short"

    def __repr__(self) -&gt; str:
        """String representation for debugging."""
        direction = "LONG" if self.quantity &gt; 0 else "SHORT"
        price = self.current_price if self.current_price is not None else self.entry_price
        pnl = self.unrealized_pnl()
        return (
            f"Position({direction} {abs(self.quantity):.2f} {self.asset} "
            f"@ ${self.entry_price:.2f}, "
            f"current ${price:.2f}, "
            f"PnL ${pnl:+.2f})"
        )


@dataclass
class Fill:
    order_id: str
    asset: str
    side: OrderSide
    quantity: float
    price: float
    timestamp: datetime
    commission: float = 0.0
    slippage: float = 0.0


@dataclass
class Trade:
    """Completed round-trip trade."""

    asset: str
    entry_time: datetime
    exit_time: datetime
    entry_price: float
    exit_price: float
    quantity: float
    pnl: float
    pnl_percent: float
    bars_held: int
    commission: float = 0.0
    slippage: float = 0.0
    entry_signals: dict[str, float] = field(default_factory=dict)
    exit_signals: dict[str, float] = field(default_factory=dict)
    # MFE/MAE preserved from Position for trade analysis
    max_favorable_excursion: float = 0.0  # Best unrealized return during trade
    max_adverse_excursion: float = 0.0  # Worst unrealized return during trade

    @property
    def side(self) -&gt; str:
        """Return 'long' or 'short' based on quantity sign."""
        return "long" if self.quantity &gt; 0 else "short"
]]>
    </file>
  </files>
</codebase>