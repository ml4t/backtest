<qengine>


    <file_summary>
        This section contains a summary of this file.

        <purpose>
            This file contains a packed representation of a subset of the repository's contents that is considered the
            most important context.
            It is designed to be easily consumable by AI systems for analysis, code review,
            or other automated processes.
        </purpose>

        <file_format>
            The content is organized as follows:
            1. This summary section
            2. Repository information
            3. Directory structure
            4. Repository files (if enabled)
            5. Multiple file entries, each consisting of:
            - File path as an attribute
            - Full contents of the file
        </file_format>

        <usage_guidelines>
            - This file should be treated as read-only. Any changes should be made to the
            original repository files, not this packed version.
            - When processing this file, use the file path to distinguish
            between different files in the repository.
            - Be aware that this file may contain sensitive information. Handle it with
            the same level of security as you would the original repository.
        </usage_guidelines>

        <notes>
            - Some files may have been excluded based on .gitignore rules and Repomix's configuration
            - Binary files are not included in this packed representation. Please refer to the Repository Structure
            section for a complete list of file paths, including binary files
            - Only files matching these patterns are included: README.md, src/qengine/__init__.py,
            src/qengine/engine.py, src/qengine/core/*.py, src/qengine/data/*.py, src/qengine/execution/*.py,
            src/qengine/portfolio/*.py, src/qengine/strategy/*.py, src/qengine/reporting/*.py, README.md, src/**/*.py
            - Files matching these patterns are excluded: .venv/**, docs/**, examples/**, tests/**, resources/**,
            htmlcov/**, __pycache__/**, *.pyc, benchmarks/**, config/**
            - Files matching patterns in .gitignore are excluded
            - Files matching default ignore patterns are excluded
            - Files are sorted by Git change count (files with more changes are at the bottom)
        </notes>

    </file_summary>

    <directory_structure>
        src/
        qengine/
        core/
        __init__.py
        assets.py
        clock.py
        event.py
        types.py
        data/
        __init__.py
        feed.py
        schemas.py
        execution/
        __init__.py
        broker.py
        commission.py
        corporate_actions.py
        market_impact.py
        order.py
        slippage.py
        portfolio/
        __init__.py
        accounting.py
        margin.py
        portfolio.py
        simple.py
        reporting/
        __init__.py
        base.py
        html.py
        parquet.py
        reporter.py
        strategy/
        __init__.py
        adapters.py
        base.py
        crypto_basis_adapter.py
        spy_order_flow_adapter.py
        __init__.py
        engine.py
        README.md
    </directory_structure>

    <files>
        This section contains the contents of the repository's files.

        <file path="src/qengine/core/__init__.py">
            """Core event system and time management for QEngine."""

            from qengine.core.assets import AssetClass, AssetRegistry, AssetSpec
            from qengine.core.clock import Clock
            from qengine.core.event import (
            Event,
            EventBus,
            FillEvent,
            MarketEvent,
            OrderEvent,
            SignalEvent,
            )
            from qengine.core.types import AssetId, Price, Quantity, Timestamp

            __all__ = [
            "AssetClass",
            "AssetId",
            "AssetRegistry",
            "AssetSpec",
            "Clock",
            "Event",
            "EventBus",
            "FillEvent",
            "MarketEvent",
            "OrderEvent",
            "Price",
            "Quantity",
            "SignalEvent",
            "Timestamp",
            ]
        </file>

        <file path="src/qengine/core/assets.py">
            """Asset class definitions and specifications for QEngine."""

            from dataclasses import dataclass
            from datetime import datetime
            from enum import Enum

            from qengine.core.types import AssetId, Price


            class AssetClass(Enum):
            """Supported asset classes."""

            EQUITY = "equity"
            FUTURE = "future"
            OPTION = "option"
            FX = "fx"
            CRYPTO = "crypto"
            BOND = "bond"
            COMMODITY = "commodity"


            class ContractType(Enum):
            """Contract types for derivatives."""

            SPOT = "spot"
            FUTURE = "future"
            PERPETUAL = "perpetual"
            CALL = "call"
            PUT = "put"


            @dataclass
            class AssetSpec:
            """
            Complete specification for an asset.

            This class handles the different requirements for various asset classes:
            - Equities: Simple spot trading with T+2 settlement
            - Futures: Margin requirements, expiry, rolling
            - Options: Greeks, expiry, exercise
            - FX: Currency pairs, pip values
            - Crypto: 24/7 trading, fractional shares
            """

            asset_id: AssetId
            asset_class: AssetClass
            contract_type: ContractType = ContractType.SPOT

            # Common fields
            currency: str = "USD"
            tick_size: float = 0.01
            lot_size: float = 1.0
            min_quantity: float = 1.0

            # Equity-specific
            exchange: str | None = None

            # Futures-specific
            contract_size: float = 1.0 # Multiplier for futures/options
            initial_margin: float = 0.0 # Initial margin requirement
            maintenance_margin: float = 0.0 # Maintenance margin requirement
            expiry: datetime | None = None
            underlying: AssetId | None = None # For derivatives
            roll_date: datetime | None = None # When to roll to next contract

            # Options-specific
            strike: Price | None = None
            option_type: str | None = None # "call" or "put"
            exercise_style: str | None = None # "american", "european"

            # FX-specific
            base_currency: str | None = None
            quote_currency: str | None = None
            pip_value: float = 0.0001 # Standard pip value

            # Crypto-specific
            is_24_7: bool = False # Trades 24/7
            network_fees: bool = False # Has blockchain network fees

            # Trading specifications
            maker_fee: float = 0.001 # 0.1% default
            taker_fee: float = 0.001 # 0.1% default
            short_enabled: bool = True
            leverage_available: float = 1.0 # Max leverage

            @property
            def is_derivative(self) -> bool:
            """Check if asset is a derivative."""
            return self.asset_class in [AssetClass.FUTURE, AssetClass.OPTION]

            @property
            def requires_margin(self) -> bool:
            """Check if asset requires margin."""
            return self.asset_class in [AssetClass.FUTURE, AssetClass.FX] or self.leverage_available > 1

            @property
            def has_expiry(self) -> bool:
            """Check if asset has expiry."""
            return self.expiry is not None

            def get_margin_requirement(self, quantity: float, price: Price) -> float:
            """
            Calculate margin requirement for position.

            Args:
            quantity: Position size
            price: Current price

            Returns:
            Required margin
            """
            if self.asset_class == AssetClass.FUTURE:
            # Futures use fixed margin per contract
            return abs(quantity) * self.initial_margin
            if self.asset_class == AssetClass.FX:
            # FX uses percentage of notional
            notional = abs(quantity) * price
            return notional / self.leverage_available if self.leverage_available > 0 else notional
            if self.asset_class == AssetClass.CRYPTO and self.leverage_available > 1:
            # Leveraged crypto trading
            notional = abs(quantity) * price
            return notional / self.leverage_available
            if self.asset_class == AssetClass.OPTION:
            # Options: buyers pay premium, sellers need margin
            if quantity > 0: # Buying options
            return abs(quantity) * price * self.contract_size
            # Selling options - simplified margin
            return abs(quantity) * self.strike * self.contract_size * 0.2 # 20% of notional
            # Spot trading - full cash required
            return abs(quantity) * price

            def get_notional_value(self, quantity: float, price: Price) -> float:
            """
            Calculate notional value of position.

            Args:
            quantity: Position size
            price: Current price

            Returns:
            Notional value
            """
            if self.asset_class in [AssetClass.FUTURE, AssetClass.OPTION]:
            return abs(quantity) * price * self.contract_size
            if self.asset_class == AssetClass.FX:
            # FX notional in base currency
            return abs(quantity) * price
            return abs(quantity) * price

            def calculate_pnl(
            self,
            entry_price: Price,
            exit_price: Price,
            quantity: float,
            include_costs: bool = True,
            ) -> float:
            """
            Calculate P&L for a trade.

            Args:
            entry_price: Entry price
            exit_price: Exit price
            quantity: Position size (positive for long, negative for short)
            include_costs: Whether to include trading costs

            Returns:
            Profit/loss
            """
            if self.asset_class == AssetClass.FUTURE:
            # Futures P&L includes contract multiplier
            pnl = quantity * (exit_price - entry_price) * self.contract_size
            elif self.asset_class == AssetClass.OPTION:
            # Options P&L depends on type
            if self.option_type == "call":
            if quantity > 0: # Long call
            pnl = max(exit_price - self.strike, 0) * quantity * self.contract_size
            pnl -= entry_price * quantity * self.contract_size # Premium paid
            else: # Short call
            pnl = entry_price * abs(quantity) * self.contract_size # Premium received
            pnl -= max(exit_price - self.strike, 0) * abs(quantity) * self.contract_size
            else: # Put
            if quantity > 0: # Long put
            pnl = max(self.strike - exit_price, 0) * quantity * self.contract_size
            pnl -= entry_price * quantity * self.contract_size # Premium paid
            else: # Short put
            pnl = entry_price * abs(quantity) * self.contract_size # Premium received
            pnl -= max(self.strike - exit_price, 0) * abs(quantity) * self.contract_size
            elif self.asset_class == AssetClass.FX:
            # FX P&L in quote currency
            pnl = quantity * (exit_price - entry_price)
            # Convert pips to currency if needed
            if self.pip_value > 0:
            pnl = pnl / self.pip_value
            else:
            # Standard P&L calculation
            pnl = quantity * (exit_price - entry_price)

            # Subtract trading costs if requested
            if include_costs:
            entry_cost = abs(quantity * entry_price) * self.taker_fee
            exit_cost = abs(quantity * exit_price) * self.taker_fee
            pnl -= entry_cost + exit_cost

            return pnl

            def calculate_pnl_premium_based(
            self,
            entry_premium: Price,
            exit_premium: Price,
            quantity: float,
            include_costs: bool = True,
            ) -> float:
            """
            Calculate P&L for options using premium change methodology.

            This is the CORRECT way to calculate options P&L for positions
            closed before expiry. It uses the change in option premium,
            not intrinsic value.

            Args:
            entry_premium: Option premium at entry
            exit_premium: Option premium at exit
            quantity: Position size (positive for long, negative for short)
            include_costs: Whether to include trading costs

            Returns:
            Profit/loss based on premium change

            Raises:
            ValueError: If called on non-option assets

            Example:
            # Long 1 call option: bought at $2.00, sold at $1.50
            # P&L = (1.50 - 2.00) * 1 * 100 = -$50
            pnl = call_spec.calculate_pnl_premium_based(2.00, 1.50, 1.0)
            assert pnl == -50.0
            """
            if self.asset_class != AssetClass.OPTION:
            raise ValueError("Premium-based P&L calculation is only for options")

            # CORRECT: P&L = (exit_premium - entry_premium) * quantity * contract_size
            pnl = (exit_premium - entry_premium) * quantity * self.contract_size

            # Subtract trading costs if requested
            if include_costs:
            entry_cost = abs(quantity * entry_premium) * getattr(self, "taker_fee", 0.0)
            exit_cost = abs(quantity * exit_premium) * getattr(self, "taker_fee", 0.0)
            pnl -= entry_cost + exit_cost

            return pnl

            def calculate_pnl_enhanced(
            self,
            entry_price: Price,
            exit_price: Price,
            quantity: float,
            entry_premium: Price = None,
            exit_premium: Price = None,
            include_costs: bool = True,
            ) -> float:
            """
            Enhanced P&L calculation with options premium support.

            For options, this method will use premium-based calculation when
            premium data is provided, falling back to intrinsic value calculation
            when no premium data is available.

            Args:
            entry_price: Entry price (underlying price for options)
            exit_price: Exit price (underlying price for options)
            quantity: Position size
            entry_premium: Option premium at entry (for options only)
            exit_premium: Option premium at exit (for options only)
            include_costs: Whether to include trading costs

            Returns:
            Profit/loss
            """
            if (
            self.asset_class == AssetClass.OPTION
            and entry_premium is not None
            and exit_premium is not None
            ):
            # Use premium-based calculation for options when premium data available
            return self.calculate_pnl_premium_based(
            entry_premium,
            exit_premium,
            quantity,
            include_costs,
            )
            # Use original calculation method
            return self.calculate_pnl(entry_price, exit_price, quantity, include_costs)


            class AssetRegistry:
            """Registry for managing asset specifications."""

            def __init__(self):
            """Initialize asset registry."""
            self._assets: dict[AssetId, AssetSpec] = {}

            def register(self, asset_spec: AssetSpec) -> None:
            """Register an asset specification."""
            self._assets[asset_spec.asset_id] = asset_spec

            def get(self, asset_id: AssetId) -> AssetSpec | None:
            """Get asset specification by ID."""
            return self._assets.get(asset_id)

            def get_or_create_equity(self, asset_id: AssetId) -> AssetSpec:
            """Get or create a default equity specification."""
            if asset_id not in self._assets:
            self._assets[asset_id] = AssetSpec(
            asset_id=asset_id,
            asset_class=AssetClass.EQUITY,
            contract_type=ContractType.SPOT,
            )
            return self._assets[asset_id]

            def create_future(
            self,
            asset_id: AssetId,
            underlying: AssetId,
            expiry: datetime,
            contract_size: float = 1.0,
            initial_margin: float = 0.0,
            maintenance_margin: float = 0.0,
            ) -> AssetSpec:
            """Create a futures contract specification."""
            spec = AssetSpec(
            asset_id=asset_id,
            asset_class=AssetClass.FUTURE,
            contract_type=ContractType.FUTURE,
            underlying=underlying,
            expiry=expiry,
            contract_size=contract_size,
            initial_margin=initial_margin,
            maintenance_margin=maintenance_margin,
            )
            self._assets[asset_id] = spec
            return spec

            def create_option(
            self,
            asset_id: AssetId,
            underlying: AssetId,
            strike: Price,
            expiry: datetime,
            option_type: str,
            contract_size: float = 100.0,
            exercise_style: str = "american",
            ) -> AssetSpec:
            """Create an option contract specification."""
            spec = AssetSpec(
            asset_id=asset_id,
            asset_class=AssetClass.OPTION,
            contract_type=ContractType.CALL if option_type == "call" else ContractType.PUT,
            underlying=underlying,
            strike=strike,
            expiry=expiry,
            option_type=option_type,
            contract_size=contract_size,
            exercise_style=exercise_style,
            )
            self._assets[asset_id] = spec
            return spec

            def create_fx_pair(
            self,
            asset_id: AssetId,
            base_currency: str,
            quote_currency: str,
            pip_value: float = 0.0001,
            leverage_available: float = 100.0,
            ) -> AssetSpec:
            """Create an FX pair specification."""
            spec = AssetSpec(
            asset_id=asset_id,
            asset_class=AssetClass.FX,
            contract_type=ContractType.SPOT,
            base_currency=base_currency,
            quote_currency=quote_currency,
            currency=quote_currency,
            pip_value=pip_value,
            leverage_available=leverage_available,
            tick_size=pip_value,
            lot_size=1000.0, # Mini lot
            )
            self._assets[asset_id] = spec
            return spec

            def create_crypto(
            self,
            asset_id: AssetId,
            base_currency: str,
            quote_currency: str = "USD",
            min_quantity: float = 0.00001,
            maker_fee: float = 0.001,
            taker_fee: float = 0.001,
            leverage_available: float = 1.0,
            ) -> AssetSpec:
            """Create a cryptocurrency specification."""
            spec = AssetSpec(
            asset_id=asset_id,
            asset_class=AssetClass.CRYPTO,
            contract_type=ContractType.SPOT,
            base_currency=base_currency,
            quote_currency=quote_currency,
            currency=quote_currency,
            min_quantity=min_quantity,
            tick_size=0.01,
            lot_size=1.0,
            is_24_7=True,
            network_fees=True,
            maker_fee=maker_fee,
            taker_fee=taker_fee,
            leverage_available=leverage_available,
            )
            self._assets[asset_id] = spec
            return spec
        </file>

        <file path="src/qengine/core/clock.py">
            """Time management and synchronization for QEngine."""

            import heapq
            from datetime import datetime
            from enum import Enum

            import pandas_market_calendars as mcal

            from qengine.core.event import Event
            from qengine.data.feed import DataFeed, SignalSource


            class ClockMode(Enum):
            """Clock operation modes."""

            BACKTEST = "backtest" # Historical simulation
            PAPER = "paper" # Paper trading with real-time data
            LIVE = "live" # Live trading


            class Clock:
            """
            Master time keeper for the simulation.

            The Clock is responsible for:
            - Advancing simulation time
            - Coordinating multiple data sources
            - Ensuring point-in-time correctness
            - Managing trading calendar
            """

            def __init__(
            self,
            mode: ClockMode = ClockMode.BACKTEST,
            calendar: str | None = "NYSE",
            start_time: datetime | None = None,
            end_time: datetime | None = None,
            ):
            """
            Initialize the Clock.

            Args:
            mode: Operating mode (backtest, paper, live)
            calendar: Market calendar name (e.g., 'NYSE', 'NASDAQ')
            start_time: Simulation start time
            end_time: Simulation end time
            """
            self.mode = mode
            self.calendar_name = calendar
            self.start_time = start_time
            self.end_time = end_time

            # Current simulation time
            self._current_time = start_time

            # Data sources
            self._data_feeds: list[DataFeed] = []
            self._signal_sources: list[SignalSource] = []

            # Event queue (min heap by timestamp)
            self._event_queue: list[tuple[datetime, Event]] = []

            # Market calendar
            if calendar:
            self.calendar = mcal.get_calendar(calendar)
            if start_time and end_time:
            self.trading_sessions = self.calendar.schedule(
            start_date=start_time.date(),
            end_date=end_time.date(),
            )
            else:
            self.calendar = None
            self.trading_sessions = None

            # Statistics
            self._events_processed = 0
            self._ticks_processed = 0

            def add_data_feed(self, feed: DataFeed) -> None:
            """
            Add a data feed to the clock.

            Args:
            feed: Data feed to add
            """
            self._data_feeds.append(feed)
            self._prime_feed(feed)

            def add_signal_source(self, source: SignalSource) -> None:
            """
            Add a signal source to the clock.

            Args:
            source: Signal source to add
            """
            self._signal_sources.append(source)
            self._prime_signal_source(source)

            def _prime_feed(self, feed: DataFeed) -> None:
            """
            Prime a data feed by adding its first event to the queue.

            Args:
            feed: Data feed to prime
            """
            next_event = feed.get_next_event()
            if next_event:
            heapq.heappush(self._event_queue, (next_event.timestamp, next_event))

            def _prime_signal_source(self, source: SignalSource) -> None:
            """
            Prime a signal source.

            Args:
            source: Signal source to prime
            """
            next_signal = source.get_next_signal()
            if next_signal:
            heapq.heappush(self._event_queue, (next_signal.timestamp, next_signal))

            def get_next_event(self) -> Event | None:
            """
            Get the next event across all data sources.

            Returns:
            Next event in chronological order or None
            """
            if not self._event_queue:
            return None

            # Get event with earliest timestamp
            timestamp, event = heapq.heappop(self._event_queue)

            # Update current time (ensures PIT correctness)
            self._current_time = timestamp

            # Check if we're past end time
            if self.end_time and timestamp > self.end_time:
            return None

            # Replenish queue from the source that provided this event
            self._replenish_queue(event)

            self._events_processed += 1

            return event

            def _replenish_queue(self, last_event: Event) -> None:
            """
            Add the next event from the source that provided the last event.

            Args:
            last_event: The event that was just processed
            """
            # This is simplified - in production we'd track which source
            # provided which event and replenish accordingly
            for feed in self._data_feeds:
            if not feed.is_exhausted:
            next_timestamp = feed.peek_next_timestamp()
            if next_timestamp and (not self.end_time or next_timestamp<= self.end_time):
            next_event = feed.get_next_event()
            if next_event:
            heapq.heappush(self._event_queue, (next_event.timestamp, next_event))
            break

            for source in self._signal_sources:
            next_timestamp = source.peek_next_timestamp()
            if next_timestamp and (not self.end_time or next_timestamp<= self.end_time):
            next_signal = source.get_next_signal()
            if next_signal:
            heapq.heappush(self._event_queue, (next_signal.timestamp, next_signal))
            break

            @property
            def current_time(self) -> datetime | None:
            """Get the current simulation time."""
            return self._current_time

            @property
            def is_market_open(self) -> bool:
            """
            Check if the market is currently open.

            Returns:
            True if market is open at current time
            """
            if not self.calendar or not self._current_time:
            return True # Assume always open if no calendar

            # Check if current time is within a trading session
            current_date = self._current_time.date()
            if current_date in self.trading_sessions.index:
            session = self.trading_sessions.loc[current_date]
            market_open = session["market_open"]
            market_close = session["market_close"]

            # Convert to timezone-aware if needed
            if self._current_time.tzinfo:
            return market_open<= self._current_time<= market_close
            return (
            market_open.replace(tzinfo=None)
            <= self._current_time
            <= market_close.replace(tzinfo=None)
            )

            return False

            @property
            def next_market_open(self) -> datetime | None:
            """
            Get the next market open time.

            Returns:
            Next market open datetime or None
            """
            if not self.calendar or not self._current_time:
            return None

            current_date = self._current_time.date()
            future_sessions = self.trading_sessions[self.trading_sessions.index >= current_date]

            for _date, session in future_sessions.iterrows():
            market_open = session["market_open"]
            if market_open > self._current_time:
            return market_open

            return None

            @property
            def next_market_close(self) -> datetime | None:
            """
            Get the next market close time.

            Returns:
            Next market close datetime or None
            """
            if not self.calendar or not self._current_time:
            return None

            current_date = self._current_time.date()
            if current_date in self.trading_sessions.index:
            market_close = self.trading_sessions.loc[current_date]["market_close"]
            if market_close > self._current_time:
            return market_close

            # Look for next session
            future_sessions = self.trading_sessions[self.trading_sessions.index > current_date]
            if not future_sessions.empty:
            return future_sessions.iloc[0]["market_close"]

            return None

            def is_trading_day(self, date: datetime) -> bool:
            """
            Check if a given date is a trading day.

            Args:
            date: Date to check

            Returns:
            True if date is a trading day
            """
            if not self.calendar:
            return True

            return date.date() in self.trading_sessions.index

            def advance_to(self, timestamp: datetime) -> None:
            """
            Advance the clock to a specific time.

            Used for jumping forward in time during backtesting.

            Args:
            timestamp: Target timestamp
            """
            if self.mode != ClockMode.BACKTEST:
            raise RuntimeError("Can only advance time in backtest mode")

            if self._current_time is not None and timestamp< self._current_time:
                                                             raise ValueError("Cannot go back in time")

            self._current_time = timestamp

            # Drop events before the new time
            while self._event_queue and self._event_queue[0][0]< timestamp:
                                                                 heapq.heappop(self._event_queue)

            def reset(self) -> None:
            """Reset the clock to initial state."""
            self._current_time = self.start_time
            self._event_queue.clear()
            self._events_processed = 0
            self._ticks_processed = 0

            # Reset all data feeds
            for feed in self._data_feeds:
            feed.reset()
            self._prime_feed(feed)

            # Reset all signal sources
            for source in self._signal_sources:
            source.reset()
            self._prime_signal_source(source)

            @property
            def stats(self) -> dict:
            """Get clock statistics."""
            return {
            "current_time": self._current_time,
            "events_processed": self._events_processed,
            "queue_size": len(self._event_queue),
            "data_feeds": len(self._data_feeds),
            "signal_sources": len(self._signal_sources),
            "mode": self.mode.value,
            }

            def __repr__(self) -> str:
            return (
            f"Clock(mode={self.mode.value}, "
            f"time={self._current_time}, "
            f"events={self._events_processed})"
            )
        </file>

        <file path="src/qengine/core/event.py">
            """Event system for QEngine."""

            import heapq
            import logging
            import threading
            from abc import ABC
            from collections import deque
            from collections.abc import Callable
            from datetime import datetime
            from typing import Any

            from qengine.core.types import (
            AssetId,
            EventType,
            MarketDataType,
            OrderId,
            OrderSide,
            OrderType,
            Price,
            Quantity,
            TimeInForce,
            Volume,
            )

            logger = logging.getLogger(__name__)


            class Event(ABC):
            """Base class for all events in the system."""

            def __init__(
            self,
            timestamp: datetime,
            event_type: EventType,
            metadata: dict[str, Any] | None = None,
            ):
            self.timestamp = timestamp
            self.event_type = event_type
            self.metadata = metadata or {}

            def __lt__(self, other: "Event") -> bool:
            """Compare events by timestamp for priority queue."""
            return self.timestamp< other.timestamp

                                   def __repr__(self) -> str:
            return f"{self.__class__.__name__}(timestamp={self.timestamp})"


            class MarketEvent(Event):
            """Market data event (trade, quote, or bar)."""

            def __init__(
            self,
            timestamp: datetime,
            asset_id: AssetId,
            data_type: MarketDataType,
            price: Price | None = None,
            size: Quantity | None = None,
            bid_price: Price | None = None,
            ask_price: Price | None = None,
            bid_size: Quantity | None = None,
            ask_size: Quantity | None = None,
            open: Price | None = None,
            high: Price | None = None,
            low: Price | None = None,
            close: Price | None = None,
            volume: Volume | None = None,
            metadata: dict[str, Any] | None = None,
            ):
            super().__init__(timestamp, EventType.MARKET, metadata)
            self.asset_id = asset_id
            self.data_type = data_type
            self.price = price
            self.size = size
            self.bid_price = bid_price
            self.ask_price = ask_price
            self.bid_size = bid_size
            self.ask_size = ask_size
            self.open = open
            self.high = high
            self.low = low
            self.close = close
            self.volume = volume


            class SignalEvent(Event):
            """ML model signal event."""

            def __init__(
            self,
            timestamp: datetime,
            asset_id: AssetId,
            signal_value: float,
            model_id: str,
            confidence: float | None = None,
            features: dict[str, Any] | None = None,
            ts_event: datetime | None = None,
            ts_arrival: datetime | None = None,
            metadata: dict[str, Any] | None = None,
            ):
            super().__init__(timestamp, EventType.SIGNAL, metadata)
            self.asset_id = asset_id
            self.signal_value = signal_value
            self.model_id = model_id
            self.confidence = confidence
            self.features = features or {}
            self.ts_event = ts_event
            self.ts_arrival = ts_arrival or timestamp


            class OrderEvent(Event):
            """Order submission event."""

            def __init__(
            self,
            timestamp: datetime,
            order_id: OrderId,
            asset_id: AssetId,
            order_type: OrderType,
            side: OrderSide,
            quantity: Quantity,
            limit_price: Price | None = None,
            stop_price: Price | None = None,
            time_in_force: TimeInForce = TimeInForce.DAY,
            parent_order_id: OrderId | None = None,
            metadata: dict[str, Any] | None = None,
            ):
            super().__init__(timestamp, EventType.ORDER, metadata)
            self.order_id = order_id
            self.asset_id = asset_id
            self.order_type = order_type
            self.side = side
            self.quantity = quantity
            self.limit_price = limit_price
            self.stop_price = stop_price
            self.time_in_force = time_in_force
            self.parent_order_id = parent_order_id


            class FillEvent(Event):
            """Order fill/execution event."""

            def __init__(
            self,
            timestamp: datetime,
            order_id: OrderId,
            trade_id: str,
            asset_id: AssetId,
            side: OrderSide,
            fill_quantity: Quantity,
            fill_price: Price,
            commission: float = 0.0,
            slippage: float = 0.0,
            market_impact: float = 0.0,
            metadata: dict[str, Any] | None = None,
            ):
            super().__init__(timestamp, EventType.FILL, metadata)
            self.order_id = order_id
            self.trade_id = trade_id
            self.asset_id = asset_id
            self.side = side
            self.fill_quantity = fill_quantity
            self.fill_price = fill_price
            self.commission = commission
            self.slippage = slippage
            self.market_impact = market_impact

            @property
            def total_cost(self) -> float:
            """Total transaction cost including all fees."""
            return self.commission + self.slippage + self.market_impact


            class CorporateActionEvent(Event):
            """Corporate action event (split, dividend, etc)."""

            def __init__(
            self,
            timestamp: datetime,
            asset_id: AssetId,
            action_type: str,
            ex_date: datetime,
            record_date: datetime | None = None,
            payment_date: datetime | None = None,
            adjustment_factor: float | None = None,
            dividend_amount: float | None = None,
            metadata: dict[str, Any] | None = None,
            ):
            super().__init__(timestamp, EventType.CORPORATE_ACTION, metadata)
            self.asset_id = asset_id
            self.action_type = action_type
            self.ex_date = ex_date
            self.record_date = record_date
            self.payment_date = payment_date
            self.adjustment_factor = adjustment_factor
            self.dividend_amount = dividend_amount


            class EventBus:
            """Central event distribution system."""

            def __init__(self, use_priority_queue: bool = True):
            """
            Initialize the event bus.

            Args:
            use_priority_queue: If True, events are processed by timestamp priority
            """
            self.use_priority_queue = use_priority_queue

            if use_priority_queue:
            self._queue: list[Event] = [] # Will use heapq
            else:
            self._queue: deque = deque()

            self._subscribers: dict[EventType, list[Callable]] = {}
            self._running = False
            self._lock = threading.Lock()

            def subscribe(self, event_type: EventType, handler: Callable[[Event], None]) -> None:
            """
            Subscribe to events of a specific type.

            Args:
            event_type: Type of events to subscribe to
            handler: Callback function to handle events
            """
            with self._lock:
            if event_type not in self._subscribers:
            self._subscribers[event_type] = []
            if handler not in self._subscribers[event_type]:
            self._subscribers[event_type].append(handler)

            def unsubscribe(self, event_type: EventType, handler: Callable[[Event], None]) -> None:
            """
            Unsubscribe from events.

            Args:
            event_type: Type of events to unsubscribe from
            handler: Handler to remove
            """
            with self._lock:
            if event_type in self._subscribers:
            if handler in self._subscribers[event_type]:
            self._subscribers[event_type].remove(handler)

            def publish(self, event: Event) -> None:
            """
            Publish an event to the queue.

            Args:
            event: Event to publish
            """
            with self._lock:
            if self.use_priority_queue:
            heapq.heappush(self._queue, event)
            else:
            self._queue.append(event)

            def process_next(self) -> Event | None:
            """
            Process the next event in the queue.

            Returns:
            The processed event or None if queue is empty
            """
            with self._lock:
            if not self._queue:
            return None

            event = heapq.heappop(self._queue) if self.use_priority_queue else self._queue.popleft()

            # Notify subscribers (outside of lock to prevent deadlock)
            self._notify_subscribers(event)
            return event

            def process_all(self, max_events: int | None = None) -> int:
            """
            Process all pending events.

            Args:
            max_events: Maximum number of events to process

            Returns:
            Number of events processed
            """
            count = 0
            while self._queue and (max_events is None or count< max_events):
            if self.process_next() is not None:
            count += 1
            else:
            break
            return count

            def peek(self) -> Event | None:
            """
            Peek at the next event without removing it.

            Returns:
            Next event or None if queue is empty
            """
            with self._lock:
            if not self._queue:
            return None

            if self.use_priority_queue:
            return self._queue[0] if self._queue else None
            return self._queue[0] if self._queue else None

            def clear(self) -> None:
            """Clear all pending events."""
            with self._lock:
            if self.use_priority_queue:
            self._queue.clear()
            else:
            self._queue.clear()

            @property
            def pending_count(self) -> int:
            """Number of pending events in the queue."""
            with self._lock:
            return len(self._queue)

            def _notify_subscribers(self, event: Event) -> None:
            """
            Notify all subscribers of an event.

            Args:
            event: Event to send to subscribers
            """
            handlers = []
            with self._lock:
            if event.event_type in self._subscribers:
            handlers = self._subscribers[event.event_type].copy()

            for handler in handlers:
            try:
            handler(event)
            except Exception as e:
            logger.error(f"Error in event handler: {e}", exc_info=True)
        </file>

        <file path="src/qengine/core/types.py">
            """Core type definitions for QEngine."""

            from datetime import datetime
            from decimal import Decimal
            from enum import Enum
            from typing import NewType, Union

            # Time types
            Timestamp = NewType("Timestamp", datetime)
            Nanoseconds = NewType("Nanoseconds", int)

            # Market data types
            AssetId = NewType("AssetId", str)
            Price = Union[float, Decimal]
            Quantity = Union[float, int]
            Volume = Union[float, int]

            # Order types
            OrderId = NewType("OrderId", str)
            TradeId = NewType("TradeId", str)
            PositionId = NewType("PositionId", str)

            # Portfolio types
            Cash = Union[float, Decimal]
            Currency = NewType("Currency", str)


            class EventType(Enum):
            """Types of events in the system."""

            MARKET = "market"
            SIGNAL = "signal"
            ORDER = "order"
            FILL = "fill"
            CORPORATE_ACTION = "corporate_action"
            TIMER = "timer"
            CUSTOM = "custom"


            class OrderType(Enum):
            """Types of orders."""

            MARKET = "market"
            LIMIT = "limit"
            STOP = "stop"
            STOP_LIMIT = "stop_limit"
            TRAILING_STOP = "trailing_stop"
            BRACKET = "bracket"
            OCO = "oco"


            class OrderStatus(Enum):
            """Order status lifecycle."""

            CREATED = "created"
            SUBMITTED = "submitted"
            ACCEPTED = "accepted"
            PARTIALLY_FILLED = "partially_filled"
            FILLED = "filled"
            CANCELED = "canceled"
            REJECTED = "rejected"
            EXPIRED = "expired"


            class OrderSide(Enum):
            """Order side (buy/sell)."""

            BUY = "buy"
            SELL = "sell"
            SHORT = "short"
            COVER = "cover"


            class TimeInForce(Enum):
            """Time-in-force constraints for orders."""

            DAY = "day" # Valid for the day
            GTC = "gtc" # Good till canceled
            IOC = "ioc" # Immediate or cancel
            FOK = "fok" # Fill or kill
            GTD = "gtd" # Good till date
            MOC = "moc" # Market on close
            MOO = "moo" # Market on open


            class AssetType(Enum):
            """Types of tradeable assets."""

            EQUITY = "equity"
            FUTURE = "future"
            OPTION = "option"
            FOREX = "forex"
            CRYPTO = "crypto"
            BOND = "bond"
            COMMODITY = "commodity"
            INDEX = "index"


            class BarType(Enum):
            """Types of price bars."""

            TICK = "tick"
            TIME = "time"
            VOLUME = "volume"
            DOLLAR = "dollar"
            TICK_IMBALANCE = "tick_imbalance"
            VOLUME_IMBALANCE = "volume_imbalance"


            class MarketDataType(Enum):
            """Types of market data."""

            TRADE = "trade"
            QUOTE = "quote"
            BAR = "bar"
            ORDERBOOK = "orderbook"
        </file>

        <file path="src/qengine/data/__init__.py">
            """Data management for QEngine."""

            from qengine.data.feed import DataFeed, SignalSource
            from qengine.data.schemas import MarketDataSchema, SignalSchema

            __all__ = [
            "DataFeed",
            "MarketDataSchema",
            "SignalSchema",
            "SignalSource",
            ]
        </file>

        <file path="src/qengine/data/feed.py">
            """Data feed interfaces and implementations for QEngine."""

            from abc import ABC, abstractmethod
            from datetime import datetime
            from pathlib import Path
            from typing import Any

            import polars as pl

            from qengine.core.event import Event, MarketEvent, SignalEvent
            from qengine.core.types import AssetId, MarketDataType


            class DataFeed(ABC):
            """Abstract base class for all data feeds."""

            @abstractmethod
            def get_next_event(self) -> Event | None:
            """
            Get the next event from this data feed.

            Returns:
            Next event or None if no more data
            """

            @abstractmethod
            def peek_next_timestamp(self) -> datetime | None:
            """
            Peek at the timestamp of the next event without consuming it.

            Returns:
            Timestamp of next event or None if no more data
            """

            @abstractmethod
            def reset(self) -> None:
            """Reset the data feed to the beginning."""

            @abstractmethod
            def seek(self, timestamp: datetime) -> None:
            """
            Seek to a specific timestamp.

            Args:
            timestamp: Target timestamp to seek to
            """

            @property
            @abstractmethod
            def is_exhausted(self) -> bool:
            """Check if the data feed has no more events."""


            class SignalSource(ABC):
            """Abstract base class for ML signal sources."""

            @abstractmethod
            def get_next_signal(self) -> SignalEvent | None:
            """
            Get the next signal from this source.

            Returns:
            Next signal event or None if no more signals
            """

            @abstractmethod
            def peek_next_timestamp(self) -> datetime | None:
            """
            Peek at the timestamp of the next signal.

            Returns:
            Timestamp of next signal or None
            """

            @abstractmethod
            def reset(self) -> None:
            """Reset the signal source."""


            class ParquetDataFeed(DataFeed):
            """Data feed that reads from Parquet files using Polars."""

            def __init__(
            self,
            path: Path,
            asset_id: AssetId,
            data_type: MarketDataType = MarketDataType.BAR,
            timestamp_column: str = "timestamp",
            filters: list[tuple] | None = None,
            ):
            """
            Initialize Parquet data feed.

            Args:
            path: Path to Parquet file
            asset_id: Asset identifier
            data_type: Type of market data
            timestamp_column: Name of timestamp column
            filters: Optional Polars filters to apply
            """
            self.path = Path(path)
            self.asset_id = asset_id
            self.data_type = data_type
            self.timestamp_column = timestamp_column

            # Load data lazily with Polars
            self.lazy_df = pl.scan_parquet(str(self.path))

            # Apply filters if provided
            if filters:
            for filter_expr in filters:
            self.lazy_df = self.lazy_df.filter(filter_expr)

            # Sort by timestamp and collect
            self.df = self.lazy_df.sort(timestamp_column).collect()

            self.current_index = 0
            self.max_index = len(self.df) - 1

            def get_next_event(self) -> MarketEvent | None:
            """Get the next market event."""
            if self.is_exhausted:
            return None

            row = self.df.row(self.current_index, named=True)
            self.current_index += 1

            # Create MarketEvent based on data type
            event = self._create_market_event(row)
            return event

            def _create_market_event(self, row: dict[str, Any]) -> MarketEvent:
            """Create a MarketEvent from a data row."""
            timestamp = row[self.timestamp_column]

            # Convert timestamp if needed
            if not isinstance(timestamp, datetime):
            timestamp = datetime.fromisoformat(str(timestamp))

            # Map column names to MarketEvent fields
            return MarketEvent(
            timestamp=timestamp,
            asset_id=self.asset_id,
            data_type=self.data_type,
            open=row.get("open"),
            high=row.get("high"),
            low=row.get("low"),
            close=row.get("close"),
            volume=row.get("volume"),
            price=row.get("price", row.get("close")),
            size=row.get("size"),
            bid_price=row.get("bid"),
            ask_price=row.get("ask"),
            bid_size=row.get("bid_size"),
            ask_size=row.get("ask_size"),
            )

            def peek_next_timestamp(self) -> datetime | None:
            """Peek at the next timestamp."""
            if self.is_exhausted:
            return None

            timestamp = self.df[self.timestamp_column][self.current_index]
            if not isinstance(timestamp, datetime):
            timestamp = datetime.fromisoformat(str(timestamp))

            return timestamp

            def reset(self) -> None:
            """Reset to the beginning."""
            self.current_index = 0

            def seek(self, timestamp: datetime) -> None:
            """Seek to a specific timestamp."""
            # Find the index of the first row >= timestamp
            mask = self.df[self.timestamp_column] >= timestamp
            indices = mask.arg_true()

            if len(indices) > 0:
            self.current_index = indices[0]
            else:
            self.current_index = self.max_index + 1

            @property
            def is_exhausted(self) -> bool:
            """Check if all data has been consumed."""
            return self.current_index > self.max_index


            class CSVDataFeed(DataFeed):
            """Data feed that reads from CSV files."""

            def __init__(
            self,
            path: Path,
            asset_id: AssetId,
            data_type: MarketDataType = MarketDataType.BAR,
            timestamp_column: str = "timestamp",
            parse_dates: bool = True,
            **csv_kwargs,
            ):
            """
            Initialize CSV data feed.

            Args:
            path: Path to CSV file
            asset_id: Asset identifier
            data_type: Type of market data
            timestamp_column: Name of timestamp column
            parse_dates: Whether to parse dates automatically
            **csv_kwargs: Additional arguments for Polars read_csv
            """
            self.path = Path(path)
            self.asset_id = asset_id
            self.data_type = data_type
            self.timestamp_column = timestamp_column

            # Read CSV with Polars
            if parse_dates:
            csv_kwargs["try_parse_dates"] = True

            self.df = pl.read_csv(str(self.path), **csv_kwargs).sort(timestamp_column)

            self.current_index = 0
            self.max_index = len(self.df) - 1

            def get_next_event(self) -> MarketEvent | None:
            """Get the next market event."""
            if self.is_exhausted:
            return None

            row = self.df.row(self.current_index, named=True)
            self.current_index += 1

            return self._create_market_event(row)

            def _create_market_event(self, row: dict[str, Any]) -> MarketEvent:
            """Create a MarketEvent from a data row."""
            timestamp = row[self.timestamp_column]

            if not isinstance(timestamp, datetime):
            timestamp = datetime.fromisoformat(str(timestamp))

            return MarketEvent(
            timestamp=timestamp,
            asset_id=self.asset_id,
            data_type=self.data_type,
            open=row.get("open"),
            high=row.get("high"),
            low=row.get("low"),
            close=row.get("close"),
            volume=row.get("volume"),
            price=row.get("price", row.get("close")),
            )

            def peek_next_timestamp(self) -> datetime | None:
            """Peek at the next timestamp."""
            if self.is_exhausted:
            return None

            timestamp = self.df[self.timestamp_column][self.current_index]
            if not isinstance(timestamp, datetime):
            timestamp = datetime.fromisoformat(str(timestamp))

            return timestamp

            def reset(self) -> None:
            """Reset to the beginning."""
            self.current_index = 0

            def seek(self, timestamp: datetime) -> None:
            """Seek to a specific timestamp."""
            mask = self.df[self.timestamp_column] >= timestamp
            indices = mask.arg_true()

            if len(indices) > 0:
            self.current_index = indices[0]
            else:
            self.current_index = self.max_index + 1

            @property
            def is_exhausted(self) -> bool:
            """Check if all data has been consumed."""
            return self.current_index > self.max_index


            class ParquetSignalSource(SignalSource):
            """Signal source that reads ML signals from Parquet files."""

            def __init__(
            self,
            path: Path,
            model_id: str,
            timestamp_column: str = "timestamp",
            asset_column: str = "asset_id",
            signal_column: str = "signal",
            confidence_column: str | None = "confidence",
            ts_event_column: str | None = "ts_event",
            ts_arrival_column: str | None = "ts_arrival",
            ):
            """
            Initialize Parquet signal source.

            Args:
            path: Path to Parquet file with signals
            model_id: Identifier for the ML model
            timestamp_column: Column with signal timestamp
            asset_column: Column with asset identifiers
            signal_column: Column with signal values
            confidence_column: Optional column with confidence scores
            ts_event_column: Optional column with event generation time
            ts_arrival_column: Optional column with signal arrival time
            """
            self.path = Path(path)
            self.model_id = model_id
            self.timestamp_column = timestamp_column
            self.asset_column = asset_column
            self.signal_column = signal_column
            self.confidence_column = confidence_column
            self.ts_event_column = ts_event_column
            self.ts_arrival_column = ts_arrival_column

            # Load signals with Polars
            self.df = pl.scan_parquet(str(self.path)).sort(timestamp_column).collect()

            self.current_index = 0
            self.max_index = len(self.df) - 1

            def get_next_signal(self) -> SignalEvent | None:
            """Get the next signal event."""
            if self.current_index > self.max_index:
            return None

            row = self.df.row(self.current_index, named=True)
            self.current_index += 1

            timestamp = row[self.timestamp_column]
            if not isinstance(timestamp, datetime):
            timestamp = datetime.fromisoformat(str(timestamp))

            return SignalEvent(
            timestamp=timestamp,
            asset_id=AssetId(row[self.asset_column]),
            signal_value=float(row[self.signal_column]),
            model_id=self.model_id,
            confidence=float(row[self.confidence_column])
            if self.confidence_column and self.confidence_column in row
            else None,
            ts_event=row.get(self.ts_event_column) if self.ts_event_column else None,
            ts_arrival=row.get(self.ts_arrival_column) if self.ts_arrival_column else timestamp,
            )

            def peek_next_timestamp(self) -> datetime | None:
            """Peek at the next signal timestamp."""
            if self.current_index > self.max_index:
            return None

            timestamp = self.df[self.timestamp_column][self.current_index]
            if not isinstance(timestamp, datetime):
            timestamp = datetime.fromisoformat(str(timestamp))

            return timestamp

            def reset(self) -> None:
            """Reset to the beginning."""
            self.current_index = 0
        </file>

        <file path="src/qengine/data/schemas.py">
            """Data schemas for QEngine."""

            from dataclasses import dataclass

            import polars as pl


            @dataclass
            class MarketDataSchema:
            """Schema definition for market data."""

            timestamp_col: str = "timestamp"
            open_col: str = "open"
            high_col: str = "high"
            low_col: str = "low"
            close_col: str = "close"
            volume_col: str = "volume"

            def get_dtypes(self) -> dict[str, pl.DataType]:
            """Get Polars data types for the schema."""
            return {
            self.timestamp_col: pl.Datetime("ns"),
            self.open_col: pl.Float64,
            self.high_col: pl.Float64,
            self.low_col: pl.Float64,
            self.close_col: pl.Float64,
            self.volume_col: pl.Int64,
            }

            def validate(self, df: pl.DataFrame) -> None:
            """Validate a DataFrame against this schema."""
            required_cols = [
            self.timestamp_col,
            self.open_col,
            self.high_col,
            self.low_col,
            self.close_col,
            self.volume_col,
            ]

            missing_cols = set(required_cols) - set(df.columns)
            if missing_cols:
            raise ValueError(f"Missing required columns: {missing_cols}")

            # Validate data types
            for col, expected_dtype in self.get_dtypes().items():
            if col in df.columns:
            actual_dtype = df[col].dtype
            if not self._compatible_dtypes(actual_dtype, expected_dtype):
            raise TypeError(
            f"Column {col} has type {actual_dtype}, expected {expected_dtype}",
            )

            def _compatible_dtypes(self, actual: pl.DataType, expected: pl.DataType) -> bool:
            """Check if data types are compatible."""
            # Allow int to float conversion
            if expected == pl.Float64 and actual in [pl.Int32, pl.Int64]:
            return True
            # Allow different datetime precisions
            if isinstance(expected, pl.Datetime) and isinstance(actual, pl.Datetime):
            return True
            return actual == expected


            @dataclass
            class SignalSchema:
            """Schema definition for ML signals."""

            timestamp_col: str = "timestamp"
            asset_id_col: str = "asset_id"
            signal_col: str = "signal"
            confidence_col: str | None = "confidence"
            model_id_col: str | None = "model_id"

            def get_dtypes(self) -> dict[str, pl.DataType]:
            """Get Polars data types for the schema."""
            dtypes = {
            self.timestamp_col: pl.Datetime("ns"),
            self.asset_id_col: pl.Utf8,
            self.signal_col: pl.Float64,
            }

            if self.confidence_col:
            dtypes[self.confidence_col] = pl.Float64
            if self.model_id_col:
            dtypes[self.model_id_col] = pl.Utf8

            return dtypes

            def validate(self, df: pl.DataFrame) -> None:
            """Validate a DataFrame against this schema."""
            required_cols = [
            self.timestamp_col,
            self.asset_id_col,
            self.signal_col,
            ]

            missing_cols = set(required_cols) - set(df.columns)
            if missing_cols:
            raise ValueError(f"Missing required columns: {missing_cols}")

            # Validate data types
            for col, expected_dtype in self.get_dtypes().items():
            if col in df.columns:
            actual_dtype = df[col].dtype
            if not self._compatible_dtypes(actual_dtype, expected_dtype):
            raise TypeError(
            f"Column {col} has type {actual_dtype}, expected {expected_dtype}",
            )

            def _compatible_dtypes(self, actual: pl.DataType, expected: pl.DataType) -> bool:
            """Check if data types are compatible."""
            # Allow int to float conversion
            if expected == pl.Float64 and actual in [pl.Int32, pl.Int64]:
            return True
            # Allow different datetime precisions
            if isinstance(expected, pl.Datetime) and isinstance(actual, pl.Datetime):
            return True
            return actual == expected
        </file>

        <file path="src/qengine/execution/__init__.py">
            """Execution module for QEngine."""

            from qengine.execution.broker import Broker, SimulationBroker
            from qengine.execution.order import Order, OrderState

            __all__ = [
            "Broker",
            "Order",
            "OrderState",
            "SimulationBroker",
            ]
        </file>

        <file path="src/qengine/execution/broker.py">
            """Broker implementations for QEngine."""

            import logging
            from abc import ABC, abstractmethod
            from collections import defaultdict
            from datetime import datetime
            from typing import TYPE_CHECKING, Any

            from qengine.core.assets import AssetRegistry
            from qengine.core.event import FillEvent, MarketEvent
            from qengine.core.types import (
            AssetId,
            OrderId,
            OrderSide,
            OrderStatus,
            OrderType,
            Price,
            Quantity,
            )
            from qengine.execution.order import Order, OrderState
            from qengine.portfolio.margin import MarginAccount

            if TYPE_CHECKING:
            from qengine.execution.commission import CommissionModel
            from qengine.execution.market_impact import MarketImpactModel
            from qengine.execution.slippage import SlippageModel

            logger = logging.getLogger(__name__)


            class Broker(ABC):
            """Abstract base class for broker implementations."""

            @abstractmethod
            def submit_order(self, order: Order) -> OrderId:
            """Submit an order for execution."""

            @abstractmethod
            def cancel_order(self, order_id: OrderId) -> bool:
            """Cancel an existing order."""

            @abstractmethod
            def get_order(self, order_id: OrderId) -> Order | None:
            """Get order by ID."""

            @abstractmethod
            def get_open_orders(self, asset_id: AssetId | None = None) -> list[Order]:
            """Get all open orders, optionally filtered by asset."""

            @abstractmethod
            def on_market_event(self, event: MarketEvent) -> list[FillEvent]:
            """Process market event and generate fills."""


            class SimulationBroker(Broker):
            """
            Simulated broker for backtesting.

            Handles order execution with configurable realism models.
            Supports multiple asset classes including equities, futures, options, FX, and crypto.
            """

            def __init__(
            self,
            initial_cash: float = 100000.0,
            asset_registry: AssetRegistry | None = None,
            commission_model: "CommissionModel | None" = None,
            slippage_model: "SlippageModel | None" = None,
            market_impact_model: "MarketImpactModel | None" = None,
            fill_model: Any | None = None,
            enable_margin: bool = True,
            ):
            """
            Initialize simulation broker.

            Args:
            initial_cash: Starting cash balance
            asset_registry: Registry of asset specifications
            commission_model: Model for calculating commissions
            slippage_model: Model for calculating slippage
            market_impact_model: Model for calculating market impact
            fill_model: Model for determining fills
            enable_margin: Whether to enable margin trading for derivatives
            """
            self.cash = initial_cash
            self.asset_registry = asset_registry or AssetRegistry()
            self.commission_model = commission_model
            self.slippage_model = slippage_model
            self.market_impact_model = market_impact_model
            self.fill_model = fill_model
            self.enable_margin = enable_margin

            # Order tracking
            self._orders: dict[OrderId, Order] = {}
            self._open_orders: dict[AssetId, list[Order]] = defaultdict(list)
            self._stop_orders: dict[AssetId, list[Order]] = defaultdict(list)
            self._trailing_stops: dict[AssetId, list[Order]] = defaultdict(list)
            self._bracket_orders: dict[AssetId, list[Order]] = defaultdict(list)

            # Position tracking
            self._positions: dict[AssetId, Quantity] = defaultdict(float)

            # Margin account for derivatives
            if enable_margin:
            self.margin_account = MarginAccount(initial_cash, self.asset_registry)

            # Latest market prices
            self._last_prices: dict[AssetId, Price] = {}

            # Statistics
            self._total_commission = 0.0
            self._total_slippage = 0.0
            self._fill_count = 0

            def submit_order(self, order: Order) -> OrderId:
            """
            Submit an order for execution.

            Args:
            order: Order to submit

            Returns:
            Order ID
            """
            # Store order
            self._orders[order.order_id] = order

            # Update order state
            order.state = OrderState.SUBMITTED
            order.status = OrderStatus.SUBMITTED
            order.submitted_time = datetime.now()

            # Route based on order type
            if order.order_type in [OrderType.STOP, OrderType.STOP_LIMIT]:
            self._stop_orders[order.asset_id].append(order)
            elif order.order_type == OrderType.TRAILING_STOP:
            self._trailing_stops[order.asset_id].append(order)
            # Initialize trailing stop price
            if order.asset_id in self._last_prices:
            order.update_trailing_stop(self._last_prices[order.asset_id])
            elif order.order_type == OrderType.BRACKET:
            # Bracket orders start as regular orders and create legs after fill
            self._open_orders[order.asset_id].append(order)
            else:
            self._open_orders[order.asset_id].append(order)

            # Try immediate execution for market orders
            if order.order_type == OrderType.MARKET:
            if order.asset_id in self._last_prices:
            self._try_fill_order(order, self._last_prices[order.asset_id])

            logger.debug(f"Submitted order: {order}")
            return order.order_id

            def cancel_order(self, order_id: OrderId) -> bool:
            """
            Cancel an existing order.

            Args:
            order_id: ID of order to cancel

            Returns:
            True if cancelled successfully
            """
            if order_id not in self._orders:
            return False

            order = self._orders[order_id]

            if not order.is_active:
            return False

            # Remove from order queues
            if order in self._open_orders[order.asset_id]:
            self._open_orders[order.asset_id].remove(order)
            if order in self._stop_orders[order.asset_id]:
            self._stop_orders[order.asset_id].remove(order)
            if order in self._trailing_stops[order.asset_id]:
            self._trailing_stops[order.asset_id].remove(order)
            # Bracket orders are tracked in open orders, not separately during submission

            # Update order state
            order.cancel()

            logger.debug(f"Cancelled order: {order}")
            return True

            def get_order(self, order_id: OrderId) -> Order | None:
            """Get order by ID."""
            return self._orders.get(order_id)

            def get_open_orders(self, asset_id: AssetId | None = None) -> list[Order]:
            """Get all open orders, optionally filtered by asset."""
            if asset_id:
            return [o for o in self._open_orders[asset_id] if o.is_active]
            orders = []
            for asset_orders in self._open_orders.values():
            orders.extend([o for o in asset_orders if o.is_active])
            return orders

            def on_market_event(self, event: MarketEvent) -> list[FillEvent]:
            """
            Process market event and generate fills.

            Args:
            event: Market data event

            Returns:
            List of fill events generated
            """
            fills = []
            asset_id = event.asset_id

            # Determine execution price
            if event.close is not None:
            price = event.close
            elif event.price is not None:
            price = event.price
            else:
            return fills # No price available

            # Update last known price
            self._last_prices[asset_id] = price

            # Check stop orders for triggering
            triggered_stops = []
            for order in list(self._stop_orders[asset_id]):
            if self._should_trigger_stop(order, price):
            triggered_stops.append(order)
            self._stop_orders[asset_id].remove(order)

            # Process triggered stops immediately
            for order in triggered_stops:
            if order.order_type == OrderType.STOP:
            # Convert to market order and try to fill immediately
            original_type = order.order_type
            order.metadata["original_type"] = "STOP"
            order.order_type = OrderType.MARKET
            fill_event = self._try_fill_order(order, price, event.timestamp)
            if fill_event:
            fills.append(fill_event)

            # FIX: Handle OCO logic for bracket legs that are filled as stop orders
            if (
            order.is_filled
            and order.child_order_ids
            and order.metadata.get("bracket_type")
            ):
            # This is a bracket leg that was filled - cancel sibling orders
            for child_id in order.child_order_ids:
            if child_id in self._orders:
            self.cancel_order(child_id)

            else:
            # If couldn't fill as market order, restore type and add to open orders
            order.order_type = original_type
            del order.metadata["original_type"]
            self._open_orders[asset_id].append(order)
            elif order.order_type == OrderType.STOP_LIMIT:
            # Keep as limit order after triggering
            order.order_type = OrderType.LIMIT
            self._open_orders[asset_id].append(order)

            # Update and check trailing stops
            triggered_trailing = []
            for order in list(self._trailing_stops[asset_id]):
            # Update trailing stop level
            order.update_trailing_stop(price)
            # Check if triggered
            if order.can_fill(price):
            triggered_trailing.append(order)
            self._trailing_stops[asset_id].remove(order)

            # Process triggered trailing stops immediately (as market orders)
            for order in triggered_trailing:
            original_type = order.order_type
            order.metadata["original_type"] = "TRAILING_STOP"
            order.order_type = OrderType.MARKET
            fill_event = self._try_fill_order(order, price, event.timestamp)
            if fill_event:
            fills.append(fill_event)

            # FIX: Handle OCO logic for bracket legs that are filled as trailing stops
            if order.is_filled and order.child_order_ids and order.metadata.get("bracket_type"):
            # This is a bracket leg that was filled - cancel sibling orders
            for child_id in order.child_order_ids:
            if child_id in self._orders:
            self.cancel_order(child_id)

            else:
            # If couldn't fill as market order, restore type and add to open orders
            order.order_type = original_type
            del order.metadata["original_type"]
            self._open_orders[asset_id].append(order)

            # Process open orders
            for order in list(self._open_orders[asset_id]):
            if not order.is_active:
            continue

            fill_event = self._try_fill_order(order, price, event.timestamp)
            if fill_event:
            fills.append(fill_event)

            # Remove filled orders
            if order.is_filled:
            self._open_orders[asset_id].remove(order)

            # Handle bracket order completion
            if order.order_type == OrderType.BRACKET:
            self._handle_bracket_fill(order, fill_event)
            # Handle OCO (One-Cancels-Other) logic for bracket legs
            # Only cancel sibling orders if this is a bracket leg (not the parent)
            elif order.child_order_ids and order.metadata.get("bracket_type"):
            for child_id in order.child_order_ids:
            if child_id in self._orders:
            self.cancel_order(child_id)

            return fills

            def _should_trigger_stop(self, order: Order, price: Price) -> bool:
            """Check if stop order should be triggered."""
            if order.stop_price is None:
            return False

            if order.is_buy:
            return price >= order.stop_price
            return price<= order.stop_price

            def _handle_bracket_fill(self, parent_order: Order, fill_event) -> None:
            """
            Handle completion of bracket order by creating stop-loss and take-profit orders.

            Args:
            parent_order: The filled bracket order
            fill_event: The fill event that completed the order
            """
            if parent_order.order_type != OrderType.BRACKET:
            return

            if parent_order.stop_loss is None or parent_order.profit_target is None:
            return

            # Bracket order was filled from open orders, no need to remove from special tracking

            # Create stop-loss order (opposite side)
            stop_side = OrderSide.SELL if parent_order.is_buy else OrderSide.BUY
            stop_order = Order(
            asset_id=parent_order.asset_id,
            order_type=OrderType.STOP,
            side=stop_side,
            quantity=parent_order.filled_quantity,
            stop_price=parent_order.stop_loss,
            parent_order_id=parent_order.order_id,
            metadata={"bracket_type": "stop_loss"},
            )

            # Create take-profit order (opposite side)
            profit_order = Order(
            asset_id=parent_order.asset_id,
            order_type=OrderType.LIMIT,
            side=stop_side,
            quantity=parent_order.filled_quantity,
            limit_price=parent_order.profit_target,
            parent_order_id=parent_order.order_id,
            metadata={"bracket_type": "take_profit"},
            )

            # Link the orders as OCO (One-Cancels-Other)
            stop_order.child_order_ids.append(profit_order.order_id)
            profit_order.child_order_ids.append(stop_order.order_id)

            # Submit the bracket legs
            self.submit_order(stop_order)
            self.submit_order(profit_order)

            # Track parent-child relationship
            parent_order.child_order_ids.extend([stop_order.order_id, profit_order.order_id])

            def _try_fill_order(
            self,
            order: Order,
            market_price: Price,
            timestamp: datetime | None = None,
            ) -> FillEvent | None:
            """
            Try to fill an order at the given price.

            Args:
            order: Order to fill
            market_price: Current market price
            timestamp: Event timestamp

            Returns:
            FillEvent if order was filled
            """
            # Check if order can be filled
            if not order.can_fill(market_price):
            return None

            # Apply market impact to the market price
            impacted_market_price = self._get_market_price_with_impact(
            order,
            market_price,
            timestamp or datetime.now(),
            )

            # Determine fill price (with slippage on top of impact)
            fill_price = self._calculate_fill_price(order, impacted_market_price)

            # Determine fill quantity (for now, always fill completely)
            fill_quantity = order.remaining_quantity

            # Get asset specification
            asset_spec = self.asset_registry.get(order.asset_id)

            # Check margin requirements for derivatives
            if self.enable_margin and asset_spec and asset_spec.requires_margin:
            # Check margin for opening/increasing position
            if order.is_buy:
            has_margin, required_margin = self.margin_account.check_margin_requirement(
            order.asset_id,
            fill_quantity,
            fill_price,
            )
            if not has_margin:
            # Try partial fill within margin
            max_quantity = (
            self.margin_account.available_margin / required_margin * fill_quantity
            )
            if max_quantity
            < asset_spec.min_quantity:
              return None
              fill_quantity= max_quantity
              elif order.is_sell and order.asset_id not in self._positions:
            # Short selling - check margin
            has_margin, required_margin = self.margin_account.check_margin_requirement(
            order.asset_id,
            -fill_quantity,
            fill_price,
            )
            if not has_margin:
            return None
            else:
            # Standard cash trading for equities
            if order.is_buy:
            # Estimate commission for calculation
            estimated_commission = self._calculate_commission(order, fill_quantity, fill_price)
            required_cash = fill_quantity * fill_price + estimated_commission
            if required_cash > self.cash:
            # Partial fill to available cash
            fill_quantity = (self.cash - estimated_commission) / fill_price
            if fill_quantity
            <
            0.01: # Minimum fill size
            return None

            # Check if we have enough shares for sell orders (non-short)
            # Only allow short selling if explicitly enabled in asset spec
            # Note: This check is only for regular orders, not for triggered stops
            if order.is_sell and (not asset_spec or not asset_spec.short_enabled):
            # Allow sell orders that were originally stop/trailing stops
            # (they would have been converted to MARKET by now)
            if order.metadata.get("original_type") not in ["STOP", "TRAILING_STOP"]:
            available_shares = self._positions[order.asset_id]
            if available_shares
            < fill_quantity:
              fill_quantity= available_shares
              if fill_quantity
            <= 0:
            return None

            # Calculate costs (asset-specific for different classes)
            commission = self._calculate_commission(order, fill_quantity, fill_price, asset_spec)
            slippage = self._calculate_slippage(
            order,
            fill_quantity,
            market_price,
            fill_price,
            asset_spec,
            )

            # Update order
            order.update_fill(fill_quantity, fill_price, commission, timestamp)

            # Update positions and cash
            if order.is_buy:
            self._positions[order.asset_id] += fill_quantity
            self.cash -= fill_quantity * fill_price + commission
            else:
            self._positions[order.asset_id] -= fill_quantity
            self.cash += fill_quantity * fill_price - commission

            # Update statistics
            self._total_commission += commission
            self._total_slippage += slippage
            self._fill_count += 1

            # Update market impact after fill
            self._update_market_impact(
            order,
            fill_quantity,
            market_price,
            timestamp or datetime.now(),
            )

            # Create fill event
            fill_event = FillEvent(
            timestamp=timestamp or datetime.now(),
            order_id=order.order_id,
            trade_id=f"T{self._fill_count:06d}",
            asset_id=order.asset_id,
            side=order.side,
            fill_quantity=fill_quantity,
            fill_price=fill_price,
            commission=commission,
            slippage=slippage,
            )

            logger.debug(f"Filled order: {order} with {fill_event}")
            return fill_event

            def _calculate_fill_price(self, order: Order, market_price: Price) -> Price:
            """Calculate the actual fill price including slippage."""
            if self.slippage_model:
            return self.slippage_model.calculate_fill_price(order, market_price)

            # Default simple slippage: 0.01% for market orders
            if order.order_type == OrderType.MARKET:
            if order.is_buy:
            return market_price * 1.0001
            return market_price * 0.9999

            # Limit orders fill at limit price or better
            if order.order_type == OrderType.LIMIT and order.limit_price is not None:
            if order.is_buy:
            return min(order.limit_price, market_price)
            return max(order.limit_price, market_price)

            return market_price

            def _get_market_price_with_impact(
            self,
            order: Order,
            market_price: Price,
            timestamp: datetime,
            ) -> Price:
            """Get market price adjusted for market impact."""
            if not self.market_impact_model:
            return market_price

            # Get current cumulative impact for this asset
            current_impact = self.market_impact_model.get_current_impact(
            order.asset_id,
            timestamp,
            )

            # Apply existing impact to market price
            return market_price + current_impact

            def _update_market_impact(
            self,
            order: Order,
            fill_quantity: Quantity,
            market_price: Price,
            timestamp: datetime,
            ) -> None:
            """Update market impact state after a fill."""
            if not self.market_impact_model:
            return

            # Calculate new impact from this trade
            permanent_impact, temporary_impact = self.market_impact_model.calculate_impact(
            order,
            fill_quantity,
            market_price,
            timestamp,
            )

            # Update market state
            self.market_impact_model.update_market_state(
            order.asset_id,
            permanent_impact,
            temporary_impact,
            timestamp,
            )

            def _calculate_commission(
            self,
            order: Order,
            fill_quantity: Quantity,
            fill_price: Price,
            asset_spec=None,
            ) -> float:
            """Calculate commission for the fill."""
            if self.commission_model:
            return self.commission_model.calculate(order, fill_quantity, fill_price)

            if asset_spec:
            # Use asset-specific fee structure
            notional = fill_quantity * fill_price * getattr(asset_spec, "contract_size", 1.0)
            if order.order_type == OrderType.MARKET:
            return notional * asset_spec.taker_fee
            return notional * asset_spec.maker_fee

            # Simple flat commission: $1 per trade for equities
            return 1.0

            def _calculate_slippage(
            self,
            order: Order,
            fill_quantity: Quantity,
            market_price: Price,
            fill_price: Price,
            asset_spec=None,
            ) -> float:
            """Calculate slippage cost."""
            if self.slippage_model:
            return self.slippage_model.calculate_slippage_cost(
            order,
            fill_quantity,
            market_price,
            fill_price,
            )

            # Default asset-specific slippage
            if asset_spec:
            slippage_rate = 0.0001 # 1 bp default
            if asset_spec.asset_class.value == "crypto":
            slippage_rate = 0.001 # 10 bp for crypto
            elif asset_spec.asset_class.value == "fx":
            slippage_rate = 0.00005 # 0.5 bp for FX
            elif asset_spec.asset_class.value == "future":
            slippage_rate = 0.0002 # 2 bp for futures

            notional = fill_quantity * market_price * getattr(asset_spec, "contract_size", 1.0)
            return notional * slippage_rate

            # Simple calculation: difference between market and fill price
            return abs(fill_price - market_price) * fill_quantity

            def get_position(self, asset_id: AssetId) -> Quantity:
            """Get current position for an asset."""
            return self._positions.get(asset_id, 0.0)

            def get_positions(self) -> dict[AssetId, Quantity]:
            """Get all current positions."""
            return dict(self._positions)

            def get_cash(self) -> float:
            """Get current cash balance."""
            return self.cash

            def get_statistics(self) -> dict[str, Any]:
            """Get broker statistics."""
            return {
            "total_commission": self._total_commission,
            "total_slippage": self._total_slippage,
            "fill_count": self._fill_count,
            "open_orders": sum(len(orders) for orders in self._open_orders.values()),
            "stop_orders": sum(len(orders) for orders in self._stop_orders.values()),
            }

            def initialize(self, portfolio, event_bus) -> None:
            """Initialize broker with portfolio and event bus.

            Args:
            portfolio: Portfolio instance for position tracking
            event_bus: Event bus for publishing fill events
            """
            self.portfolio = portfolio
            self.event_bus = event_bus
            logger.debug("SimulationBroker initialized")

            def on_order_event(self, event) -> None:
            """Handle order event from strategy.

            Args:
            event: OrderEvent to process
            """
            from qengine.execution.order import Order

            # Create Order object from OrderEvent
            order = Order(
            order_id=event.order_id,
            asset_id=event.asset_id,
            order_type=event.order_type,
            side=event.side,
            quantity=event.quantity,
            limit_price=getattr(event, "limit_price", None),
            stop_price=getattr(event, "stop_price", None),
            time_in_force=getattr(event, "time_in_force", None),
            )

            # Submit the order
            self.submit_order(order)

            def finalize(self) -> None:
            """Finalize broker at end of backtest."""
            # Cancel all remaining open orders
            for asset_orders in self._open_orders.values():
            for order in list(asset_orders):
            if order.is_active:
            order.cancel()

            for asset_orders in self._stop_orders.values():
            for order in list(asset_orders):
            if order.is_active:
            order.cancel()

            logger.info(f"SimulationBroker finalized. Total fills: {self._fill_count}")

            def get_trades(self) -> Any:
            """Get all executed trades.

            Returns:
            DataFrame or list of trades
            """
            import polars as pl

            trades = []
            for order_id, order in self._orders.items():
            if order.filled_quantity > 0:
            trades.append(
            {
            "order_id": order_id,
            "asset_id": order.asset_id,
            "side": order.side.value,
            "quantity": order.filled_quantity,
            "price": order.average_fill_price,
            "commission": order.commission,
            "status": order.status.value,
            "submitted_time": order.submitted_time,
            "filled_time": order.filled_time,
            },
            )

            if trades:
            return pl.DataFrame(trades)
            return pl.DataFrame()

            def reset(self) -> None:
            """Reset broker to initial state."""
            self._orders.clear()
            self._open_orders.clear()
            self._stop_orders.clear()
            self._trailing_stops.clear()
            self._bracket_orders.clear()
            self._positions.clear()
            self._last_prices.clear()
            self.cash = self.initial_cash if hasattr(self, "initial_cash") else 100000.0
            self._total_commission = 0.0
            self._total_slippage = 0.0
            self._fill_count = 0
            logger.debug("SimulationBroker reset")
        </file>

        <file path="src/qengine/execution/commission.py">
            """Commission models for realistic cost simulation."""

            from abc import ABC, abstractmethod
            from typing import TYPE_CHECKING, Optional

            if TYPE_CHECKING:
            from qengine.core.types import Price, Quantity
            from qengine.execution.order import Order


            class CommissionModel(ABC):
            """Abstract base class for commission models."""

            @abstractmethod
            def calculate(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            fill_price: "Price",
            ) -> float:
            """Calculate commission for a filled order.

            Args:
            order: The order being filled
            fill_quantity: Quantity of the fill
            fill_price: Price at which the order was filled

            Returns:
            Commission amount in currency terms
            """

            def __repr__(self) -> str:
            """String representation."""
            return f"{self.__class__.__name__}()"


            class NoCommission(CommissionModel):
            """No commission model for testing."""

            def calculate(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            fill_price: "Price",
            ) -> float:
            """Calculate zero commission."""
            return 0.0


            class FlatCommission(CommissionModel):
            """Flat commission per trade."""

            def __init__(self, commission: float = 1.0):
            """Initialize flat commission model.

            Args:
            commission: Flat fee per trade (default $1)
            """
            if commission
            <
            0:
            raise ValueError("Commission cannot be negative")
            self.commission = commission

            def calculate(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            fill_price: "Price",
            ) -> float:
            """Calculate flat commission."""
            return self.commission

            def __repr__(self) -> str:
            """String representation."""
            return f"FlatCommission(commission={self.commission})"


            class PercentageCommission(CommissionModel):
            """Percentage-based commission on trade value."""

            def __init__(self, rate: float = 0.001):
            """Initialize percentage commission model.

            Args:
            rate: Commission rate as decimal (0.001 = 0.1% = 10bps)
            """
            if rate
            <
            0:
            raise ValueError("Commission rate cannot be negative")
            if rate > 0.1: # 10% cap as sanity check
            raise ValueError("Commission rate too high (>10%)")
            self.rate = rate

            def calculate(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            fill_price: "Price",
            ) -> float:
            """Calculate percentage-based commission."""
            notional = fill_quantity * fill_price
            return notional * self.rate

            def __repr__(self) -> str:
            """String representation."""
            return f"PercentageCommission(rate={self.rate})"


            class PerShareCommission(CommissionModel):
            """Per-share commission model."""

            def __init__(self, commission_per_share: float = 0.005):
            """Initialize per-share commission model.

            Args:
            commission_per_share: Commission per share (default $0.005)
            """
            if commission_per_share
            <
            0:
            raise ValueError("Per-share commission cannot be negative")
            self.commission_per_share = commission_per_share

            def calculate(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            fill_price: "Price",
            ) -> float:
            """Calculate per-share commission."""
            return fill_quantity * self.commission_per_share

            def __repr__(self) -> str:
            """String representation."""
            return f"PerShareCommission(commission_per_share={self.commission_per_share})"


            class TieredCommission(CommissionModel):
            """Tiered commission based on trade size."""

            def __init__(
            self,
            tiers: list[tuple[float, float]] | None = None,
            minimum: float = 1.0,
            ):
            """Initialize tiered commission model.

            Args:
            tiers: List of (threshold, rate) tuples in ascending order
            Default: [(10000, 0.0010), (50000, 0.0008), (100000, 0.0005)]
            minimum: Minimum commission per trade
            """
            if tiers is None:
            # Default tiers: better rates for larger trades
            tiers = [
            (10_000, 0.0010), # 10 bps for trades
            <
            $10k
            (50_000, 0.0008), # 8 bps for trades $10k-$50k
            (100_000, 0.0005), # 5 bps for trades $50k-$100k
            (float("inf"), 0.0003), # 3 bps for trades > $100k
            ]

            # Validate tiers
            prev_threshold = 0
            for threshold, rate in tiers:
            if threshold<= prev_threshold:
            raise ValueError("Tiers must be in ascending order")
            if rate
            <
            0:
            raise ValueError("Commission rates cannot be negative")
            prev_threshold = threshold

            if minimum
            <
            0:
            raise ValueError("Minimum commission cannot be negative")

            self.tiers = tiers
            self.minimum = minimum

            def calculate(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            fill_price: "Price",
            ) -> float:
            """Calculate tiered commission based on notional value."""
            notional = fill_quantity * fill_price

            # Find applicable tier
            rate = self.tiers[-1][1] # Default to highest tier
            for threshold, tier_rate in self.tiers:
            if notional
            < threshold:
              rate= tier_rate
              break

              commission= notional
            * rate
            return max(commission, self.minimum)

            def __repr__(self) -> str:
            """String representation."""
            return f"TieredCommission(tiers={self.tiers}, minimum={self.minimum})"


            class MakerTakerCommission(CommissionModel):
            """Maker-taker commission model (exchanges)."""

            def __init__(
            self,
            maker_rate: float = -0.0002, # Maker rebate
            taker_rate: float = 0.0003, # Taker fee
            ):
            """Initialize maker-taker commission model.

            Args:
            maker_rate: Maker fee rate (negative for rebate)
            taker_rate: Taker fee rate
            """
            if taker_rate
            <
            0:
            raise ValueError("Taker rate should be positive")
            if maker_rate > taker_rate:
            raise ValueError("Maker rate should not exceed taker rate")

            self.maker_rate = maker_rate
            self.taker_rate = taker_rate

            def calculate(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            fill_price: "Price",
            ) -> float:
            """Calculate maker-taker commission based on order type."""
            from qengine.execution.order import OrderType

            notional = fill_quantity * fill_price

            # Market orders always take liquidity
            # Limit orders that execute immediately also take liquidity
            # For simplicity, we assume limit orders make liquidity
            rate = self.taker_rate if order.order_type == OrderType.MARKET else self.maker_rate

            commission = notional * rate
            # Negative commission means rebate, but ensure we don't pay too much rebate
            return max(commission, -notional * 0.001) # Cap rebate at 10bps

            def __repr__(self) -> str:
            """String representation."""
            return f"MakerTakerCommission(maker_rate={self.maker_rate}, taker_rate={self.taker_rate})"


            class AssetClassCommission(CommissionModel):
            """Asset class specific commission model."""

            def __init__(
            self,
            equity_rate: float = 0.001, # 10 bps
            futures_per_contract: float = 2.50, # $2.50 per contract
            options_per_contract: float = 0.65, # $0.65 per contract
            forex_rate: float = 0.0002, # 2 bps
            crypto_rate: float = 0.002, # 20 bps
            default_rate: float = 0.001, # 10 bps fallback
            ):
            """Initialize asset class commission model.

            Args:
            equity_rate: Commission rate for equities
            futures_per_contract: Commission per futures contract
            options_per_contract: Commission per options contract
            forex_rate: Commission rate for forex
            crypto_rate: Commission rate for crypto
            default_rate: Default commission rate
            """
            self.equity_rate = equity_rate
            self.futures_per_contract = futures_per_contract
            self.options_per_contract = options_per_contract
            self.forex_rate = forex_rate
            self.crypto_rate = crypto_rate
            self.default_rate = default_rate

            def calculate(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            fill_price: "Price",
            ) -> float:
            """Calculate commission based on asset class."""
            # Determine asset class from symbol or metadata
            asset_class = order.metadata.get("asset_class", "equity")

            if asset_class == "futures":
            # Futures charge per contract
            return fill_quantity * self.futures_per_contract
            if asset_class == "options":
            # Options charge per contract (1 contract = 100 shares usually)
            contracts = fill_quantity / 100
            return contracts * self.options_per_contract
            if asset_class == "forex":
            notional = fill_quantity * fill_price
            return notional * self.forex_rate
            if asset_class == "crypto":
            notional = fill_quantity * fill_price
            return notional * self.crypto_rate
            if asset_class == "equity":
            notional = fill_quantity * fill_price
            return notional * self.equity_rate
            # Default rate for unknown asset classes
            notional = fill_quantity * fill_price
            return notional * self.default_rate

            def __repr__(self) -> str:
            """String representation."""
            return (
            f"AssetClassCommission("
            f"equity_rate={self.equity_rate}, "
            f"futures_per_contract={self.futures_per_contract}, "
            f"options_per_contract={self.options_per_contract}, "
            f"forex_rate={self.forex_rate}, "
            f"crypto_rate={self.crypto_rate})"
            )


            class InteractiveBrokersCommission(CommissionModel):
            """Interactive Brokers tiered commission structure."""

            def __init__(self, tier: str = "fixed"):
            """Initialize IB commission model.

            Args:
            tier: Commission tier ('fixed' or 'tiered')
            """
            if tier not in ["fixed", "tiered"]:
            raise ValueError("Tier must be 'fixed' or 'tiered'")
            self.tier = tier

            def calculate(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            fill_price: "Price",
            ) -> float:
            """Calculate IB commission."""
            if self.tier == "fixed":
            # Fixed pricing: $0.005 per share, $1 minimum, $1% max
            per_share = fill_quantity * 0.005
            min_commission = 1.0
            max_commission = fill_quantity * fill_price * 0.01
            return min(max(per_share, min_commission), max_commission)
            # Tiered pricing (simplified)
            fill_quantity * fill_price
            if fill_quantity<= 300:
            rate = 0.0035 # $0.0035 per share for first 300
            elif fill_quantity<= 3000:
            rate = 0.0025 # $0.0025 per share for next 2700
            else:
            rate = 0.0015 # $0.0015 per share above 3000

            commission = fill_quantity * rate
            return max(commission, 0.35) # $0.35 minimum

            def __repr__(self) -> str:
            """String representation."""
            return f"InteractiveBrokersCommission(tier='{self.tier}')"
        </file>

        <file path="src/qengine/execution/corporate_actions.py">
            """Corporate actions handling for QEngine.

            Corporate actions are events that affect the equity structure of a company,
            requiring adjustments to positions, prices, and orders. This module provides
            a comprehensive framework for handling:

            1. Dividends (cash dividends, special dividends)
            2. Stock splits and stock dividends
            3. Mergers and acquisitions (cash, stock, mixed)
            4. Spin-offs
            5. Symbol changes/reorganizations
            6. Rights offerings

            All actions maintain point-in-time correctness and properly adjust positions,
            orders, and price histories.
            """

            import logging
            from dataclasses import dataclass, field
            from datetime import date
            from typing import TYPE_CHECKING, Optional

            if TYPE_CHECKING:
            from qengine.core.types import AssetId, Price, Quantity
            from qengine.execution.order import Order

            logger = logging.getLogger(__name__)


            @dataclass
            class CorporateAction:
            """Base class for corporate actions."""

            action_id: str
            asset_id: "AssetId"
            ex_date: date # Ex-dividend date (when action takes effect)
            record_date: date | None = None # Record date for eligibility
            payment_date: date | None = None # When payment/distribution occurs
            announcement_date: date | None = None # When action was announced
            metadata: dict[str, str] = field(default_factory=dict)

            def __post_init__(self):
            """Validate dates."""
            if self.record_date and self.ex_date and self.record_date > self.ex_date:
            raise ValueError("Record date must be before ex-date")


            class CashDividend(CorporateAction):
            """Cash dividend corporate action."""

            def __init__(
            self,
            action_id: str,
            asset_id: "AssetId",
            ex_date: date,
            dividend_per_share: float,
            currency: str = "USD",
            record_date: date | None = None,
            payment_date: date | None = None,
            announcement_date: date | None = None,
            metadata: dict[str, str] | None = None,
            ):
            super().__init__(
            action_id=action_id,
            asset_id=asset_id,
            ex_date=ex_date,
            record_date=record_date,
            payment_date=payment_date,
            announcement_date=announcement_date,
            metadata=metadata or {},
            )
            self.dividend_per_share = dividend_per_share
            self.currency = currency

            @property
            def action_type(self) -> str:
            return "DIVIDEND"


            class StockSplit(CorporateAction):
            """Stock split corporate action."""

            def __init__(
            self,
            action_id: str,
            asset_id: "AssetId",
            ex_date: date,
            split_ratio: float,
            record_date: date | None = None,
            payment_date: date | None = None,
            announcement_date: date | None = None,
            metadata: dict[str, str] | None = None,
            ):
            super().__init__(
            action_id=action_id,
            asset_id=asset_id,
            ex_date=ex_date,
            record_date=record_date,
            payment_date=payment_date,
            announcement_date=announcement_date,
            metadata=metadata or {},
            )
            if split_ratio<= 0:
            raise ValueError("Split ratio must be positive")
            self.split_ratio = split_ratio

            @property
            def action_type(self) -> str:
            return "SPLIT"


            class StockDividend(CorporateAction):
            """Stock dividend corporate action."""

            def __init__(
            self,
            action_id: str,
            asset_id: "AssetId",
            ex_date: date,
            dividend_ratio: float,
            record_date: date | None = None,
            payment_date: date | None = None,
            announcement_date: date | None = None,
            metadata: dict[str, str] | None = None,
            ):
            super().__init__(
            action_id=action_id,
            asset_id=asset_id,
            ex_date=ex_date,
            record_date=record_date,
            payment_date=payment_date,
            announcement_date=announcement_date,
            metadata=metadata or {},
            )
            self.dividend_ratio = dividend_ratio

            @property
            def action_type(self) -> str:
            return "STOCK_DIVIDEND"


            class Merger(CorporateAction):
            """Merger/acquisition corporate action."""

            def __init__(
            self,
            action_id: str,
            asset_id: "AssetId",
            ex_date: date,
            target_asset_id: "AssetId",
            cash_consideration: float = 0.0,
            stock_consideration: float = 0.0,
            record_date: date | None = None,
            payment_date: date | None = None,
            announcement_date: date | None = None,
            metadata: dict[str, str] | None = None,
            ):
            super().__init__(
            action_id=action_id,
            asset_id=asset_id,
            ex_date=ex_date,
            record_date=record_date,
            payment_date=payment_date,
            announcement_date=announcement_date,
            metadata=metadata or {},
            )
            if cash_consideration == 0.0 and stock_consideration == 0.0:
            raise ValueError("Must have either cash or stock consideration")
            self.target_asset_id = target_asset_id
            self.cash_consideration = cash_consideration
            self.stock_consideration = stock_consideration

            @property
            def action_type(self) -> str:
            return "MERGER"


            class SpinOff(CorporateAction):
            """Spin-off corporate action."""

            def __init__(
            self,
            action_id: str,
            asset_id: "AssetId",
            ex_date: date,
            new_asset_id: "AssetId",
            distribution_ratio: float,
            record_date: date | None = None,
            payment_date: date | None = None,
            announcement_date: date | None = None,
            metadata: dict[str, str] | None = None,
            ):
            super().__init__(
            action_id=action_id,
            asset_id=asset_id,
            ex_date=ex_date,
            record_date=record_date,
            payment_date=payment_date,
            announcement_date=announcement_date,
            metadata=metadata or {},
            )
            self.new_asset_id = new_asset_id
            self.distribution_ratio = distribution_ratio

            @property
            def action_type(self) -> str:
            return "SPINOFF"


            class SymbolChange(CorporateAction):
            """Symbol change/reorganization."""

            def __init__(
            self,
            action_id: str,
            asset_id: "AssetId",
            ex_date: date,
            new_asset_id: "AssetId",
            conversion_ratio: float = 1.0,
            record_date: date | None = None,
            payment_date: date | None = None,
            announcement_date: date | None = None,
            metadata: dict[str, str] | None = None,
            ):
            super().__init__(
            action_id=action_id,
            asset_id=asset_id,
            ex_date=ex_date,
            record_date=record_date,
            payment_date=payment_date,
            announcement_date=announcement_date,
            metadata=metadata or {},
            )
            self.new_asset_id = new_asset_id
            self.conversion_ratio = conversion_ratio

            @property
            def action_type(self) -> str:
            return "SYMBOL_CHANGE"


            class RightsOffering(CorporateAction):
            """Rights offering corporate action."""

            def __init__(
            self,
            action_id: str,
            asset_id: "AssetId",
            ex_date: date,
            subscription_price: float,
            rights_ratio: float,
            shares_per_right: float,
            expiration_date: date,
            record_date: date | None = None,
            payment_date: date | None = None,
            announcement_date: date | None = None,
            metadata: dict[str, str] | None = None,
            ):
            super().__init__(
            action_id=action_id,
            asset_id=asset_id,
            ex_date=ex_date,
            record_date=record_date,
            payment_date=payment_date,
            announcement_date=announcement_date,
            metadata=metadata or {},
            )
            self.subscription_price = subscription_price
            self.rights_ratio = rights_ratio
            self.shares_per_right = shares_per_right
            self.expiration_date = expiration_date

            @property
            def action_type(self) -> str:
            return "RIGHTS_OFFERING"


            class CorporateActionProcessor:
            """Processes corporate actions and adjusts positions/orders."""

            def __init__(self):
            """Initialize corporate action processor."""
            self.pending_actions: list[CorporateAction] = []
            self.processed_actions: list[CorporateAction] = []

            def add_action(self, action: CorporateAction) -> None:
            """Add a corporate action for processing.

            Args:
            action: Corporate action to add
            """
            self.pending_actions.append(action)
            # Sort by ex-date to ensure proper processing order
            self.pending_actions.sort(key=lambda a: a.ex_date)
            logger.info(
            f"Added corporate action: {action.action_id} ({action.action_type}) for {action.asset_id}",
            )

            def get_pending_actions(self, as_of_date: date) -> list[CorporateAction]:
            """Get actions that should be processed on the given date.

            Args:
            as_of_date: Date to check for pending actions

            Returns:
            List of actions to process
            """
            return [action for action in self.pending_actions if action.ex_date<= as_of_date]

            def process_actions(
            self,
            as_of_date: date,
            positions: dict["AssetId", "Quantity"],
            orders: list["Order"],
            cash: float,
            ) -> tuple[dict["AssetId", "Quantity"], list["Order"], float, list[str]]:
            """Process all pending corporate actions as of the given date.

            Args:
            as_of_date: Date to process actions through
            positions: Current position quantities by asset
            orders: List of open orders
            cash: Current cash balance

            Returns:
            Tuple of (updated_positions, updated_orders, updated_cash, notifications)
            """
            notifications = []
            updated_positions = positions.copy()
            updated_orders = orders.copy()
            updated_cash = cash

            pending = self.get_pending_actions(as_of_date)

            for action in pending:
            logger.info(f"Processing {action.action_type} for {action.asset_id} on {as_of_date}")

            if isinstance(action, CashDividend):
            updated_cash, notification = self._process_cash_dividend(
            action,
            updated_positions,
            updated_cash,
            )
            notifications.append(notification)

            elif isinstance(action, StockSplit):
            updated_positions, updated_orders, notification = self._process_stock_split(
            action,
            updated_positions,
            updated_orders,
            )
            notifications.append(notification)

            elif isinstance(action, StockDividend):
            updated_positions, notification = self._process_stock_dividend(
            action,
            updated_positions,
            )
            notifications.append(notification)

            elif isinstance(action, Merger):
            updated_positions, updated_cash, notification = self._process_merger(
            action,
            updated_positions,
            updated_cash,
            )
            notifications.append(notification)

            elif isinstance(action, SpinOff):
            updated_positions, notification = self._process_spinoff(
            action,
            updated_positions,
            )
            notifications.append(notification)

            elif isinstance(action, SymbolChange):
            updated_positions, updated_orders, notification = self._process_symbol_change(
            action,
            updated_positions,
            updated_orders,
            )
            notifications.append(notification)

            elif isinstance(action, RightsOffering):
            # Rights offerings are complex and typically require user decision
            # For now, just notify
            notifications.append(
            f"Rights offering for {action.asset_id}: "
            f"{action.rights_ratio} rights per share, "
            f"subscription price ${action.subscription_price:.2f}",
            )

            # Move to processed
            self.processed_actions.append(action)
            self.pending_actions.remove(action)

            return updated_positions, updated_orders, updated_cash, notifications

            def _process_cash_dividend(
            self,
            dividend: CashDividend,
            positions: dict["AssetId", "Quantity"],
            cash: float,
            ) -> tuple[float, str]:
            """Process cash dividend.

            Args:
            dividend: Dividend action
            positions: Current positions
            cash: Current cash balance

            Returns:
            Tuple of (updated_cash, notification)
            """
            position = positions.get(dividend.asset_id, 0.0)
            if position > 0:
            dividend_payment = position * dividend.dividend_per_share
            cash += dividend_payment
            notification = (
            f"Dividend received: {position:.0f} shares of {dividend.asset_id} "
            f" ${dividend.dividend_per_share:.4f} = ${dividend_payment:.2f}"
            )
            logger.info(notification)
            return cash, notification

            return cash, f"No position in {dividend.asset_id} for dividend"

            def _process_stock_split(
            self,
            split: StockSplit,
            positions: dict["AssetId", "Quantity"],
            orders: list["Order"],
            ) -> tuple[dict["AssetId", "Quantity"], list["Order"], str]:
            """Process stock split.

            Args:
            split: Stock split action
            positions: Current positions
            orders: Open orders

            Returns:
            Tuple of (updated_positions, updated_orders, notification)
            """
            # Adjust position
            if split.asset_id in positions:
            old_position = positions[split.asset_id]
            positions[split.asset_id] = old_position * split.split_ratio
            notification = (
            f"Stock split: {split.asset_id} {split.split_ratio}:1 split - "
            f"Position adjusted from {old_position:.0f} to {positions[split.asset_id]:.0f} shares"
            )
            else:
            notification = f"No position in {split.asset_id} for stock split"

            # Adjust open orders
            updated_orders = []
            for order in orders:
            if order.asset_id == split.asset_id:
            # Adjust quantity and prices
            order.quantity *= split.split_ratio
            # Note: remaining_quantity is computed from quantity - filled_quantity
            if order.limit_price is not None:
            order.limit_price /= split.split_ratio
            if order.stop_price is not None:
            order.stop_price /= split.split_ratio

            order.metadata["corporate_action"] = (
            f"Split {split.split_ratio}:1 on {split.ex_date}"
            )
            updated_orders.append(order)

            logger.info(notification)
            return positions, updated_orders, notification

            def _process_stock_dividend(
            self,
            stock_div: StockDividend,
            positions: dict["AssetId", "Quantity"],
            ) -> tuple[dict["AssetId", "Quantity"], str]:
            """Process stock dividend.

            Args:
            stock_div: Stock dividend action
            positions: Current positions

            Returns:
            Tuple of (updated_positions, notification)
            """
            if stock_div.asset_id in positions:
            old_position = positions[stock_div.asset_id]
            additional_shares = old_position * stock_div.dividend_ratio
            positions[stock_div.asset_id] += additional_shares

            notification = (
            f"Stock dividend: {stock_div.asset_id} "
            f"{stock_div.dividend_ratio * 100:.1f}% stock dividend - "
            f"Received {additional_shares:.0f} additional shares"
            )
            else:
            notification = f"No position in {stock_div.asset_id} for stock dividend"

            logger.info(notification)
            return positions, notification

            def _process_merger(
            self,
            merger: Merger,
            positions: dict["AssetId", "Quantity"],
            cash: float,
            ) -> tuple[dict["AssetId", "Quantity"], float, str]:
            """Process merger/acquisition.

            Args:
            merger: Merger action
            positions: Current positions
            cash: Current cash balance

            Returns:
            Tuple of (updated_positions, updated_cash, notification)
            """
            if merger.asset_id not in positions or positions[merger.asset_id]<= 0:
            return positions, cash, f"No position in {merger.asset_id} for merger"

            old_shares = positions[merger.asset_id]

            # Remove old position
            del positions[merger.asset_id]

            # Add cash consideration
            cash_received = old_shares * merger.cash_consideration
            cash += cash_received

            # Add stock consideration
            if merger.stock_consideration > 0:
            new_shares = old_shares * merger.stock_consideration
            if merger.target_asset_id in positions:
            positions[merger.target_asset_id] += new_shares
            else:
            positions[merger.target_asset_id] = new_shares

            notification = (
            f"Merger: {merger.asset_id}  {merger.target_asset_id} - "
            f"{old_shares:.0f} shares converted to "
            )

            if cash_received > 0 and merger.stock_consideration > 0:
            notification += f"${cash_received:.2f} cash + {old_shares * merger.stock_consideration:.0f}
            {merger.target_asset_id} shares"
            elif cash_received > 0:
            notification += f"${cash_received:.2f} cash"
            else:
            notification += (
            f"{old_shares * merger.stock_consideration:.0f} {merger.target_asset_id} shares"
            )

            logger.info(notification)
            return positions, cash, notification

            def _process_spinoff(
            self,
            spinoff: SpinOff,
            positions: dict["AssetId", "Quantity"],
            ) -> tuple[dict["AssetId", "Quantity"], str]:
            """Process spin-off.

            Args:
            spinoff: Spin-off action
            positions: Current positions

            Returns:
            Tuple of (updated_positions, notification)
            """
            if spinoff.asset_id not in positions or positions[spinoff.asset_id]<= 0:
            return positions, f"No position in {spinoff.asset_id} for spin-off"

            parent_shares = positions[spinoff.asset_id]
            spinoff_shares = parent_shares * spinoff.distribution_ratio

            # Add spin-off shares
            if spinoff.new_asset_id in positions:
            positions[spinoff.new_asset_id] += spinoff_shares
            else:
            positions[spinoff.new_asset_id] = spinoff_shares

            notification = (
            f"Spin-off: {spinoff.asset_id} distributed {spinoff_shares:.0f} shares of "
            f"{spinoff.new_asset_id} ({spinoff.distribution_ratio} per share)"
            )

            logger.info(notification)
            return positions, notification

            def _process_symbol_change(
            self,
            symbol_change: SymbolChange,
            positions: dict["AssetId", "Quantity"],
            orders: list["Order"],
            ) -> tuple[dict["AssetId", "Quantity"], list["Order"], str]:
            """Process symbol change.

            Args:
            symbol_change: Symbol change action
            positions: Current positions
            orders: Open orders

            Returns:
            Tuple of (updated_positions, updated_orders, notification)
            """
            # Update position
            if symbol_change.asset_id in positions:
            old_shares = positions[symbol_change.asset_id]
            new_shares = old_shares * symbol_change.conversion_ratio

            del positions[symbol_change.asset_id]
            positions[symbol_change.new_asset_id] = new_shares

            notification = (
            f"Symbol change: {symbol_change.asset_id}  {symbol_change.new_asset_id} "
            f"({old_shares:.0f}  {new_shares:.0f} shares)"
            )
            else:
            notification = f"Symbol change: {symbol_change.asset_id}  {symbol_change.new_asset_id} (no position)"

            # Update orders
            for order in orders:
            if order.asset_id == symbol_change.asset_id:
            order.asset_id = symbol_change.new_asset_id
            order.quantity *= symbol_change.conversion_ratio
            # Note: remaining_quantity is computed from quantity - filled_quantity

            if symbol_change.conversion_ratio != 1.0:
            if order.limit_price is not None:
            order.limit_price /= symbol_change.conversion_ratio
            if order.stop_price is not None:
            order.stop_price /= symbol_change.conversion_ratio

            order.metadata["corporate_action"] = f"Symbol change on {symbol_change.ex_date}"

            logger.info(notification)
            return positions, orders, notification

            def adjust_price_for_actions(
            self,
            asset_id: "AssetId",
            price: "Price",
            as_of_date: date,
            ) -> "Price":
            """Adjust historical price for corporate actions.

            This is used to maintain price continuity in backtesting by adjusting
            historical prices for splits, dividends, etc.

            Args:
            asset_id: Asset to adjust price for
            price: Original price
            as_of_date: Date the price is from

            Returns:
            Adjusted price
            """
            adjusted_price = price

            # Apply adjustments for all actions after this date
            for action in self.processed_actions:
            if action.asset_id != asset_id or action.ex_date<= as_of_date:
            continue

            if isinstance(action, StockSplit):
            # Adjust price downward for future splits
            adjusted_price /= action.split_ratio

            elif isinstance(action, CashDividend):
            # Adjust price downward for future dividends
            adjusted_price -= action.dividend_per_share

            elif isinstance(action, StockDividend):
            # Adjust price for stock dividend
            adjusted_price /= 1 + action.dividend_ratio

            return max(adjusted_price, 0.01) # Minimum price floor

            def get_processed_actions(
            self,
            asset_id: Optional["AssetId"] = None,
            start_date: date | None = None,
            end_date: date | None = None,
            ) -> list[CorporateAction]:
            """Get processed corporate actions with optional filtering.

            Args:
            asset_id: Filter by asset ID
            start_date: Filter by start date (inclusive)
            end_date: Filter by end date (inclusive)

            Returns:
            List of matching corporate actions
            """
            filtered_actions = self.processed_actions

            if asset_id:
            filtered_actions = [a for a in filtered_actions if a.asset_id == asset_id]

            if start_date:
            filtered_actions = [a for a in filtered_actions if a.ex_date >= start_date]

            if end_date:
            filtered_actions = [a for a in filtered_actions if a.ex_date<= end_date]

            return filtered_actions

            def reset(self) -> None:
            """Reset processor state."""
            self.pending_actions.clear()
            self.processed_actions.clear()
            logger.info("Corporate action processor reset")


            class CorporateActionDataProvider:
            """Provides corporate action data from various sources."""

            def __init__(self):
            """Initialize data provider."""
            self.actions: dict[str, CorporateAction] = {}

            def load_from_csv(self, file_path: str) -> None:
            """Load corporate actions from CSV file.

            Expected CSV format:
            action_id,asset_id,action_type,ex_date,dividend_per_share,split_ratio,...

            Args:
            file_path: Path to CSV file
            """
            import pandas as pd

            df = pd.read_csv(file_path)

            for _, row in df.iterrows():
            action = self._create_action_from_row(row)
            if action:
            self.actions[action.action_id] = action
            logger.info(f"Loaded corporate action: {action.action_id}")

            def _create_action_from_row(self, row) -> CorporateAction | None:
            """Create corporate action from CSV row."""
            try:
            action_type = row["action_type"].upper()
            import pandas as pd

            ex_date = pd.to_datetime(row["ex_date"]).date()

            base_args = {
            "action_id": row["action_id"],
            "asset_id": row["asset_id"],
            "ex_date": ex_date,
            "record_date": pd.to_datetime(row.get("record_date")).date()
            if pd.notna(row.get("record_date"))
            else None,
            "payment_date": pd.to_datetime(row.get("payment_date")).date()
            if pd.notna(row.get("payment_date"))
            else None,
            }

            if action_type == "DIVIDEND":
            return CashDividend(
            dividend_per_share=float(row["dividend_per_share"]),
            **base_args,
            )
            if action_type == "SPLIT":
            return StockSplit(
            split_ratio=float(row["split_ratio"]),
            **base_args,
            )
            if action_type == "MERGER":
            return Merger(
            target_asset_id=row["target_asset_id"],
            cash_consideration=float(row.get("cash_consideration", 0)),
            stock_consideration=float(row.get("stock_consideration", 0)),
            **base_args,
            )
            if action_type == "SPINOFF":
            return SpinOff(
            new_asset_id=row["new_asset_id"],
            distribution_ratio=float(row["distribution_ratio"]),
            **base_args,
            )
            if action_type == "SYMBOL_CHANGE":
            return SymbolChange(
            new_asset_id=row["new_asset_id"],
            conversion_ratio=float(row.get("conversion_ratio", 1.0)),
            **base_args,
            )
            logger.warning(f"Unknown action type: {action_type}")
            return None

            except Exception as e:
            logger.error(f"Error creating action from row: {e}")
            return None

            def get_actions_for_asset(
            self,
            asset_id: "AssetId",
            start_date: date | None = None,
            end_date: date | None = None,
            ) -> list[CorporateAction]:
            """Get actions for a specific asset.

            Args:
            asset_id: Asset to get actions for
            start_date: Optional start date filter
            end_date: Optional end date filter

            Returns:
            List of corporate actions
            """
            actions = [action for action in self.actions.values() if action.asset_id == asset_id]

            if start_date:
            actions = [a for a in actions if a.ex_date >= start_date]

            if end_date:
            actions = [a for a in actions if a.ex_date<= end_date]

            return sorted(actions, key=lambda a: a.ex_date)
        </file>

        <file path="src/qengine/execution/market_impact.py">
            """Market impact models for realistic price simulation.

            Market impact differs from slippage in that it represents the actual change
            in market prices due to trading activity, affecting all subsequent orders.
            """

            import math
            from abc import ABC, abstractmethod
            from dataclasses import dataclass
            from datetime import datetime, timedelta
            from typing import TYPE_CHECKING, Optional

            if TYPE_CHECKING:
            from qengine.core.types import AssetId, Price, Quantity
            from qengine.execution.order import Order


            @dataclass
            class ImpactState:
            """Tracks market impact state for an asset."""

            permanent_impact: float = 0.0 # Permanent price shift
            temporary_impact: float = 0.0 # Temporary price displacement
            last_update: datetime | None = None
            volume_traded: float = 0.0 # Recent volume for impact calculation

            def get_total_impact(self) -> float:
            """Get total current impact."""
            return self.permanent_impact + self.temporary_impact

            def decay_temporary_impact(self, decay_rate: float, time_elapsed: float) -> None:
            """Decay temporary impact over time."""
            if time_elapsed > 0:
            # Exponential decay
            self.temporary_impact *= math.exp(-decay_rate * time_elapsed)
            # Clean up near-zero values
            if abs(self.temporary_impact)
            <
            1e-10:
            self.temporary_impact = 0.0


            class MarketImpactModel(ABC):
            """Abstract base class for market impact models."""

            def __init__(self):
            """Initialize impact model."""
            # Track impact state per asset
            self.impact_states: dict[AssetId, ImpactState] = {}

            @abstractmethod
            def calculate_impact(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            market_price: "Price",
            timestamp: datetime,
            ) -> tuple[float, float]:
            """Calculate permanent and temporary market impact.

            Args:
            order: The order being filled
            fill_quantity: Quantity being filled
            market_price: Current market price
            timestamp: Time of the fill

            Returns:
            Tuple of (permanent_impact, temporary_impact) as price changes
            """

            def update_market_state(
            self,
            asset_id: "AssetId",
            permanent_impact: float,
            temporary_impact: float,
            timestamp: datetime,
            ) -> None:
            """Update the market state with new impact.

            Args:
            asset_id: Asset identifier
            permanent_impact: Permanent price change
            temporary_impact: Temporary price displacement
            timestamp: Time of the update
            """
            if asset_id not in self.impact_states:
            self.impact_states[asset_id] = ImpactState()

            state = self.impact_states[asset_id]

            # Apply time decay to existing temporary impact
            if state.last_update is not None:
            time_elapsed = (timestamp - state.last_update).total_seconds()
            self.apply_decay(asset_id, time_elapsed)

            # Add new impacts
            state.permanent_impact += permanent_impact
            state.temporary_impact += temporary_impact
            state.last_update = timestamp

            def apply_decay(self, asset_id: "AssetId", time_elapsed: float) -> None:
            """Apply time decay to temporary impact.

            Args:
            asset_id: Asset identifier
            time_elapsed: Time elapsed in seconds
            """
            if asset_id in self.impact_states:
            # Default decay rate (can be overridden)
            decay_rate = getattr(self, "decay_rate", 0.1)
            self.impact_states[asset_id].decay_temporary_impact(decay_rate, time_elapsed)

            def get_current_impact(
            self,
            asset_id: "AssetId",
            timestamp: datetime | None = None,
            ) -> float:
            """Get current total market impact for an asset.

            Args:
            asset_id: Asset identifier
            timestamp: Current time for decay calculation

            Returns:
            Total price impact (permanent + temporary)
            """
            if asset_id not in self.impact_states:
            return 0.0

            state = self.impact_states[asset_id]

            # Apply decay if timestamp provided
            if timestamp and state.last_update:
            time_elapsed = (timestamp - state.last_update).total_seconds()
            self.apply_decay(asset_id, time_elapsed)

            return state.get_total_impact()

            def reset(self) -> None:
            """Reset all impact states."""
            self.impact_states.clear()


            class NoMarketImpact(MarketImpactModel):
            """No market impact model for testing."""

            def calculate_impact(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            market_price: "Price",
            timestamp: datetime,
            ) -> tuple[float, float]:
            """Calculate zero market impact."""
            return 0.0, 0.0


            class LinearMarketImpact(MarketImpactModel):
            """Linear market impact model.

            Impact is proportional to order size relative to average daily volume.
            """

            def __init__(
            self,
            permanent_impact_factor: float = 0.1,
            temporary_impact_factor: float = 0.5,
            avg_daily_volume: float = 1_000_000,
            decay_rate: float = 0.1,
            ):
            """Initialize linear impact model.

            Args:
            permanent_impact_factor: Permanent impact per unit of volume fraction
            temporary_impact_factor: Temporary impact per unit of volume fraction
            avg_daily_volume: Average daily volume for normalization
            decay_rate: Decay rate for temporary impact (per second)
            """
            super().__init__()
            self.permanent_impact_factor = permanent_impact_factor
            self.temporary_impact_factor = temporary_impact_factor
            self.avg_daily_volume = avg_daily_volume
            self.decay_rate = decay_rate

            def calculate_impact(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            market_price: "Price",
            timestamp: datetime,
            ) -> tuple[float, float]:
            """Calculate linear market impact."""
            # Volume fraction (what percentage of ADV is this trade?)
            volume_fraction = fill_quantity / self.avg_daily_volume

            # Linear impact proportional to volume fraction
            permanent_impact = market_price * self.permanent_impact_factor * volume_fraction
            temporary_impact = market_price * self.temporary_impact_factor * volume_fraction

            # Buy orders push price up, sell orders push price down
            from qengine.execution.order import OrderSide

            if order.side == OrderSide.SELL:
            permanent_impact = -permanent_impact
            temporary_impact = -temporary_impact

            return permanent_impact, temporary_impact


            class AlmgrenChrissImpact(MarketImpactModel):
            """Almgren-Chriss market impact model.

            Sophisticated model with square-root permanent impact and linear temporary impact.
            Based on "Optimal Execution of Portfolio Transactions" (2001).
            """

            def __init__(
            self,
            permanent_impact_const: float = 0.01,
            temporary_impact_const: float = 0.1,
            daily_volatility: float = 0.02,
            avg_daily_volume: float = 1_000_000,
            decay_rate: float = 0.05,
            ):
            """Initialize Almgren-Chriss model.

            Args:
            permanent_impact_const: Permanent impact constant (gamma)
            temporary_impact_const: Temporary impact constant (eta)
            daily_volatility: Daily return volatility
            avg_daily_volume: Average daily volume
            decay_rate: Decay rate for temporary impact
            """
            super().__init__()
            self.permanent_impact_const = permanent_impact_const
            self.temporary_impact_const = temporary_impact_const
            self.daily_volatility = daily_volatility
            self.avg_daily_volume = avg_daily_volume
            self.decay_rate = decay_rate

            def calculate_impact(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            market_price: "Price",
            timestamp: datetime,
            ) -> tuple[float, float]:
            """Calculate Almgren-Chriss market impact."""
            # Normalized volume (fraction of ADV)
            volume_fraction = fill_quantity / self.avg_daily_volume

            # Permanent impact: square-root of volume fraction
            # g(v) = gamma * sign(v) * |v|^0.5
            permanent_impact = (
            self.permanent_impact_const
            * self.daily_volatility
            * market_price
            * math.sqrt(volume_fraction)
            )

            # Temporary impact: linear in trading rate
            # h(v) = eta * v
            temporary_impact = (
            self.temporary_impact_const * self.daily_volatility * market_price * volume_fraction
            )

            # Adjust sign based on order side
            from qengine.execution.order import OrderSide

            if order.side == OrderSide.SELL:
            permanent_impact = -permanent_impact
            temporary_impact = -temporary_impact

            return permanent_impact, temporary_impact


            class PropagatorImpact(MarketImpactModel):
            """Propagator model for market impact.

            Based on Bouchaud et al. model where impact propagates and decays
            according to a power law kernel.
            """

            def __init__(
            self,
            impact_coefficient: float = 0.1,
            propagator_exponent: float = 0.5,
            decay_exponent: float = 0.7,
            avg_daily_volume: float = 1_000_000,
            ):
            """Initialize propagator model.

            Args:
            impact_coefficient: Base impact coefficient
            propagator_exponent: Exponent for volume impact (typically 0.5)
            decay_exponent: Exponent for time decay (typically 0.5-0.7)
            avg_daily_volume: Average daily volume
            """
            super().__init__()
            self.impact_coefficient = impact_coefficient
            self.propagator_exponent = propagator_exponent
            self.decay_exponent = decay_exponent
            self.avg_daily_volume = avg_daily_volume

            # Track order history for propagation
            self.order_history: list[tuple[datetime, float, float]] = []

            def calculate_impact(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            market_price: "Price",
            timestamp: datetime,
            ) -> tuple[float, float]:
            """Calculate propagator market impact."""
            # Normalized volume
            volume_fraction = fill_quantity / self.avg_daily_volume

            # Instantaneous impact: power law in volume
            instant_impact = (
            self.impact_coefficient * market_price * (volume_fraction**self.propagator_exponent)
            )

            # Calculate propagated impact from historical orders
            propagated_impact = 0.0
            cutoff_time = timestamp - timedelta(hours=1) # Only consider recent history

            for hist_time, hist_volume, hist_price in self.order_history[-100:]: # Limit history
            if hist_time< cutoff_time:
                          continue

                          time_diff=(timestamp - hist_time).total_seconds()
            if time_diff > 0:
            # Power law decay
            decay_factor = (1 + time_diff) ** (-self.decay_exponent)
            propagated_impact += (
            self.impact_coefficient
            * hist_price
            * (abs(hist_volume) / self.avg_daily_volume) ** self.propagator_exponent
            * decay_factor
            * (1 if hist_volume > 0 else -1)
            )

            # Store this order for future propagation
            from qengine.execution.order import OrderSide

            signed_volume = fill_quantity if order.side == OrderSide.BUY else -fill_quantity
            self.order_history.append((timestamp, signed_volume, market_price))

            # Clean old history
            if len(self.order_history) > 1000:
            self.order_history = self.order_history[-500:]

            # Adjust sign
            if order.side == OrderSide.SELL:
            instant_impact = -instant_impact

            # Split into permanent and temporary
            # Propagator model typically has mostly temporary impact
            permanent_impact = instant_impact * 0.2
            temporary_impact = instant_impact * 0.8 + propagated_impact

            return permanent_impact, temporary_impact

            def reset(self) -> None:
            """Reset impact states and history."""
            super().reset()
            self.order_history.clear()


            class IntraDayMomentum(MarketImpactModel):
            """Intraday momentum impact model.

            Models the tendency for large trades to create momentum that
            attracts further trading in the same direction.
            """

            def __init__(
            self,
            base_impact: float = 0.05,
            momentum_factor: float = 0.3,
            momentum_decay: float = 0.2,
            avg_daily_volume: float = 1_000_000,
            ):
            """Initialize momentum impact model.

            Args:
            base_impact: Base impact coefficient
            momentum_factor: How much momentum affects impact
            momentum_decay: Decay rate for momentum
            avg_daily_volume: Average daily volume
            """
            super().__init__()
            self.base_impact = base_impact
            self.momentum_factor = momentum_factor
            self.momentum_decay = momentum_decay
            self.avg_daily_volume = avg_daily_volume

            # Track momentum state per asset
            self.momentum_states: dict[AssetId, float] = {}

            def calculate_impact(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            market_price: "Price",
            timestamp: datetime,
            ) -> tuple[float, float]:
            """Calculate momentum-based impact."""
            asset_id = order.asset_id
            volume_fraction = fill_quantity / self.avg_daily_volume

            # Get current momentum
            momentum = self.momentum_states.get(asset_id, 0.0)

            # Base impact
            base_impact_value = self.base_impact * market_price * volume_fraction

            # Momentum enhancement (same-direction trades have larger impact)
            from qengine.execution.order import OrderSide

            trade_direction = 1.0 if order.side == OrderSide.BUY else -1.0

            momentum_enhancement = 1.0 + self.momentum_factor * abs(momentum)
            if momentum * trade_direction > 0: # Same direction as momentum
            impact = base_impact_value * momentum_enhancement
            else: # Against momentum
            impact = base_impact_value / momentum_enhancement

            # Update momentum (exponential moving average)
            new_momentum = (
            momentum * (1 - self.momentum_decay)
            + trade_direction * volume_fraction * self.momentum_decay
            )
            self.momentum_states[asset_id] = new_momentum

            # Apply direction
            if order.side == OrderSide.SELL:
            impact = -impact

            # Split impact (momentum creates more temporary impact)
            permanent_impact = impact * 0.3
            temporary_impact = impact * 0.7

            return permanent_impact, temporary_impact

            def reset(self) -> None:
            """Reset all states."""
            super().reset()
            self.momentum_states.clear()


            class ObizhaevWangImpact(MarketImpactModel):
            """Obizhaev-Wang market impact model.

            Models impact based on order book dynamics and trade informativeness.
            """

            def __init__(
            self,
            price_impact_const: float = 0.1,
            information_share: float = 0.3,
            book_depth: float = 100_000,
            resilience_rate: float = 0.5,
            ):
            """Initialize Obizhaev-Wang model.

            Args:
            price_impact_const: Price impact constant (lambda)
            information_share: Share of informed trading (alpha)
            book_depth: Typical order book depth
            resilience_rate: Rate of order book resilience
            """
            super().__init__()
            self.price_impact_const = price_impact_const
            self.information_share = information_share
            self.book_depth = book_depth
            self.resilience_rate = resilience_rate
            self.decay_rate = resilience_rate # For base class decay

            def calculate_impact(
            self,
            order: "Order",
            fill_quantity: "Quantity",
            market_price: "Price",
            timestamp: datetime,
            ) -> tuple[float, float]:
            """Calculate Obizhaev-Wang impact."""
            # Normalized order size relative to book depth
            size_ratio = fill_quantity / self.book_depth

            # Information-based permanent impact
            permanent_impact = (
            self.information_share * self.price_impact_const * market_price * size_ratio
            )

            # Mechanical temporary impact from eating through book
            temporary_impact = (
            (1 - self.information_share) * self.price_impact_const * market_price * size_ratio
            )

            # Adjust for order side
            from qengine.execution.order import OrderSide

            if order.side == OrderSide.SELL:
            permanent_impact = -permanent_impact
            temporary_impact = -temporary_impact

            return permanent_impact, temporary_impact
        </file>

        <file path="src/qengine/execution/order.py">
            """Order management for QEngine."""

            import uuid
            from dataclasses import dataclass, field
            from datetime import datetime
            from enum import Enum
            from typing import Any

            from qengine.core.types import (
            AssetId,
            OrderId,
            OrderSide,
            OrderStatus,
            OrderType,
            Price,
            Quantity,
            TimeInForce,
            )


            class OrderState(Enum):
            """Order lifecycle states."""

            PENDING = "pending" # Created but not yet submitted
            SUBMITTED = "submitted" # Sent to broker
            ACKNOWLEDGED = "acknowledged" # Broker confirmed receipt
            PARTIALLY_FILLED = "partially_filled" # Some quantity filled
            FILLED = "filled" # Completely filled
            CANCELLED = "cancelled" # Cancelled by user
            REJECTED = "rejected" # Rejected by broker
            EXPIRED = "expired" # Expired due to time constraint


            @dataclass
            class Order:
            """Represents a trading order."""

            # Core identifiers
            order_id: OrderId = field(default_factory=lambda: str(uuid.uuid4()))
            asset_id: AssetId = ""

            # Order specifications
            order_type: OrderType = OrderType.MARKET
            side: OrderSide = OrderSide.BUY
            quantity: Quantity = 0.0

            # Price constraints
            limit_price: Price | None = None
            stop_price: Price | None = None

            # Advanced order type parameters
            trail_amount: Price | None = None # For trailing stops (absolute)
            trail_percent: float | None = None # For trailing stops (percentage)
            trailing_stop_price: Price | None = None # Current trailing stop level

            # Bracket order parameters
            profit_target: Price | None = None # Take profit level
            stop_loss: Price | None = None # Stop loss level

            # Time constraints
            time_in_force: TimeInForce = TimeInForce.DAY
            expire_time: datetime | None = None

            # State tracking
            state: OrderState = OrderState.PENDING
            status: OrderStatus = OrderStatus.CREATED

            # Timestamps
            created_time: datetime = field(default_factory=datetime.now)
            submitted_time: datetime | None = None
            acknowledged_time: datetime | None = None
            filled_time: datetime | None = None
            cancelled_time: datetime | None = None

            # Fill information
            filled_quantity: Quantity = 0.0
            average_fill_price: Price | None = None
            fill_count: int = 0

            # Costs
            commission: float = 0.0
            slippage: float = 0.0

            # Relationships
            parent_order_id: OrderId | None = None
            child_order_ids: list[OrderId] = field(default_factory=list)

            # Metadata
            metadata: dict[str, Any] = field(default_factory=dict)

            def __post_init__(self):
            """Validate order on creation."""
            if self.order_type == OrderType.LIMIT and self.limit_price is None:
            raise ValueError("Limit orders must have a limit price")
            if self.order_type == OrderType.STOP and self.stop_price is None:
            raise ValueError("Stop orders must have a stop price")
            if self.order_type == OrderType.STOP_LIMIT:
            if self.stop_price is None or self.limit_price is None:
            raise ValueError("Stop-limit orders must have both stop and limit prices")
            if self.order_type == OrderType.TRAILING_STOP:
            if self.trail_amount is None and self.trail_percent is None:
            raise ValueError("Trailing stop orders must have trail_amount or trail_percent")
            if self.order_type == OrderType.BRACKET:
            if self.profit_target is None or self.stop_loss is None:
            raise ValueError("Bracket orders must have both profit_target and stop_loss")
            if self.quantity<= 0:
            raise ValueError("Order quantity must be positive")

            @property
            def is_buy(self) -> bool:
            """Check if this is a buy order."""
            return self.side == OrderSide.BUY

            @property
            def is_sell(self) -> bool:
            """Check if this is a sell order."""
            return self.side == OrderSide.SELL

            @property
            def is_filled(self) -> bool:
            """Check if order is completely filled."""
            return self.state == OrderState.FILLED

            @property
            def is_partially_filled(self) -> bool:
            """Check if order is partially filled."""
            return self.state == OrderState.PARTIALLY_FILLED

            @property
            def is_active(self) -> bool:
            """Check if order is still active."""
            return self.state in [
            OrderState.PENDING,
            OrderState.SUBMITTED,
            OrderState.ACKNOWLEDGED,
            OrderState.PARTIALLY_FILLED,
            ]

            @property
            def is_terminal(self) -> bool:
            """Check if order is in a terminal state."""
            return self.state in [
            OrderState.FILLED,
            OrderState.CANCELLED,
            OrderState.REJECTED,
            OrderState.EXPIRED,
            ]

            @property
            def remaining_quantity(self) -> Quantity:
            """Get remaining quantity to fill."""
            return self.quantity - self.filled_quantity

            @property
            def fill_ratio(self) -> float:
            """Get the ratio of filled quantity to total."""
            if self.quantity == 0:
            return 0.0
            return self.filled_quantity / self.quantity

            def can_fill(self, price: Price) -> bool:
            """
            Check if order can be filled at given price.

            Args:
            price: Current market price

            Returns:
            True if order can be filled
            """
            if not self.is_active:
            return False

            if self.order_type == OrderType.MARKET:
            return True

            if self.order_type == OrderType.LIMIT:
            if self.limit_price is None:
            return False
            if self.is_buy:
            return price<= self.limit_price
            return price >= self.limit_price

            if self.order_type == OrderType.STOP:
            if self.stop_price is None:
            return False
            # Stop orders trigger when price crosses the stop level
            if self.is_buy:
            return price >= self.stop_price
            return price<= self.stop_price

            if self.order_type == OrderType.STOP_LIMIT:
            # For simplicity, assume stop has been triggered if we get here
            # The broker will handle the trigger logic
            if self.limit_price is None:
            return False
            if self.is_buy:
            return price<= self.limit_price
            return price >= self.limit_price

            if self.order_type == OrderType.TRAILING_STOP:
            if self.trailing_stop_price is None:
            return False
            # Trailing stop triggers when price crosses the trailing level
            if self.is_buy:
            return price >= self.trailing_stop_price
            return price<= self.trailing_stop_price

            if self.order_type == OrderType.BRACKET:
            # Bracket orders fill based on their entry criteria (limit_price if set)
            if self.limit_price is not None:
            # Act like a limit order for entry
            if self.is_buy:
            return price<= self.limit_price
            return price >= self.limit_price
            # Act like a market order for entry
            return True

            # OCO and other special orders
            return False

            def update_fill(
            self,
            fill_quantity: Quantity,
            fill_price: Price,
            commission: float = 0.0,
            timestamp: datetime | None = None,
            ) -> None:
            """
            Update order with fill information.

            Args:
            fill_quantity: Quantity filled
            fill_price: Price of fill
            commission: Commission charged
            timestamp: Time of fill
            """
            if fill_quantity<= 0:
            raise ValueError("Fill quantity must be positive")

            if fill_quantity > self.remaining_quantity:
            raise ValueError(
            f"Fill quantity {fill_quantity} exceeds remaining {self.remaining_quantity}",
            )

            # Update fill tracking
            if self.average_fill_price is None:
            self.average_fill_price = fill_price
            else:
            # Calculate weighted average
            total_value = (
            self.filled_quantity * self.average_fill_price + fill_quantity * fill_price
            )
            self.average_fill_price = total_value / (self.filled_quantity + fill_quantity)

            self.filled_quantity += fill_quantity
            self.fill_count += 1
            self.commission += commission

            # Update state
            if self.filled_quantity >= self.quantity:
            self.state = OrderState.FILLED
            self.status = OrderStatus.FILLED
            self.filled_time = timestamp or datetime.now()
            else:
            self.state = OrderState.PARTIALLY_FILLED
            self.status = OrderStatus.PARTIALLY_FILLED

            def cancel(self, timestamp: datetime | None = None) -> None:
            """Cancel the order."""
            if self.is_terminal:
            raise ValueError(f"Cannot cancel order in state {self.state}")

            self.state = OrderState.CANCELLED
            self.status = OrderStatus.CANCELED
            self.cancelled_time = timestamp or datetime.now()

            def reject(self, reason: str = "", timestamp: datetime | None = None) -> None:
            """Reject the order."""
            self.state = OrderState.REJECTED
            self.status = OrderStatus.REJECTED
            self.metadata["rejection_reason"] = reason
            self.cancelled_time = timestamp or datetime.now()

            def update_trailing_stop(self, current_price: Price) -> bool:
            """
            Update trailing stop price based on current market price.

            Args:
            current_price: Current market price

            Returns:
            True if trailing stop was updated, False otherwise
            """
            if self.order_type != OrderType.TRAILING_STOP:
            return False

            # Initialize trailing stop price if not set
            if self.trailing_stop_price is None:
            if self.trail_amount is not None:
            if self.is_buy:
            self.trailing_stop_price = current_price + self.trail_amount
            else:
            self.trailing_stop_price = current_price - self.trail_amount
            elif self.trail_percent is not None:
            trail_amount = current_price * (self.trail_percent / 100.0)
            if self.is_buy:
            self.trailing_stop_price = current_price + trail_amount
            else:
            self.trailing_stop_price = current_price - trail_amount
            return True

            # Update trailing stop if price moves favorably
            updated = False

            if self.trail_amount is not None:
            # Absolute trailing amount
            if self.is_buy:
            # For buy stops, trail up when price falls
            new_stop = current_price + self.trail_amount
            if new_stop
            < self.trailing_stop_price:
              self.trailing_stop_price= new_stop
              updated= True
              else:
            # For sell stops, trail down when price rises
            new_stop = current_price - self.trail_amount
            if new_stop > self.trailing_stop_price:
            self.trailing_stop_price = new_stop
            updated = True

            elif self.trail_percent is not None:
            # Percentage trailing amount
            trail_amount = current_price * (self.trail_percent / 100.0)
            if self.is_buy:
            new_stop = current_price + trail_amount
            if new_stop
            < self.trailing_stop_price:
              self.trailing_stop_price= new_stop
              updated= True
              else:
              new_stop= current_price
            - trail_amount
            if new_stop > self.trailing_stop_price:
            self.trailing_stop_price = new_stop
            updated = True

            return updated

            def __repr__(self) -> str:
            return (
            f"Order(id={self.order_id[:8]}, {self.side.value} {self.quantity} "
            f"{self.asset_id} @ {self.order_type.value}, state={self.state.value})"
            )
        </file>

        <file path="src/qengine/execution/slippage.py">
            """Slippage models for QEngine."""

            from abc import ABC, abstractmethod
            from typing import Optional

            from qengine.core.types import Price, Quantity
            from qengine.execution.order import Order


            class SlippageModel(ABC):
            """Abstract base class for slippage models.

            Slippage models determine the actual fill price based on order characteristics
            and market conditions.
            """

            @abstractmethod
            def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
            """Calculate the fill price with slippage.

            Args:
            order: The order being filled
            market_price: Current market price

            Returns:
            The fill price including slippage
            """

            @abstractmethod
            def calculate_slippage_cost(
            self,
            order: Order,
            fill_quantity: Quantity,
            market_price: Price,
            fill_price: Price,
            ) -> float:
            """Calculate the slippage cost in currency terms.

            Args:
            order: The order being filled
            fill_quantity: Quantity being filled
            market_price: Current market price
            fill_price: Actual fill price

            Returns:
            Slippage cost in currency terms
            """


            class NoSlippage(SlippageModel):
            """No slippage - all orders fill at market price.

            Primarily used for testing or ideal conditions.
            """

            def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
            """Fill at market price."""
            return market_price

            def calculate_slippage_cost(
            self,
            order: Order,
            fill_quantity: Quantity,
            market_price: Price,
            fill_price: Price,
            ) -> float:
            """No slippage cost."""
            return 0.0


            class FixedSlippage(SlippageModel):
            """Fixed spread slippage model.

            Assumes a fixed spread for all orders.
            Buy orders fill at ask (market + spread/2)
            Sell orders fill at bid (market - spread/2)

            Args:
            spread: Fixed spread amount (default 0.01)
            """

            def __init__(self, spread: float = 0.01):
            """Initialize with fixed spread."""
            if spread
            <
            0:
            raise ValueError("Spread must be non-negative")
            self.spread = spread

            def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
            """Calculate fill price with fixed spread."""
            half_spread = self.spread / 2

            if order.is_buy:
            # Buy at ask (worse price)
            return market_price + half_spread
            # Sell at bid (worse price)
            return market_price - half_spread

            def calculate_slippage_cost(
            self,
            order: Order,
            fill_quantity: Quantity,
            market_price: Price,
            fill_price: Price,
            ) -> float:
            """Calculate slippage cost from spread."""
            # Cost is the absolute difference times quantity
            return abs(fill_price - market_price) * fill_quantity


            class PercentageSlippage(SlippageModel):
            """Percentage-based slippage model.

            Slippage is a percentage of the market price.

            Args:
            slippage_pct: Slippage percentage (default 0.1%)
            min_slippage: Minimum slippage amount (default 0.001)
            """

            def __init__(self, slippage_pct: float = 0.001, min_slippage: float = 0.001):
            """Initialize with percentage parameters."""
            if slippage_pct
            <
            0:
            raise ValueError("Slippage percentage must be non-negative")
            if min_slippage
            <
            0:
            raise ValueError("Minimum slippage must be non-negative")

            self.slippage_pct = slippage_pct
            self.min_slippage = min_slippage

            def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
            """Calculate fill price with percentage slippage."""
            # Calculate slippage amount
            slippage_amount = max(market_price * self.slippage_pct, self.min_slippage)

            if order.is_buy:
            # Buy at higher price
            return market_price + slippage_amount
            # Sell at lower price
            return market_price - slippage_amount

            def calculate_slippage_cost(
            self,
            order: Order,
            fill_quantity: Quantity,
            market_price: Price,
            fill_price: Price,
            ) -> float:
            """Calculate slippage cost."""
            return abs(fill_price - market_price) * fill_quantity


            class LinearImpactSlippage(SlippageModel):
            """Linear market impact slippage model.

            Slippage increases linearly with order size.

            Args:
            base_slippage: Base slippage for minimal orders (default 0.0001)
            impact_coefficient: Impact per unit of order size (default 0.00001)
            """

            def __init__(
            self,
            base_slippage: float = 0.0001,
            impact_coefficient: float = 0.00001,
            ):
            """Initialize with impact parameters."""
            if base_slippage
            <
            0:
            raise ValueError("Base slippage must be non-negative")
            if impact_coefficient
            <
            0:
            raise ValueError("Impact coefficient must be non-negative")

            self.base_slippage = base_slippage
            self.impact_coefficient = impact_coefficient

            def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
            """Calculate fill price with linear impact."""
            # Linear impact based on order size
            impact = self.base_slippage + self.impact_coefficient * order.quantity
            slippage_amount = market_price * impact

            if order.is_buy:
            return market_price + slippage_amount
            return market_price - slippage_amount

            def calculate_slippage_cost(
            self,
            order: Order,
            fill_quantity: Quantity,
            market_price: Price,
            fill_price: Price,
            ) -> float:
            """Calculate slippage cost."""
            return abs(fill_price - market_price) * fill_quantity


            class SquareRootImpactSlippage(SlippageModel):
            """Square root market impact model (Almgren-Chriss style).

            Slippage increases with the square root of order size, modeling
            non-linear market impact for large orders.

            Args:
            temporary_impact: Temporary impact coefficient (default 0.1)
            permanent_impact: Permanent impact coefficient (default 0.05)
            """

            def __init__(
            self,
            temporary_impact: float = 0.1,
            permanent_impact: float = 0.05,
            ):
            """Initialize with impact parameters."""
            if temporary_impact
            <
            0:
            raise ValueError("Temporary impact must be non-negative")
            if permanent_impact
            <
            0:
            raise ValueError("Permanent impact must be non-negative")

            self.temporary_impact = temporary_impact
            self.permanent_impact = permanent_impact

            def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
            """Calculate fill price with square root impact."""
            import math

            # Square root impact model
            order_size_impact = math.sqrt(order.quantity / 1000.0) # Normalize by 1000 shares

            # Combine temporary and permanent impact
            total_impact = (
            self.temporary_impact * order_size_impact
            + self.permanent_impact * order_size_impact / 2
            )

            # Convert to price impact
            slippage_amount = market_price * total_impact * 0.01 # Convert to percentage

            if order.is_buy:
            return market_price + slippage_amount
            return market_price - slippage_amount

            def calculate_slippage_cost(
            self,
            order: Order,
            fill_quantity: Quantity,
            market_price: Price,
            fill_price: Price,
            ) -> float:
            """Calculate slippage cost."""
            return abs(fill_price - market_price) * fill_quantity


            class VolumeShareSlippage(SlippageModel):
            """Volume-based slippage model.

            Slippage is based on the percentage of daily volume being traded.
            Larger orders relative to volume have more impact.

            Args:
            volume_limit: Maximum percentage of volume per bar (default 0.025 = 2.5%)
            price_impact: Price impact coefficient (default 0.1)
            """

            def __init__(
            self,
            volume_limit: float = 0.025,
            price_impact: float = 0.1,
            ):
            """Initialize with volume parameters."""
            if not 0
            < volume_limit
            <= 1:
            raise ValueError("Volume limit must be between 0 and 1")
            if price_impact
            <
            0:
            raise ValueError("Price impact must be non-negative")

            self.volume_limit = volume_limit
            self.price_impact = price_impact
            self._daily_volume: float | None = None

            def set_daily_volume(self, volume: float) -> None:
            """Set the daily volume for impact calculation.

            Args:
            volume: Daily volume
            """
            self._daily_volume = volume

            def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
            """Calculate fill price based on volume impact."""
            if self._daily_volume is None or self._daily_volume == 0:
            # No volume data, use minimal slippage
            slippage_amount = market_price * 0.0001
            else:
            # Calculate volume share
            volume_share = min(order.quantity / self._daily_volume, self.volume_limit)

            # Quadratic impact model (like Zipline)
            impact = volume_share**2 * self.price_impact
            slippage_amount = market_price * impact

            if order.is_buy:
            return market_price + slippage_amount
            return market_price - slippage_amount

            def calculate_slippage_cost(
            self,
            order: Order,
            fill_quantity: Quantity,
            market_price: Price,
            fill_price: Price,
            ) -> float:
            """Calculate slippage cost."""
            return abs(fill_price - market_price) * fill_quantity


            class AssetClassSlippage(SlippageModel):
            """Asset class specific slippage model.

            Different slippage rates for different asset classes.

            Args:
            equity_slippage: Slippage for equities (default 0.01%)
            future_slippage: Slippage for futures (default 0.02%)
            option_slippage: Slippage for options (default 0.05%)
            fx_slippage: Slippage for forex (default 0.005%)
            crypto_slippage: Slippage for crypto (default 0.1%)
            """

            def __init__(
            self,
            equity_slippage: float = 0.0001,
            future_slippage: float = 0.0002,
            option_slippage: float = 0.0005,
            fx_slippage: float = 0.00005,
            crypto_slippage: float = 0.001,
            ):
            """Initialize with asset class specific rates."""
            self.slippage_rates = {
            "equity": equity_slippage,
            "future": future_slippage,
            "option": option_slippage,
            "forex": fx_slippage,
            "fx": fx_slippage, # Alias
            "crypto": crypto_slippage,
            }
            self.default_slippage = equity_slippage

            def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
            """Calculate fill price based on asset class."""
            # Get asset class from order metadata or default
            asset_class = order.metadata.get("asset_class", "equity")
            slippage_rate = self.slippage_rates.get(asset_class, self.default_slippage)

            slippage_amount = market_price * slippage_rate

            if order.is_buy:
            return market_price + slippage_amount
            return market_price - slippage_amount

            def calculate_slippage_cost(
            self,
            order: Order,
            fill_quantity: Quantity,
            market_price: Price,
            fill_price: Price,
            ) -> float:
            """Calculate slippage cost."""
            return abs(fill_price - market_price) * fill_quantity
        </file>

        <file path="src/qengine/portfolio/__init__.py">
            """Portfolio management for QEngine."""

            from qengine.portfolio.accounting import PortfolioAccounting
            from qengine.portfolio.margin import MarginAccount, MarginRequirement
            from qengine.portfolio.portfolio import Portfolio, PortfolioState, Position
            from qengine.portfolio.simple import SimplePortfolio

            __all__ = [
            "MarginAccount",
            "MarginRequirement",
            "Portfolio",
            "PortfolioAccounting",
            "PortfolioState",
            "Position",
            "SimplePortfolio",
            ]
        </file>

        <file path="src/qengine/portfolio/accounting.py">
            """Portfolio accounting and P&L tracking for QEngine."""

            from datetime import datetime
            from typing import Any

            import polars as pl

            from qengine.core.event import FillEvent
            from qengine.core.types import AssetId, Cash
            from qengine.portfolio.portfolio import Portfolio


            class PortfolioAccounting:
            """
            Handles portfolio accounting, P&L calculation, and performance tracking.

            This class integrates with the broker to track trades and calculate
            real-time portfolio metrics including realized/unrealized P&L,
            returns, and risk metrics.
            """

            def __init__(self, initial_cash: Cash = 100000.0, track_history: bool = True):
            """
            Initialize portfolio accounting.

            Args:
            initial_cash: Starting cash balance
            track_history: Whether to keep detailed history
            """
            self.portfolio = Portfolio(initial_cash)
            self.track_history = track_history

            # Track all fills
            self.fills: list[FillEvent] = []

            # Performance tracking
            self.high_water_mark = initial_cash
            self.max_drawdown = 0.0
            self.daily_returns: list[float] = []
            self.timestamps: list[datetime] = []
            self.equity_curve: list[float] = []

            # Risk tracking
            self.max_leverage = 0.0
            self.max_concentration = 0.0

            if track_history:
            self.timestamps.append(datetime.now())
            self.equity_curve.append(initial_cash)

            def process_fill(self, fill_event: FillEvent) -> None:
            """
            Process a fill event and update portfolio.

            Args:
            fill_event: Fill event from broker
            """
            # Record fill
            self.fills.append(fill_event)

            # Determine quantity change (positive for buy, negative for sell)
            quantity_change = fill_event.fill_quantity
            if fill_event.side.value == "sell":
            quantity_change = -quantity_change

            # Update portfolio position
            self.portfolio.update_position(
            asset_id=fill_event.asset_id,
            quantity_change=quantity_change,
            price=fill_event.fill_price,
            commission=fill_event.commission,
            slippage=fill_event.slippage,
            )

            # Update performance metrics
            self._update_metrics(fill_event.timestamp)

            def update_prices(self, prices: dict[AssetId, float], timestamp: datetime) -> None:
            """
            Update portfolio with new market prices.

            Args:
            prices: Dictionary of asset prices
            timestamp: Current timestamp
            """
            self.portfolio.update_prices(prices)
            self._update_metrics(timestamp)

            def _update_metrics(self, timestamp: datetime) -> None:
            """Update performance and risk metrics."""
            current_equity = self.portfolio.equity

            # Update high water mark and drawdown
            if current_equity > self.high_water_mark:
            self.high_water_mark = current_equity

            if self.high_water_mark > 0:
            current_drawdown = (self.high_water_mark - current_equity) / self.high_water_mark
            self.max_drawdown = max(self.max_drawdown, current_drawdown)

            # Track equity curve
            if self.track_history:
            self.timestamps.append(timestamp)
            self.equity_curve.append(current_equity)

            # Calculate daily return if we have previous data
            if len(self.equity_curve) > 1:
            prev_equity = self.equity_curve[-2]
            if prev_equity > 0:
            daily_return = (current_equity - prev_equity) / prev_equity
            self.daily_returns.append(daily_return)

            # Update risk metrics from current state
            state = self.portfolio.get_current_state(timestamp)
            self.max_leverage = max(self.max_leverage, state.leverage)
            self.max_concentration = max(self.max_concentration, state.concentration)

            # Save state if tracking history
            if self.track_history:
            self.portfolio.save_state(timestamp)

            def get_performance_metrics(self) -> dict[str, Any]:
            """Get comprehensive performance metrics."""
            metrics = {
            "total_return": self.portfolio.returns,
            "total_pnl": self.portfolio.total_realized_pnl + self.portfolio.unrealized_pnl,
            "realized_pnl": self.portfolio.total_realized_pnl,
            "unrealized_pnl": self.portfolio.unrealized_pnl,
            "max_drawdown": self.max_drawdown,
            "current_equity": self.portfolio.equity,
            "current_cash": self.portfolio.cash,
            "total_commission": self.portfolio.total_commission,
            "total_slippage": self.portfolio.total_slippage,
            "num_trades": len(self.fills),
            "max_leverage": self.max_leverage,
            "max_concentration": self.max_concentration,
            }

            # Add Sharpe ratio if we have enough data
            if len(self.daily_returns) > 1:
            import numpy as np

            returns = np.array(self.daily_returns)
            if returns.std() > 0:
            # Annualized Sharpe (assuming 252 trading days)
            metrics["sharpe_ratio"] = (returns.mean() / returns.std()) * np.sqrt(252)
            else:
            metrics["sharpe_ratio"] = 0.0

            return metrics

            def get_trades_df(self) -> pl.DataFrame | None:
            """Get all trades as a Polars DataFrame."""
            if not self.fills:
            return None

            trades_data = []
            for fill in self.fills:
            trades_data.append(
            {
            "timestamp": fill.timestamp,
            "order_id": fill.order_id,
            "trade_id": fill.trade_id,
            "asset_id": fill.asset_id,
            "side": fill.side.value,
            "quantity": fill.fill_quantity,
            "price": fill.fill_price,
            "commission": fill.commission,
            "slippage": fill.slippage,
            "total_cost": fill.total_cost,
            },
            )

            return pl.DataFrame(trades_data)

            def get_equity_curve_df(self) -> pl.DataFrame | None:
            """Get equity curve as a Polars DataFrame."""
            if not self.timestamps:
            return None

            return pl.DataFrame(
            {
            "timestamp": self.timestamps,
            "equity": self.equity_curve,
            "returns": [0.0, *self.daily_returns], # Pad with 0 for first day
            },
            )

            def get_positions_df(self) -> pl.DataFrame | None:
            """Get current positions as a Polars DataFrame."""
            if not self.portfolio.positions:
            return None

            positions_data = []
            for position in self.portfolio.positions.values():
            positions_data.append(
            {
            "asset_id": position.asset_id,
            "quantity": position.quantity,
            "cost_basis": position.cost_basis,
            "last_price": position.last_price,
            "market_value": position.market_value,
            "unrealized_pnl": position.unrealized_pnl,
            "realized_pnl": position.realized_pnl,
            "total_pnl": position.total_pnl,
            },
            )

            return pl.DataFrame(positions_data)

            def get_summary(self) -> dict[str, Any]:
            """Get portfolio summary."""
            summary = self.portfolio.get_position_summary()
            summary.update(self.get_performance_metrics())
            return summary

            def reset(self) -> None:
            """Reset portfolio to initial state."""
            initial_cash = self.portfolio.initial_cash
            self.portfolio = Portfolio(initial_cash)
            self.fills.clear()
            self.high_water_mark = initial_cash
            self.max_drawdown = 0.0
            self.daily_returns.clear()
            self.timestamps.clear()
            self.equity_curve.clear()
            self.max_leverage = 0.0
            self.max_concentration = 0.0

            if self.track_history:
            self.timestamps.append(datetime.now())
            self.equity_curve.append(initial_cash)
        </file>

        <file path="src/qengine/portfolio/margin.py">
            """Margin management for derivatives and leveraged trading."""

            from dataclasses import dataclass, field
            from datetime import datetime

            from qengine.core.assets import AssetRegistry, AssetSpec
            from qengine.core.types import AssetId, Cash, Price, Quantity


            @dataclass
            class MarginRequirement:
            """Margin requirements for a position."""

            asset_id: AssetId
            initial_margin: Cash
            maintenance_margin: Cash
            current_margin: Cash
            excess_margin: Cash
            margin_call: bool = False
            liquidation_price: Price | None = None


            @dataclass
            class MarginAccount:
            """
            Manages margin requirements for derivatives and leveraged trading.

            Handles:
            - Futures margin requirements
            - Options margin for sellers
            - FX leverage
            - Crypto perpetuals and leveraged trading
            - Portfolio margining
            """

            cash_balance: Cash
            initial_margin_requirement: Cash = 0.0
            maintenance_margin_requirement: Cash = 0.0
            margin_used: Cash = 0.0
            available_margin: Cash = 0.0
            positions: dict[AssetId, dict] = field(default_factory=dict)

            # Risk parameters
            margin_call_level: float = 1.0 # 100% of maintenance margin
            liquidation_level: float = 0.8 # 80% of maintenance margin

            def __init__(self, initial_cash: Cash, asset_registry: AssetRegistry):
            """Initialize margin account."""
            self.cash_balance = initial_cash
            self.available_margin = initial_cash
            self.asset_registry = asset_registry
            self.positions = {}
            self.margin_calls: list[MarginRequirement] = []

            def check_margin_requirement(
            self,
            asset_id: AssetId,
            quantity: Quantity,
            price: Price,
            ) -> tuple[bool, Cash]:
            """
            Check if there's sufficient margin for a new position.

            Args:
            asset_id: Asset to trade
            quantity: Quantity to trade
            price: Current price

            Returns:
            Tuple of (has_sufficient_margin, required_margin)
            """
            asset_spec = self.asset_registry.get(asset_id)
            if not asset_spec:
            # Default to equity-like behavior
            required = abs(quantity) * price
            return self.available_margin >= required, required

            required_margin = asset_spec.get_margin_requirement(quantity, price)
            has_margin = self.available_margin >= required_margin

            return has_margin, required_margin

            def open_position(
            self,
            asset_id: AssetId,
            quantity: Quantity,
            price: Price,
            timestamp: datetime,
            ) -> bool:
            """
            Open or modify a position with margin.

            Args:
            asset_id: Asset to trade
            quantity: Quantity to trade (positive for long, negative for short)
            price: Entry price
            timestamp: Transaction time

            Returns:
            Success status
            """
            has_margin, required_margin = self.check_margin_requirement(asset_id, quantity, price)

            if not has_margin:
            return False

            asset_spec = self.asset_registry.get(asset_id)

            if asset_id in self.positions:
            # Modify existing position
            pos = self.positions[asset_id]
            old_margin = pos["margin_used"]

            # Update position
            pos["quantity"] += quantity
            pos["avg_price"] = (
            (pos["avg_price"] * abs(pos["quantity"] - quantity) + price * abs(quantity))
            / abs(pos["quantity"])
            if pos["quantity"] != 0
            else 0
            )
            pos["last_price"] = price
            pos["timestamp"] = timestamp

            # Recalculate margin
            if asset_spec:
            new_margin = asset_spec.get_margin_requirement(pos["quantity"], price)
            pos["margin_used"] = new_margin
            margin_change = new_margin - old_margin
            else:
            pos["margin_used"] = abs(pos["quantity"]) * price
            margin_change = pos["margin_used"] - old_margin

            # Update account margins
            self.margin_used += margin_change
            self.available_margin -= margin_change

            # Remove position if closed
            if pos["quantity"] == 0:
            self.margin_used -= pos["margin_used"]
            self.available_margin += pos["margin_used"]
            del self.positions[asset_id]
            else:
            # Open new position
            self.positions[asset_id] = {
            "quantity": quantity,
            "avg_price": price,
            "last_price": price,
            "margin_used": required_margin,
            "timestamp": timestamp,
            "asset_spec": asset_spec,
            }

            self.margin_used += required_margin
            self.available_margin -= required_margin

            # Update margin requirements
            self._update_margin_requirements()

            return True

            def update_prices(self, prices: dict[AssetId, Price]) -> list[MarginRequirement]:
            """
            Update positions with new prices and check margin requirements.

            Args:
            prices: Current market prices

            Returns:
            List of margin requirements/calls
            """
            margin_status = []

            for asset_id, price in prices.items():
            if asset_id not in self.positions:
            continue

            pos = self.positions[asset_id]
            pos["last_price"] = price

            # Calculate unrealized P&L
            pos["quantity"] * (price - pos["avg_price"])

            # Update margin for this position
            asset_spec = pos.get("asset_spec")
            if asset_spec and asset_spec.requires_margin:
            current_margin = asset_spec.get_margin_requirement(pos["quantity"], price)

            # Calculate liquidation price
            liquidation_price = self._calculate_liquidation_price(asset_id, pos, asset_spec)

            # Check margin status
            margin_req = MarginRequirement(
            asset_id=asset_id,
            initial_margin=asset_spec.initial_margin * abs(pos["quantity"]),
            maintenance_margin=asset_spec.maintenance_margin * abs(pos["quantity"]),
            current_margin=current_margin,
            excess_margin=self.available_margin,
            margin_call=current_margin > self.available_margin * self.margin_call_level,
            liquidation_price=liquidation_price,
            )

            margin_status.append(margin_req)

            # Force liquidation if below threshold
            if current_margin > self.available_margin * self.liquidation_level:
            self._force_liquidation(asset_id, price)

            # Update total equity
            self._update_equity()

            return margin_status

            def _calculate_liquidation_price(
            self,
            asset_id: AssetId,
            position: dict,
            asset_spec: AssetSpec,
            ) -> Price | None:
            """Calculate liquidation price for a position."""
            if not asset_spec.requires_margin:
            return None

            quantity = position["quantity"]
            avg_price = position["avg_price"]

            if asset_spec.asset_class.value == "future":
            # Futures liquidation when margin depleted
            maintenance_margin = asset_spec.maintenance_margin * abs(quantity)
            if quantity > 0: # Long position
            return avg_price - (self.available_margin - maintenance_margin) / (
            quantity * asset_spec.contract_size
            )
            # Short position
            return avg_price + (self.available_margin - maintenance_margin) / (
            abs(quantity) * asset_spec.contract_size
            )
            if asset_spec.asset_class.value == "fx":
            # FX liquidation based on leverage
            margin_used = position["margin_used"]
            if quantity > 0:
            return avg_price * (
            1 - self.liquidation_level * margin_used / (abs(quantity) * avg_price)
            )
            return avg_price * (
            1 + self.liquidation_level * margin_used / (abs(quantity) * avg_price)
            )

            return None

            def _force_liquidation(self, asset_id: AssetId, price: Price) -> None:
            """Force liquidate a position due to margin call."""
            if asset_id in self.positions:
            pos = self.positions[asset_id]

            # Return margin to available
            self.margin_used -= pos["margin_used"]
            self.available_margin += pos["margin_used"]

            # Calculate and apply loss
            loss = pos["quantity"] * (price - pos["avg_price"])
            self.cash_balance += loss # Loss reduces cash

            # Remove position
            del self.positions[asset_id]

            def _update_margin_requirements(self) -> None:
            """Update total margin requirements."""
            self.initial_margin_requirement = 0.0
            self.maintenance_margin_requirement = 0.0

            for _asset_id, pos in self.positions.items():
            asset_spec = pos.get("asset_spec")
            if asset_spec and asset_spec.requires_margin:
            self.initial_margin_requirement += asset_spec.initial_margin * abs(pos["quantity"])
            self.maintenance_margin_requirement += asset_spec.maintenance_margin * abs(
            pos["quantity"],
            )

            def _update_equity(self) -> None:
            """Update total account equity."""
            total_unrealized = 0.0

            for pos in self.positions.values():
            unrealized = pos["quantity"] * (pos["last_price"] - pos["avg_price"])

            # Apply contract multiplier for futures
            asset_spec = pos.get("asset_spec")
            if asset_spec and asset_spec.asset_class.value == "future":
            unrealized *= asset_spec.contract_size

            total_unrealized += unrealized

            # Update available margin with unrealized P&L
            self.available_margin = self.cash_balance + total_unrealized - self.margin_used

            def get_margin_status(self) -> dict:
            """Get current margin account status."""
            total_unrealized = sum(
            pos["quantity"] * (pos["last_price"] - pos["avg_price"])
            for pos in self.positions.values()
            )

            return {
            "cash_balance": self.cash_balance,
            "margin_used": self.margin_used,
            "available_margin": self.available_margin,
            "initial_requirement": self.initial_margin_requirement,
            "maintenance_requirement": self.maintenance_margin_requirement,
            "unrealized_pnl": total_unrealized,
            "total_equity": self.cash_balance + total_unrealized,
            "margin_utilization": self.margin_used / self.available_margin
            if self.available_margin > 0
            else 0,
            "num_positions": len(self.positions),
            "has_margin_call": any(mc.margin_call for mc in self.margin_calls),
            }
        </file>

        <file path="src/qengine/portfolio/portfolio.py">
            """Portfolio state management for QEngine."""

            from dataclasses import dataclass, field
            from datetime import datetime
            from typing import Any

            from qengine.core.types import AssetId, Cash, Quantity


            @dataclass
            class Position:
            """Represents a position in a single asset."""

            asset_id: AssetId
            quantity: Quantity = 0.0
            cost_basis: float = 0.0
            last_price: float = 0.0
            realized_pnl: float = 0.0
            unrealized_pnl: float = 0.0

            @property
            def market_value(self) -> float:
            """Current market value of the position."""
            return self.quantity * self.last_price

            @property
            def total_pnl(self) -> float:
            """Total P&L (realized + unrealized)."""
            return self.realized_pnl + self.unrealized_pnl

            def update_price(self, price: float) -> None:
            """Update position with new market price."""
            self.last_price = price
            if self.quantity != 0:
            self.unrealized_pnl = self.quantity * (price - self.cost_basis / self.quantity)

            def add_shares(self, quantity: Quantity, price: float) -> None:
            """Add shares to position."""
            if self.quantity + quantity == 0:
            # Closing position
            self.realized_pnl += self.unrealized_pnl
            self.unrealized_pnl = 0.0
            self.cost_basis = 0.0
            else:
            # Update cost basis
            new_cost = quantity * price
            self.cost_basis += new_cost

            self.quantity += quantity
            self.update_price(price)

            def remove_shares(self, quantity: Quantity, price: float) -> float:
            """Remove shares from position, returns realized P&L."""
            if abs(quantity) > abs(self.quantity):
            raise ValueError(f"Cannot remove {quantity} shares, only have {self.quantity}")

            # Calculate realized P&L for the shares being removed
            avg_cost = self.cost_basis / self.quantity if self.quantity != 0 else 0
            realized = quantity * (price - avg_cost)
            self.realized_pnl += realized

            # Update cost basis
            self.cost_basis -= quantity * avg_cost
            self.quantity -= quantity

            self.update_price(price)
            return realized


            @dataclass
            class PortfolioState:
            """Complete portfolio state at a point in time."""

            timestamp: datetime
            cash: Cash
            positions: dict[AssetId, Position] = field(default_factory=dict)
            pending_orders: list[Any] = field(default_factory=list)
            filled_orders: list[Any] = field(default_factory=list)

            # Performance metrics
            total_value: float = 0.0
            total_realized_pnl: float = 0.0
            total_unrealized_pnl: float = 0.0
            total_commission: float = 0.0
            total_slippage: float = 0.0

            # Risk metrics
            leverage: float = 1.0
            max_position_value: float = 0.0
            concentration: float = 0.0

            @property
            def equity(self) -> float:
            """Total equity (cash + positions)."""
            position_value = sum(p.market_value for p in self.positions.values())
            return self.cash + position_value

            @property
            def total_pnl(self) -> float:
            """Total P&L across all positions."""
            return self.total_realized_pnl + self.total_unrealized_pnl

            def update_metrics(self) -> None:
            """Update portfolio metrics."""
            # Update position values
            position_values = [p.market_value for p in self.positions.values()]

            if position_values:
            self.max_position_value = max(abs(v) for v in position_values)
            total_position_value = sum(abs(v) for v in position_values)

            # Update concentration (largest position as % of portfolio)
            if self.equity > 0:
            self.concentration = self.max_position_value / self.equity
            self.leverage = total_position_value / self.equity
            else:
            self.concentration = 0.0
            self.leverage = 0.0
            else:
            self.max_position_value = 0.0
            self.concentration = 0.0
            self.leverage = 0.0

            # Update P&L
            self.total_unrealized_pnl = sum(p.unrealized_pnl for p in self.positions.values())
            self.total_realized_pnl = sum(p.realized_pnl for p in self.positions.values())
            self.total_value = self.equity


            class Portfolio:
            """Portfolio management with state tracking."""

            def __init__(self, initial_cash: Cash = 100000.0):
            """Initialize portfolio with starting cash."""
            self.initial_cash = initial_cash
            self.cash = initial_cash
            self.positions: dict[AssetId, Position] = {}

            # Track cumulative costs
            self.total_commission = 0.0
            self.total_slippage = 0.0
            self.total_realized_pnl = 0.0

            # History tracking
            self.state_history: list[PortfolioState] = []

            def get_position(self, asset_id: AssetId) -> Position | None:
            """Get position for an asset."""
            return self.positions.get(asset_id)

            def update_position(
            self,
            asset_id: AssetId,
            quantity_change: Quantity,
            price: float,
            commission: float = 0.0,
            slippage: float = 0.0,
            ) -> None:
            """
            Update a position with a trade.

            Args:
            asset_id: Asset identifier
            quantity_change: Change in quantity (positive for buy, negative for sell)
            price: Execution price
            commission: Commission paid
            slippage: Slippage cost
            """
            # Get or create position
            if asset_id not in self.positions:
            self.positions[asset_id] = Position(asset_id=asset_id)

            position = self.positions[asset_id]

            # Update position
            if quantity_change > 0:
            position.add_shares(quantity_change, price)
            self.cash -= quantity_change * price + commission
            else:
            realized_pnl = position.remove_shares(-quantity_change, price)
            self.cash += (-quantity_change) * price - commission
            self.total_realized_pnl += realized_pnl

            # Track costs
            self.total_commission += commission
            self.total_slippage += slippage

            # Remove empty positions
            if position.quantity == 0 and position.realized_pnl == 0:
            del self.positions[asset_id]

            def update_prices(self, prices: dict[AssetId, float]) -> None:
            """Update all positions with new market prices."""
            for asset_id, price in prices.items():
            if asset_id in self.positions:
            self.positions[asset_id].update_price(price)

            def get_current_state(self, timestamp: datetime) -> PortfolioState:
            """Get current portfolio state."""
            state = PortfolioState(
            timestamp=timestamp,
            cash=self.cash,
            positions=self.positions.copy(),
            total_commission=self.total_commission,
            total_slippage=self.total_slippage,
            total_realized_pnl=self.total_realized_pnl,
            )
            state.update_metrics()
            return state

            def save_state(self, timestamp: datetime) -> None:
            """Save current state to history."""
            self.state_history.append(self.get_current_state(timestamp))

            @property
            def equity(self) -> float:
            """Total equity (cash + positions)."""
            position_value = sum(p.market_value for p in self.positions.values())
            return self.cash + position_value

            @property
            def returns(self) -> float:
            """Simple returns from initial capital."""
            if self.initial_cash == 0:
            return 0.0
            return (self.equity - self.initial_cash) / self.initial_cash

            @property
            def unrealized_pnl(self) -> float:
            """Total unrealized P&L."""
            return sum(p.unrealized_pnl for p in self.positions.values())

            def get_position_summary(self) -> dict[str, Any]:
            """Get summary of all positions."""
            return {
            "cash": self.cash,
            "equity": self.equity,
            "positions": len(self.positions),
            "realized_pnl": self.total_realized_pnl,
            "unrealized_pnl": self.unrealized_pnl,
            "total_pnl": self.total_realized_pnl + self.unrealized_pnl,
            "returns": self.returns,
            "commission": self.total_commission,
            "slippage": self.total_slippage,
            }
        </file>

        <file path="src/qengine/portfolio/simple.py">
            """Simple portfolio implementation for basic backtesting."""

            import logging
            from datetime import datetime
            from typing import Any

            import polars as pl

            from qengine.core.event import FillEvent, MarketEvent
            from qengine.core.types import Cash
            from qengine.portfolio.portfolio import Portfolio

            logger = logging.getLogger(__name__)


            class SimplePortfolio(Portfolio):
            """Simple portfolio implementation with basic tracking.

            This portfolio provides:
            - Position tracking
            - P&L calculation
            - Basic performance metrics
            - Event handling integration
            """

            def __init__(self, initial_capital: Cash = 100000.0, currency: str = "USD"):
            """Initialize simple portfolio.

            Args:
            initial_capital: Starting cash balance
            currency: Base currency
            """
            super().__init__(initial_cash=initial_capital)
            self.currency = currency
            self.trades = [] # Track all trades
            self.current_prices = {} # Latest market prices

            def initialize(self) -> None:
            """Initialize portfolio for new backtest."""
            logger.debug(f"Initializing portfolio with ${self.initial_cash:,.2f} {self.currency}")

            def on_fill_event(self, event: FillEvent) -> None:
            """Handle fill event from broker.

            Args:
            event: Fill event with execution details
            """
            # Update position
            self.update_position(
            asset_id=event.asset_id,
            quantity_change=event.fill_quantity
            if event.side.value in ["buy", "BUY"]
            else -event.fill_quantity,
            price=float(event.fill_price),
            commission=event.commission,
            slippage=event.slippage,
            )

            # Record trade
            self.trades.append(
            {
            "timestamp": event.timestamp,
            "asset_id": event.asset_id,
            "side": event.side.value,
            "quantity": event.fill_quantity,
            "price": float(event.fill_price),
            "commission": event.commission,
            "slippage": event.slippage,
            "pnl": 0.0, # Will be calculated later
            },
            )

            logger.info(
            f"Fill: {event.side.value.upper()} {event.fill_quantity} {event.asset_id} "
            f"@ ${float(event.fill_price):.2f} (commission: ${event.commission:.2f})",
            )

            def update_market_value(self, event: MarketEvent) -> None:
            """Update portfolio with latest market prices.

            Args:
            event: Market event with price data
            """
            # Update current price for the asset
            if hasattr(event, "close") and event.close is not None:
            self.current_prices[event.asset_id] = float(event.close)
            elif hasattr(event, "price") and event.price is not None:
            self.current_prices[event.asset_id] = float(event.price)

            # Update all positions with latest prices
            self.update_prices(self.current_prices)

            def get_total_value(self) -> float:
            """Get total portfolio value (cash + positions).

            Returns:
            Total portfolio value
            """
            return self.equity

            def get_positions(self) -> pl.DataFrame:
            """Get DataFrame of current positions.

            Returns:
            DataFrame with position details
            """
            if not self.positions:
            return pl.DataFrame()

            positions_data = []
            for asset_id, position in self.positions.items():
            positions_data.append(
            {
            "asset_id": asset_id,
            "quantity": position.quantity,
            "cost_basis": position.cost_basis,
            "market_value": position.market_value,
            "unrealized_pnl": position.unrealized_pnl,
            "realized_pnl": position.realized_pnl,
            "last_price": position.last_price,
            },
            )

            return pl.DataFrame(positions_data)

            def get_trades(self) -> pl.DataFrame:
            """Get DataFrame of all trades.

            Returns:
            DataFrame with trade history
            """
            if not self.trades:
            return pl.DataFrame()
            return pl.DataFrame(self.trades)

            def get_returns(self) -> pl.Series:
            """Get returns series.

            Returns:
            Series of portfolio returns
            """
            if not self.state_history:
            return pl.Series([])

            returns = []
            prev_value = self.initial_cash

            for state in self.state_history:
            current_value = state.equity
            ret = (current_value - prev_value) / prev_value if prev_value != 0 else 0
            returns.append(ret)
            prev_value = current_value

            return pl.Series(returns)

            def calculate_metrics(self) -> dict[str, Any]:
            """Calculate performance metrics.

            Returns:
            Dictionary of performance metrics
            """
            returns = self.get_returns()

            metrics = {
            "total_return": self.returns * 100, # Percentage
            "total_trades": len(self.trades),
            "winning_trades": sum(1 for t in self.trades if t.get("pnl", 0) > 0),
            "losing_trades": sum(1 for t in self.trades if t.get("pnl", 0)
            <
            0),
            "total_commission": self.total_commission,
            "total_slippage": self.total_slippage,
            "final_equity": self.equity,
            "cash_remaining": self.cash,
            }

            # Calculate returns-based metrics if we have data
            if len(returns) > 0:
            import numpy as np

            returns_array = returns.to_numpy()

            # Remove any NaN values
            returns_array = returns_array[~np.isnan(returns_array)]

            if len(returns_array) > 0:
            metrics["avg_return"] = np.mean(returns_array)
            metrics["std_return"] = np.std(returns_array)

            # Sharpe ratio (assuming 0 risk-free rate)
            if metrics["std_return"] > 0:
            metrics["sharpe_ratio"] = (
            np.sqrt(252) * metrics["avg_return"] / metrics["std_return"]
            )
            else:
            metrics["sharpe_ratio"] = 0.0

            # Maximum drawdown
            cumulative = np.cumprod(1 + returns_array)
            running_max = np.maximum.accumulate(cumulative)
            drawdown = (cumulative - running_max) / running_max
            metrics["max_drawdown"] = np.min(drawdown) * 100 # Percentage

            # Win rate
            if metrics["total_trades"] > 0:
            metrics["win_rate"] = (
            metrics["winning_trades"] / metrics["total_trades"]
            ) * 100
            else:
            metrics["win_rate"] = 0.0

            return metrics

            def finalize(self) -> None:
            """Finalize portfolio at end of backtest."""
            # Save final state
            self.save_state(datetime.now())

            # Calculate P&L for all trades
            for i, trade in enumerate(self.trades):
            if i > 0 and trade["side"] in ["sell", "SELL"]:
            # Find corresponding buy trade and calculate P&L
            # This is simplified - real implementation would match specific lots
            prev_trades = [t for t in self.trades[:i] if t["asset_id"] == trade["asset_id"]]
            if prev_trades:
            avg_buy_price = sum(
            t["price"] * t["quantity"]
            for t in prev_trades
            if t["side"] in ["buy", "BUY"]
            ) / sum(t["quantity"] for t in prev_trades if t["side"] in ["buy", "BUY"])
            trade["pnl"] = (trade["price"] - avg_buy_price) * trade["quantity"] - trade[
            "commission"
            ]

            logger.info(f"Portfolio finalized. Final equity: ${self.equity:,.2f}")

            def reset(self) -> None:
            """Reset portfolio to initial state."""
            self.cash = self.initial_cash
            self.positions.clear()
            self.trades.clear()
            self.current_prices.clear()
            self.state_history.clear()
            self.total_commission = 0.0
            self.total_slippage = 0.0
            self.total_realized_pnl = 0.0


            __all__ = ["SimplePortfolio"]
        </file>

        <file path="src/qengine/reporting/__init__.py">
            """Reporting module for QEngine."""

            from qengine.reporting.base import ReportGenerator
            from qengine.reporting.html import HTMLReportGenerator
            from qengine.reporting.parquet import ParquetReportGenerator
            from qengine.reporting.reporter import ConsoleReporter, InMemoryReporter, Reporter

            __all__ = [
            "ConsoleReporter",
            "HTMLReportGenerator",
            "InMemoryReporter",
            "ParquetReportGenerator",
            "ReportGenerator",
            "Reporter",
            ]
        </file>

        <file path="src/qengine/reporting/base.py">
            """Base reporting functionality for QEngine."""

            from abc import ABC, abstractmethod
            from datetime import datetime
            from pathlib import Path
            from typing import Any

            from qengine.portfolio.accounting import PortfolioAccounting


            class ReportGenerator(ABC):
            """
            Abstract base class for report generation.

            Different report formats (HTML, Parquet, JSON) should implement this interface.
            """

            def __init__(self, output_dir: Path | None = None, report_name: str | None = None):
            """
            Initialize report generator.

            Args:
            output_dir: Directory to save reports
            report_name: Base name for report files
            """
            self.output_dir = Path(output_dir) if output_dir else Path.cwd() / "reports"
            self.report_name = report_name or f"backtest_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

            # Ensure output directory exists
            self.output_dir.mkdir(parents=True, exist_ok=True)

            @abstractmethod
            def generate(
            self,
            accounting: PortfolioAccounting,
            strategy_params: dict[str, Any] | None = None,
            backtest_params: dict[str, Any] | None = None,
            ) -> Path:
            """
            Generate report from portfolio accounting data.

            Args:
            accounting: Portfolio accounting with results
            strategy_params: Strategy configuration parameters
            backtest_params: Backtest configuration parameters

            Returns:
            Path to generated report
            """

            def _prepare_report_data(
            self,
            accounting: PortfolioAccounting,
            strategy_params: dict[str, Any] | None = None,
            backtest_params: dict[str, Any] | None = None,
            ) -> dict[str, Any]:
            """
            Prepare standardized report data from accounting.

            Args:
            accounting: Portfolio accounting instance
            strategy_params: Strategy parameters
            backtest_params: Backtest parameters

            Returns:
            Dictionary with report data
            """
            # Get performance metrics
            metrics = accounting.get_performance_metrics()

            # Get summary data
            summary = accounting.get_summary()

            # Prepare report data structure
            report_data = {
            "metadata": {
            "report_name": self.report_name,
            "generated_at": datetime.now().isoformat(),
            "strategy_params": strategy_params or {},
            "backtest_params": backtest_params or {},
            },
            "performance": {
            "total_return": metrics.get("total_return", 0.0),
            "total_pnl": metrics.get("total_pnl", 0.0),
            "realized_pnl": metrics.get("realized_pnl", 0.0),
            "unrealized_pnl": metrics.get("unrealized_pnl", 0.0),
            "max_drawdown": metrics.get("max_drawdown", 0.0),
            "sharpe_ratio": metrics.get("sharpe_ratio", 0.0),
            "num_trades": metrics.get("num_trades", 0),
            "win_rate": self._calculate_win_rate(accounting),
            "profit_factor": self._calculate_profit_factor(accounting),
            },
            "costs": {
            "total_commission": metrics.get("total_commission", 0.0),
            "total_slippage": metrics.get("total_slippage", 0.0),
            "avg_commission_per_trade": self._calculate_avg_commission(accounting),
            "avg_slippage_per_trade": self._calculate_avg_slippage(accounting),
            },
            "portfolio": {
            "initial_cash": accounting.portfolio.initial_cash,
            "final_equity": summary.get("equity", 0.0),
            "final_cash": summary.get("cash", 0.0),
            "num_positions": summary.get("positions", 0),
            },
            "risk": {
            "max_leverage": metrics.get("max_leverage", 1.0),
            "max_concentration": metrics.get("max_concentration", 0.0),
            },
            "trades": accounting.get_trades_df(),
            "equity_curve": accounting.get_equity_curve_df(),
            "positions": accounting.get_positions_df(),
            }

            return report_data

            def _calculate_win_rate(self, accounting: PortfolioAccounting) -> float:
            """Calculate win rate from trades."""
            if not accounting.fills:
            return 0.0

            # Group trades by asset to calculate P&L
            winning_trades = 0
            total_trades = 0

            # Track positions to determine win/loss
            position_pnl = {}

            for fill in accounting.fills:
            asset_id = fill.asset_id

            if fill.side.value == "buy":
            if asset_id not in position_pnl:
            position_pnl[asset_id] = []
            position_pnl[asset_id].append(
            {"quantity": fill.fill_quantity, "price": fill.fill_price},
            )
            elif fill.side.value == "sell":
            if position_pnl.get(asset_id):
            # Calculate P&L for this trade
            buy_info = position_pnl[asset_id].pop(0)
            pnl = (fill.fill_price - buy_info["price"]) * min(
            fill.fill_quantity,
            buy_info["quantity"],
            )

            total_trades += 1
            if pnl > 0:
            winning_trades += 1

            return winning_trades / total_trades if total_trades > 0 else 0.0

            def _calculate_profit_factor(self, accounting: PortfolioAccounting) -> float:
            """Calculate profit factor (gross profit / gross loss)."""
            gross_profit = 0.0
            gross_loss = 0.0

            # Track positions to determine profits and losses
            position_costs = {}

            for fill in accounting.fills:
            asset_id = fill.asset_id

            if fill.side.value == "buy":
            if asset_id not in position_costs:
            position_costs[asset_id] = []
            position_costs[asset_id].append(
            {"quantity": fill.fill_quantity, "price": fill.fill_price},
            )
            elif fill.side.value == "sell":
            if position_costs.get(asset_id):
            # Calculate P&L for this trade
            buy_info = position_costs[asset_id].pop(0)
            pnl = (fill.fill_price - buy_info["price"]) * min(
            fill.fill_quantity,
            buy_info["quantity"],
            )

            if pnl > 0:
            gross_profit += pnl
            else:
            gross_loss += abs(pnl)

            return (
            gross_profit / gross_loss
            if gross_loss > 0
            else float("inf")
            if gross_profit > 0
            else 0.0
            )

            def _calculate_avg_commission(self, accounting: PortfolioAccounting) -> float:
            """Calculate average commission per trade."""
            if not accounting.fills:
            return 0.0
            return accounting.portfolio.total_commission / len(accounting.fills)

            def _calculate_avg_slippage(self, accounting: PortfolioAccounting) -> float:
            """Calculate average slippage per trade."""
            if not accounting.fills:
            return 0.0
            return accounting.portfolio.total_slippage / len(accounting.fills)
        </file>

        <file path="src/qengine/reporting/html.py">
            """HTML report generation for QEngine backtests."""

            import json
            from pathlib import Path
            from typing import Any

            from qengine.portfolio.accounting import PortfolioAccounting
            from qengine.reporting.base import ReportGenerator


            class HTMLReportGenerator(ReportGenerator):
            """
            Generates comprehensive HTML reports for backtest results.

            Creates interactive reports with:
            - Performance summary
            - Equity curve charts
            - Trade analysis
            - Risk metrics
            - Asset class breakdown
            """

            def generate(
            self,
            accounting: PortfolioAccounting,
            strategy_params: dict[str, Any] | None = None,
            backtest_params: dict[str, Any] | None = None,
            ) -> Path:
            """
            Generate HTML report from portfolio accounting data.

            Args:
            accounting: Portfolio accounting with results
            strategy_params: Strategy configuration parameters
            backtest_params: Backtest configuration parameters

            Returns:
            Path to generated HTML report
            """
            # Prepare report data
            report_data = self._prepare_report_data(accounting, strategy_params, backtest_params)

            # Generate HTML content
            html_content = self._generate_html_content(report_data)

            # Save report
            report_path = self.output_dir / f"{self.report_name}.html"
            with open(report_path, "w", encoding="utf-8") as f:
            f.write(html_content)

            return report_path

            def _generate_html_content(self, report_data: dict[str, Any]) -> str:
            """Generate the complete HTML report content."""
            html = f"""
            <!DOCTYPE html>
            <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>QEngine Backtest Report - {report_data["metadata"]["report_name"]}</title>
                    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
                    <style>
                        {self._get_css_styles()}
                    </style>
                </head>
                <body>
                    <div class="container">
                        {self._generate_header(report_data)}
                        {self._generate_summary_section(report_data)}
                        {self._generate_performance_section(report_data)}
                        {self._generate_charts_section(report_data)}
                        {self._generate_trades_section(report_data)}
                        {self._generate_positions_section(report_data)}
                        {self._generate_risk_section(report_data)}
                        {self._generate_footer(report_data)}
                    </div>

                    <script>
                        {self._generate_javascript(report_data)}
                    </script>
                </body>
            </html>
            """
            return html

            def _get_css_styles(self) -> str:
            """Get CSS styles for the report."""
            return """
            * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            }

            body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            }

            .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            }

            .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
            }

            .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            }

            .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            }

            .section {
            background: white;
            margin-bottom: 30px;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            }

            .section h2 {
            color: #667eea;
            font-size: 1.8em;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            }

            .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            }

            .metric-card {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            }

            .metric-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            }

            .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #333;
            }

            .metric-value.positive {
            color: #28a745;
            }

            .metric-value.negative {
            color: #dc3545;
            }

            .chart-container {
            margin: 20px 0;
            min-height: 400px;
            }

            .table-container {
            overflow-x: auto;
            margin-top: 20px;
            }

            table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            }

            th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            }

            th {
            background-color: #f8f9ff;
            font-weight: 600;
            color: #667eea;
            }

            tr:hover {
            background-color: #f8f9ff;
            }

            .footer {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            }

            .warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            }

            .info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            }

            @media (max-width: 768px) {
            .metrics-grid {
            grid-template-columns: 1fr;
            }

            .header h1 {
            font-size: 2em;
            }
            }
            """

            def _generate_header(self, report_data: dict[str, Any]) -> str:
            """Generate the report header."""
            metadata = report_data["metadata"]
            return f"""
            <div class="header">
                <h1>QEngine Backtest Report</h1>
                <div class="subtitle">
                    {metadata["report_name"]}
                    <br>
                    Generated: {metadata["generated_at"][:19]}
                </div>
            </div>
            """

            def _generate_summary_section(self, report_data: dict[str, Any]) -> str:
            """Generate the summary metrics section."""
            perf = report_data["performance"]
            portfolio = report_data["portfolio"]
            costs = report_data["costs"]

            return f"""
            <div class="section">
                <h2>Performance Summary</h2>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-label">Total Return</div>
                        <div class="metric-value {" positive" if perf["total_return"] >= 0 else "negative"}">
                        {perf["total_return"]:.2%}
                    </div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Total P&L</div>
                    <div class="metric-value {" positive" if perf["total_pnl"] >= 0 else "negative"}">
                    ${perf["total_pnl"]:,.2f}
                </div>
            </div>

            <div class="metric-card">
                <div class="metric-label">Sharpe Ratio</div>
                <div class="metric-value {" positive" if perf.get("sharpe_ratio", 0) >= 0 else "negative"}">
                {perf.get("sharpe_ratio", "N/A")}
            </div>
        </div>

        <div class="metric-card">
            <div class="metric-label">Max Drawdown</div>
            <div class="metric-value negative">
                -{perf["max_drawdown"]:.2%}
            </div>
        </div>

        <div class="metric-card">
            <div class="metric-label">Win Rate</div>
            <div class="metric-value">
                {perf["win_rate"]:.2%}
            </div>
        </div>

        <div class="metric-card">
            <div class="metric-label">Total Trades</div>
            <div class="metric-value">
                {perf["num_trades"]:,}
            </div>
        </div>

        <div class="metric-card">
            <div class="metric-label">Final Equity</div>
            <div class="metric-value">
                ${portfolio["final_equity"]:,.2f}
            </div>
        </div>

        <div class="metric-card">
            <div class="metric-label">Total Commission</div>
            <div class="metric-value negative">
                ${costs["total_commission"]:,.2f}
            </div>
        </div>
    </div>
</div>
        """

        def _generate_performance_section(self, report_data: dict[str, Any]) -> str:
        """Generate detailed performance metrics."""
        perf = report_data["performance"]
        costs = report_data["costs"]

        return f"""
<div class="section">
<h2>Detailed Performance</h2>

<div class="metrics-grid">
    <div class="metric-card">
        <div class="metric-label">Realized P&L</div>
        <div class="metric-value {" positive" if perf["realized_pnl"] >= 0 else "negative"}">
        ${perf["realized_pnl"]:,.2f}
    </div>
</div>

<div class="metric-card">
    <div class="metric-label">Unrealized P&L</div>
    <div class="metric-value {" positive" if perf["unrealized_pnl"] >= 0 else "negative"}">
    ${perf["unrealized_pnl"]:,.2f}
</div>
</div>

<div class="metric-card">
<div class="metric-label">Profit Factor</div>
<div class="metric-value">
    {perf["profit_factor"]:.2f}
</div>
</div>

<div class="metric-card">
<div class="metric-label">Avg Commission/Trade</div>
<div class="metric-value">
    ${costs["avg_commission_per_trade"]:.2f}
</div>
</div>
        </div>
        </div>
        """

        def _generate_charts_section(self, report_data: dict[str, Any]) -> str:
        """Generate charts section."""
        return """
<div class="section">
<h2>Charts</h2>

<div class="chart-container">
    <div id="equity-curve-chart"></div>
</div>

<div class="chart-container">
    <div id="returns-chart"></div>
</div>
</div>
        """

        def _generate_trades_section(self, report_data: dict[str, Any]) -> str:
        """Generate trades analysis section."""
        trades_df = report_data.get("trades")

        if trades_df is None or len(trades_df) == 0:
        return """
<div class="section">
<h2>Trade Analysis</h2>
<div class="info">No trades found in this backtest.</div>
</div>
        """

        # Get first few trades for display
        display_trades = trades_df.head(20).to_dicts()

        trades_html = ""
        for trade in display_trades:
        trades_html += f"""
<tr>
<td>{trade["timestamp"]}</td>
<td>{trade["asset_id"]}</td>
<td>{trade["side"].upper()}</td>
<td>{trade["quantity"]:.2f}</td>
<td>${trade["price"]:.2f}</td>
<td>${trade["commission"]:.2f}</td>
<td>${trade["total_cost"]:.2f}</td>
</tr>
        """

        return f"""
<div class="section">
<h2>Trade Analysis</h2>

<div class="info">
    Showing first 20 trades out of {len(trades_df)} total trades.
</div>

<div class="table-container">
    <table>
        <thead>
            <tr>
                <th>Timestamp</th>
                <th>Asset</th>
                <th>Side</th>
                <th>Quantity</th>
                <th>Price</th>
                <th>Commission</th>
                <th>Total Cost</th>
            </tr>
        </thead>
        <tbody>
            {trades_html}
        </tbody>
    </table>
</div>
</div>
        """

        def _generate_positions_section(self, report_data: dict[str, Any]) -> str:
        """Generate current positions section."""
        positions_df = report_data.get("positions")

        if positions_df is None or len(positions_df) == 0:
        return """
<div class="section">
<h2>Current Positions</h2>
<div class="info">No open positions at end of backtest.</div>
</div>
        """

        positions_html = ""
        for pos in positions_df.to_dicts():
        positions_html += f"""
<tr>
<td>{pos["asset_id"]}</td>
<td>{pos["quantity"]:.2f}</td>
<td>${pos["cost_basis"]:.2f}</td>
<td>${pos["last_price"]:.2f}</td>
<td>${pos["market_value"]:.2f}</td>
<td class="{" positive" if pos["unrealized_pnl"] >= 0 else "negative"}">${pos["unrealized_pnl"]:.2f}
</td>
<td class="{" positive" if pos["total_pnl"] >= 0 else "negative"}">${pos["total_pnl"]:.2f}</td>
        </tr>
        """

        return f"""
<div class="section">
<h2>Current Positions</h2>

<div class="table-container">
    <table>
        <thead>
            <tr>
                <th>Asset</th>
                <th>Quantity</th>
                <th>Cost Basis</th>
                <th>Last Price</th>
                <th>Market Value</th>
                <th>Unrealized P&L</th>
                <th>Total P&L</th>
            </tr>
        </thead>
        <tbody>
            {positions_html}
        </tbody>
    </table>
</div>
</div>
        """

        def _generate_risk_section(self, report_data: dict[str, Any]) -> str:
        """Generate risk metrics section."""
        risk = report_data.get("risk", {})

        return f"""
<div class="section">
<h2>Risk Metrics</h2>

<div class="metrics-grid">
    <div class="metric-card">
        <div class="metric-label">Max Leverage</div>
        <div class="metric-value">
            {risk.get("max_leverage", 1.0):.2f}x
        </div>
    </div>

    <div class="metric-card">
        <div class="metric-label">Max Concentration</div>
        <div class="metric-value">
            {risk.get("max_concentration", 0.0):.2%}
        </div>
    </div>
</div>

<div class="warning">
    <strong>Risk Disclaimer:</strong>
    Past performance does not guarantee future results.
    All trading involves risk of loss.
</div>
</div>
        """

        def _generate_footer(self, report_data: dict[str, Any]) -> str:
        """Generate report footer."""
        return f"""
<div class="footer">
Report generated by QEngine Backtesting Framework
<br>
Generated at: {report_data["metadata"]["generated_at"]}
</div>
        """

        def _generate_javascript(self, report_data: dict[str, Any]) -> str:
        """Generate JavaScript for interactive charts."""
        equity_df = report_data.get("equity_curve")

        if equity_df is None or len(equity_df) == 0:
        return "// No data available for charts"

        # Convert DataFrame to JSON for JavaScript
        equity_data = equity_df.to_dicts()

        # Convert datetime objects to strings for JSON serialization
        for item in equity_data:
        if "timestamp" in item:
        item["timestamp"] = item["timestamp"].isoformat()

        return f"""
        // Equity curve chart
        const equityData = {json.dumps(equity_data)};

        const equityTrace = {{
        x: equityData.map(d => d.timestamp),
        y: equityData.map(d => d.equity),
        type: 'scatter',
        mode: 'lines',
        name: 'Equity',
        line: {{
        color: '#667eea',
        width: 2
        }}
        }};

        const equityLayout = {{
        title: 'Equity Curve',
        xaxis: {{ title: 'Date' }},
        yaxis: {{ title: 'Portfolio Value ($)' }},
        margin: {{ t: 50 }}
        }};

        Plotly.newPlot('equity-curve-chart', [equityTrace], equityLayout);

        // Returns chart
        const returnsTrace = {{
        x: equityData.map(d => d.timestamp).slice(1),
        y: equityData.map(d => d.returns).slice(1),
        type: 'scatter',
        mode: 'markers',
        name: 'Daily Returns',
        marker: {{
        color: equityData.map(d => d.returns > 0 ? '#28a745' : '#dc3545').slice(1),
        size: 4
        }}
        }};

        const returnsLayout = {{
        title: 'Daily Returns Distribution',
        xaxis: {{ title: 'Date' }},
        yaxis: {{ title: 'Daily Return' }},
        margin: {{ t: 50 }}
        }};

        Plotly.newPlot('returns-chart', [returnsTrace], returnsLayout);
        """
        </file>

<file path="src/qengine/reporting/parquet.py">
"""Parquet report generation for QEngine backtests."""

import json
from pathlib import Path
from typing import Any

import polars as pl

from qengine.portfolio.accounting import PortfolioAccounting
from qengine.reporting.base import ReportGenerator


class ParquetReportGenerator(ReportGenerator):
"""
Generates Parquet-based reports for backtest results.

Creates structured data files optimized for:
- Data science workflows
- Further analysis with Polars/Pandas
- Integration with data pipelines
- Long-term storage and archival
"""

def generate(
self,
accounting: PortfolioAccounting,
strategy_params: dict[str, Any] | None = None,
backtest_params: dict[str, Any] | None = None,
) -> Path:
"""
Generate Parquet report from portfolio accounting data.

Args:
accounting: Portfolio accounting with results
strategy_params: Strategy configuration parameters
backtest_params: Backtest configuration parameters

Returns:
Path to generated report directory
"""
# Create report directory
report_dir = self.output_dir / f"{self.report_name}_parquet"
report_dir.mkdir(exist_ok=True)

# Prepare report data
report_data = self._prepare_report_data(accounting, strategy_params, backtest_params)

# Save metadata as JSON
self._save_metadata(report_data, report_dir)

# Save performance metrics
self._save_performance_metrics(report_data, report_dir)

# Save time series data
self._save_equity_curve(report_data, report_dir)

# Save trades data
self._save_trades(report_data, report_dir)

# Save positions data
self._save_positions(report_data, report_dir)

# Create summary file
self._create_summary_file(report_data, report_dir)

return report_dir

def _save_metadata(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Save metadata and configuration as JSON."""
metadata = {
"report_info": report_data["metadata"],
"backtest_config": {
"strategy_params": report_data["metadata"].get("strategy_params", {}),
"backtest_params": report_data["metadata"].get("backtest_params", {}),
},
"portfolio_config": report_data["portfolio"],
"file_manifest": {
"metadata": "metadata.json",
"performance": "performance_metrics.parquet",
"equity_curve": "equity_curve.parquet",
"trades": "trades.parquet",
"positions": "positions.parquet",
"summary": "summary.parquet",
},
}

metadata_path = report_dir / "metadata.json"
with open(metadata_path, "w") as f:
json.dump(metadata, f, indent=2, default=str)

def _save_performance_metrics(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Save performance metrics as Parquet."""
# Combine all performance data
metrics_data = []

# Performance metrics
for key, value in report_data["performance"].items():
metrics_data.append(
{
"category": "performance",
"metric": key,
"value": float(value) if isinstance(value, (int, float)) else str(value),
"format": "percentage"
if "return" in key or "rate" in key
else "currency"
if "pnl" in key
else "number",
},
)

# Cost metrics
for key, value in report_data["costs"].items():
metrics_data.append(
{
"category": "costs",
"metric": key,
"value": float(value) if isinstance(value, (int, float)) else str(value),
"format": "currency" if "commission" in key or "slippage" in key else "number",
},
)

# Risk metrics
for key, value in report_data["risk"].items():
metrics_data.append(
{
"category": "risk",
"metric": key,
"value": float(value) if isinstance(value, (int, float)) else str(value),
"format": "percentage" if "concentration" in key else "number",
},
)

# Portfolio metrics
for key, value in report_data["portfolio"].items():
metrics_data.append(
{
"category": "portfolio",
"metric": key,
"value": float(value) if isinstance(value, (int, float)) else str(value),
"format": "currency" if "cash" in key or "equity" in key else "number",
},
)

metrics_df = pl.DataFrame(metrics_data)
metrics_path = report_dir / "performance_metrics.parquet"
metrics_df.write_parquet(metrics_path)

def _save_equity_curve(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Save equity curve as Parquet."""
equity_df = report_data.get("equity_curve")

if equity_df is not None and len(equity_df) > 0:
# Add derived metrics
enhanced_df = equity_df.with_columns(
[
# Cumulative returns
pl.col("returns").cum_sum().alias("cumulative_returns"),
# Running maximum for drawdown calculation
pl.col("equity").cum_max().alias("running_max"),
# Drawdown
((pl.col("equity") / pl.col("equity").cum_max()) - 1).alias("drawdown"),
# Volatility (rolling 30-day)
pl.col("returns").rolling_std(window_size=30).alias("rolling_volatility_30d"),
# Rolling Sharpe (annualized)
(
pl.col("returns").rolling_mean(window_size=30)
/ pl.col("returns").rolling_std(window_size=30)
* (252**0.5)
).alias("rolling_sharpe_30d"),
],
)

equity_path = report_dir / "equity_curve.parquet"
enhanced_df.write_parquet(equity_path)
else:
# Create empty DataFrame with schema
empty_df = pl.DataFrame(
{
"timestamp": [],
"equity": [],
"returns": [],
"cumulative_returns": [],
"running_max": [],
"drawdown": [],
"rolling_volatility_30d": [],
"rolling_sharpe_30d": [],
},
schema={
"timestamp": pl.Datetime,
"equity": pl.Float64,
"returns": pl.Float64,
"cumulative_returns": pl.Float64,
"running_max": pl.Float64,
"drawdown": pl.Float64,
"rolling_volatility_30d": pl.Float64,
"rolling_sharpe_30d": pl.Float64,
},
)
empty_df.write_parquet(report_dir / "equity_curve.parquet")

def _save_trades(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Save trades data as Parquet."""
trades_df = report_data.get("trades")

if trades_df is not None and len(trades_df) > 0:
# Add derived columns for analysis
enhanced_df = trades_df.with_columns(
[
# Notional value
(pl.col("quantity") * pl.col("price")).alias("notional_value"),
# Commission rate
(pl.col("commission") / (pl.col("quantity") * pl.col("price"))).alias(
"commission_rate",
),
# Slippage rate
(pl.col("slippage") / (pl.col("quantity") * pl.col("price"))).alias(
"slippage_rate",
),
# Trade direction
pl.when(pl.col("side") == "buy").then(1).otherwise(-1).alias("direction"),
# Time-based features
pl.col("timestamp").dt.hour().alias("hour_of_day"),
pl.col("timestamp").dt.day().alias("day_of_month"),
pl.col("timestamp").dt.weekday().alias("day_of_week"),
# Size categories
pl.when(pl.col("quantity") * pl.col("price")
<
1000)
.then(pl.lit("small"))
.when(pl.col("quantity") * pl.col("price")
<
10000)
.then(pl.lit("medium"))
.otherwise(pl.lit("large"))
.alias("trade_size_category"),
],
)

trades_path = report_dir / "trades.parquet"
enhanced_df.write_parquet(trades_path)
else:
# Create empty DataFrame with schema
empty_df = pl.DataFrame(
{
"timestamp": [],
"order_id": [],
"trade_id": [],
"asset_id": [],
"side": [],
"quantity": [],
"price": [],
"commission": [],
"slippage": [],
"total_cost": [],
"notional_value": [],
"commission_rate": [],
"slippage_rate": [],
"direction": [],
"hour_of_day": [],
"day_of_month": [],
"day_of_week": [],
"trade_size_category": [],
},
schema={
"timestamp": pl.Datetime,
"order_id": pl.Utf8,
"trade_id": pl.Utf8,
"asset_id": pl.Utf8,
"side": pl.Utf8,
"quantity": pl.Float64,
"price": pl.Float64,
"commission": pl.Float64,
"slippage": pl.Float64,
"total_cost": pl.Float64,
"notional_value": pl.Float64,
"commission_rate": pl.Float64,
"slippage_rate": pl.Float64,
"direction": pl.Int8,
"hour_of_day": pl.UInt32,
"day_of_month": pl.UInt32,
"day_of_week": pl.UInt32,
"trade_size_category": pl.Utf8,
},
)
empty_df.write_parquet(report_dir / "trades.parquet")

def _save_positions(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Save positions data as Parquet."""
positions_df = report_data.get("positions")

if positions_df is not None and len(positions_df) > 0:
# Add derived columns
enhanced_df = positions_df.with_columns(
[
# Position direction
pl.when(pl.col("quantity") > 0)
.then(pl.lit("long"))
.when(pl.col("quantity")
<
0)
.then(pl.lit("short"))
.otherwise(pl.lit("flat"))
.alias("position_type"),
# Average cost per share
(pl.col("cost_basis") / pl.col("quantity")).alias("avg_cost_per_share"),
# Unrealized return percentage
(pl.col("unrealized_pnl") / pl.col("cost_basis")).alias(
"unrealized_return_pct",
),
# Total return percentage
(pl.col("total_pnl") / pl.col("cost_basis")).alias("total_return_pct"),
# Position weight (would need portfolio value for this)
pl.col("market_value").alias("position_weight_placeholder"),
],
)

positions_path = report_dir / "positions.parquet"
enhanced_df.write_parquet(positions_path)
else:
# Create empty DataFrame with schema
empty_df = pl.DataFrame(
{
"asset_id": [],
"quantity": [],
"cost_basis": [],
"last_price": [],
"market_value": [],
"unrealized_pnl": [],
"realized_pnl": [],
"total_pnl": [],
"position_type": [],
"avg_cost_per_share": [],
"unrealized_return_pct": [],
"total_return_pct": [],
"position_weight_placeholder": [],
},
schema={
"asset_id": pl.Utf8,
"quantity": pl.Float64,
"cost_basis": pl.Float64,
"last_price": pl.Float64,
"market_value": pl.Float64,
"unrealized_pnl": pl.Float64,
"realized_pnl": pl.Float64,
"total_pnl": pl.Float64,
"position_type": pl.Utf8,
"avg_cost_per_share": pl.Float64,
"unrealized_return_pct": pl.Float64,
"total_return_pct": pl.Float64,
"position_weight_placeholder": pl.Float64,
},
)
empty_df.write_parquet(report_dir / "positions.parquet")

def _create_summary_file(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Create a summary file with key statistics."""
summary_data = [
{
"report_name": report_data["metadata"]["report_name"],
"generated_at": report_data["metadata"]["generated_at"],
"total_return": report_data["performance"]["total_return"],
"total_pnl": report_data["performance"]["total_pnl"],
"sharpe_ratio": report_data["performance"].get("sharpe_ratio", None),
"max_drawdown": report_data["performance"]["max_drawdown"],
"win_rate": report_data["performance"]["win_rate"],
"num_trades": report_data["performance"]["num_trades"],
"total_commission": report_data["costs"]["total_commission"],
"total_slippage": report_data["costs"]["total_slippage"],
"initial_capital": report_data["portfolio"]["initial_cash"],
"final_equity": report_data["portfolio"]["final_equity"],
"max_leverage": report_data["risk"]["max_leverage"],
"max_concentration": report_data["risk"]["max_concentration"],
},
]

summary_df = pl.DataFrame(summary_data)
summary_path = report_dir / "summary.parquet"
summary_df.write_parquet(summary_path)

def load_report(self, report_dir: Path) -> dict[str, Any]:
"""
Load a previously generated Parquet report.

Args:
report_dir: Directory containing the Parquet report

Returns:
Dictionary with loaded report data
"""
if not report_dir.exists():
raise FileNotFoundError(f"Report directory not found: {report_dir}")

# Load metadata
metadata_path = report_dir / "metadata.json"
with open(metadata_path) as f:
metadata = json.load(f)

# Load data files
report_data = {
"metadata": metadata,
"performance_metrics": pl.read_parquet(report_dir / "performance_metrics.parquet"),
"equity_curve": pl.read_parquet(report_dir / "equity_curve.parquet"),
"trades": pl.read_parquet(report_dir / "trades.parquet"),
"positions": pl.read_parquet(report_dir / "positions.parquet"),
"summary": pl.read_parquet(report_dir / "summary.parquet"),
}

return report_data
</file>

<file path="src/qengine/reporting/reporter.py">
"""Reporter implementations for capturing backtest events and results."""

import logging
from datetime import datetime
from typing import Any, Optional

from qengine.core.event import Event

logger = logging.getLogger(__name__)


class Reporter:
"""Abstract base class for reporters."""

def on_start(self) -> None:
"""Called at start of backtest."""

def on_event(self, event: Event) -> None:
"""Called for each event processed."""

def on_end(self) -> None:
"""Called at end of backtest."""

def reset(self) -> None:
"""Reset reporter state."""

def get_report(self) -> Any:
"""Get the generated report."""


class InMemoryReporter(Reporter):
"""Reporter that stores all events and results in memory.

This reporter captures:
- All events processed during backtest
- Timestamps and event counts
- Summary statistics

Useful for debugging and analysis of backtest execution.
"""

def __init__(self, capture_all_events: bool = False):
"""Initialize in-memory reporter.

Args:
capture_all_events: If True, store all events (can use significant memory)
"""
self.capture_all_events = capture_all_events
self.events = []
self.event_counts = {}
self.start_time: datetime | None = None
self.end_time: datetime | None = None
self.first_event_time: datetime | None = None
self.last_event_time: datetime | None = None

def on_start(self) -> None:
"""Mark start of backtest."""
self.start_time = datetime.now()
logger.debug("InMemoryReporter started")

def on_event(self, event: Event) -> None:
"""Capture event details.

Args:
event: Event to record
"""
# Track event counts by type
event_type = (
event.event_type.value if hasattr(event.event_type, "value") else str(event.event_type)
)
self.event_counts[event_type] = self.event_counts.get(event_type, 0) + 1

# Track first and last event timestamps
if self.first_event_time is None:
self.first_event_time = event.timestamp
self.last_event_time = event.timestamp

# Optionally store full event
if self.capture_all_events:
self.events.append(
{
"timestamp": event.timestamp,
"type": event_type,
"event": event,
},
)

def on_end(self) -> None:
"""Mark end of backtest."""
self.end_time = datetime.now()
logger.debug(f"InMemoryReporter finished. Total events: {sum(self.event_counts.values())}")

def get_report(self) -> dict[str, Any]:
"""Get summary report of captured events.

Returns:
Dictionary with event statistics and timing information
"""
total_events = sum(self.event_counts.values())
duration = (
(self.end_time - self.start_time).total_seconds()
if self.end_time and self.start_time
else 0
)

report = {
"summary": {
"total_events": total_events,
"event_types": len(self.event_counts),
"duration_seconds": duration,
"events_per_second": total_events / duration if duration > 0 else 0,
},
"event_counts": self.event_counts,
"timing": {
"start_time": self.start_time.isoformat() if self.start_time else None,
"end_time": self.end_time.isoformat() if self.end_time else None,
"first_event": self.first_event_time.isoformat() if self.first_event_time else None,
"last_event": self.last_event_time.isoformat() if self.last_event_time else None,
},
}

if self.capture_all_events:
report["events"] = self.events

# Add event type breakdown
if self.event_counts:
report["breakdown"] = {
event_type: {
"count": count,
"percentage": (count / total_events * 100) if total_events > 0 else 0,
}
for event_type, count in self.event_counts.items()
}

return report

def reset(self) -> None:
"""Reset reporter to initial state."""
self.events.clear()
self.event_counts.clear()
self.start_time = None
self.end_time = None
self.first_event_time = None
self.last_event_time = None


class ConsoleReporter(Reporter):
"""Reporter that logs events to console.

Useful for real-time monitoring of backtest progress.
"""

def __init__(self, log_level: str = "INFO", log_every_n: int = 1000):
"""Initialize console reporter.

Args:
log_level: Logging level (DEBUG, INFO, WARNING, ERROR)
log_every_n: Log summary every N events
"""
self.log_level = getattr(logging, log_level.upper(), logging.INFO)
self.log_every_n = log_every_n
self.event_count = 0
self.event_counts = {}

def on_start(self) -> None:
"""Log backtest start."""
logger.log(self.log_level, "=" * 60)
logger.log(self.log_level, "BACKTEST STARTED")
logger.log(self.log_level, "=" * 60)

def on_event(self, event: Event) -> None:
"""Log event if appropriate.

Args:
event: Event to potentially log
"""
self.event_count += 1
event_type = (
event.event_type.value if hasattr(event.event_type, "value") else str(event.event_type)
)
self.event_counts[event_type] = self.event_counts.get(event_type, 0) + 1

# Log periodic summary
if self.event_count % self.log_every_n == 0:
logger.log(
self.log_level,
f"Processed {self.event_count:,} events. "
f"Latest: {event.timestamp} | "
f"Types: {dict(sorted(self.event_counts.items()))}",
)

def on_end(self) -> None:
"""Log backtest completion."""
logger.log(self.log_level, "=" * 60)
logger.log(self.log_level, "BACKTEST COMPLETED")
logger.log(self.log_level, f"Total Events: {self.event_count:,}")
logger.log(self.log_level, f"Event Breakdown: {dict(sorted(self.event_counts.items()))}")
logger.log(self.log_level, "=" * 60)

def reset(self) -> None:
"""Reset reporter state."""
self.event_count = 0
self.event_counts.clear()

def get_report(self) -> dict[str, Any]:
"""Get simple report for console reporter.

Returns:
Event count summary
"""
return {
"total_events": self.event_count,
"event_counts": self.event_counts,
}


__all__ = [
"ConsoleReporter",
"InMemoryReporter",
"Reporter",
]
</file>

<file path="src/qengine/strategy/__init__.py">
"""Strategy framework for QEngine."""

from qengine.strategy.adapters import (
DataFrameAdapter,
ExternalStrategyInterface,
PITData,
StrategyAdapter,
StrategySignal,
)
from qengine.strategy.base import Strategy
from qengine.strategy.crypto_basis_adapter import (
CryptoBasisAdapter,
CryptoBasisExternalStrategy,
create_crypto_basis_strategy,
)

__all__ = [
"CryptoBasisAdapter",
"CryptoBasisExternalStrategy",
"DataFrameAdapter",
"ExternalStrategyInterface",
"PITData",
"Strategy",
"StrategyAdapter",
"StrategySignal",
"create_crypto_basis_strategy",
]
</file>

<file path="src/qengine/strategy/adapters.py">
"""
Strategy-QEngine Integration Bridge
==================================

This module provides adapters that bridge external strategy implementations
to QEngine's event-driven architecture. It allows existing strategies to run
within QEngine and benefit from advanced execution models.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Callable, Optional

import polars as pl

from qengine.core.event import Event, FillEvent, MarketEvent
from qengine.core.types import AssetId, OrderSide, OrderType, Price
from qengine.execution.order import Order
from qengine.strategy.base import Strategy


@dataclass
class PITData:
"""Point-in-time data snapshot for strategy decision making."""

timestamp: datetime
asset_data: dict[AssetId, dict[str, Any]]
market_prices: dict[AssetId, Price]

def get_price(self, asset_id: AssetId) -> Price | None:
"""Get current price for asset."""
return self.market_prices.get(asset_id)

def get_data(self, asset_id: AssetId, field: str) -> Any:
"""Get specific field for asset."""
return self.asset_data.get(asset_id, {}).get(field)


@dataclass
class StrategySignal:
"""Signal generated by external strategy."""

timestamp: datetime
asset_id: AssetId
position: float # Target position (-1 to 1, or absolute quantities)
confidence: float = 0.0
metadata: dict[str, Any] = None

def __post_init__(self):
if self.metadata is None:
self.metadata = {}


class ExternalStrategyInterface(ABC):
"""
Interface that external strategies must implement to integrate with QEngine.

This defines the minimal API needed for QEngine integration.
"""

@abstractmethod
def generate_signal(
self,
timestamp: datetime,
pit_data: PITData,
) -> StrategySignal | None:
"""
Generate trading signal based on point-in-time data.

Args:
timestamp: Current timestamp
pit_data: Point-in-time data snapshot

Returns:
Trading signal or None if no action needed
"""

@abstractmethod
def initialize(self) -> None:
"""Initialize strategy state."""

@abstractmethod
def finalize(self) -> None:
"""Cleanup strategy state."""


class StrategyAdapter(Strategy):
"""
Base adapter that bridges external strategies to QEngine.

This class handles the translation between QEngine's event-driven architecture
and external strategy APIs.
"""

def __init__(
self,
external_strategy: ExternalStrategyInterface,
position_sizer: Callable[[StrategySignal, float], float] | None = None,
risk_manager: Callable[[StrategySignal], bool] | None = None,
name: str | None = None,
):
"""
Initialize strategy adapter.

Args:
external_strategy: External strategy implementation
position_sizer: Optional position sizing function
risk_manager: Optional risk management function
name: Strategy name
"""
super().__init__(name=name or f"Adapter_{external_strategy.__class__.__name__}")
self.external_strategy = external_strategy
self.position_sizer = position_sizer or self._default_position_sizer
self.risk_manager = risk_manager or self._default_risk_manager

# State tracking
self._data_history: dict[AssetId, list[dict]] = {}
self._last_signals: dict[AssetId, StrategySignal] = {}
self._target_positions: dict[AssetId, float] = {}
self._pending_orders: dict[AssetId, list[Order]] = {}

def on_start(self) -> None:
"""Initialize external strategy."""
self.log("Starting strategy adapter")
self.external_strategy.initialize()

def on_end(self) -> None:
"""Cleanup external strategy."""
self.log("Stopping strategy adapter")
self.external_strategy.finalize()

def on_event(self, event: Event) -> None:
"""Route events to appropriate handlers."""
if isinstance(event, MarketEvent):
self.on_market_event(event)
elif isinstance(event, FillEvent):
self.on_fill_event(event)

def on_market_event(self, event: MarketEvent) -> None:
"""Process market event and generate signals."""
try:
# Update data history
self._update_data_history(event)

# Create point-in-time data snapshot
pit_data = self._create_pit_data(event.timestamp)

# Generate signal from external strategy
signal = self.external_strategy.generate_signal(event.timestamp, pit_data)

if signal:
self._process_signal(signal)

except Exception as e:
self.log(f"Error processing market event: {e}", level="ERROR")

def on_fill_event(self, event: FillEvent) -> None:
"""Update position tracking when fills occur."""
super().on_fill_event(event)

# Remove filled orders from pending
if event.asset_id in self._pending_orders:
self._pending_orders[event.asset_id] = [
order
for order in self._pending_orders[event.asset_id]
if order.order_id != event.order_id
]

self.log(f"Fill received: {event.asset_id} {event.fill_quantity} @ {event.fill_price}")

def _update_data_history(self, event: MarketEvent) -> None:
"""Update historical data for strategy calculations."""
if event.asset_id not in self._data_history:
self._data_history[event.asset_id] = []

data_point = {
"timestamp": event.timestamp,
"open": event.open,
"high": event.high,
"low": event.low,
"close": event.close,
"volume": event.volume,
}

self._data_history[event.asset_id].append(data_point)

# Keep only last N points for memory efficiency
if len(self._data_history[event.asset_id]) > 1000:
self._data_history[event.asset_id] = self._data_history[event.asset_id][-500:]

def _create_pit_data(self, timestamp: datetime) -> PITData:
"""Create point-in-time data snapshot."""
asset_data = {}
market_prices = {}

for asset_id, history in self._data_history.items():
if history:
# Get most recent data up to timestamp
valid_data = [d for d in history if d["timestamp"]<= timestamp]
if valid_data:
latest = valid_data[-1]
asset_data[asset_id] = latest
market_prices[asset_id] = latest["close"]

return PITData(
timestamp=timestamp,
asset_data=asset_data,
market_prices=market_prices,
)

def _process_signal(self, signal: StrategySignal) -> None:
"""Process signal and submit orders if needed."""
# Store last signal
self._last_signals[signal.asset_id] = signal

# Apply risk management
if not self.risk_manager(signal):
self.log(f"Signal rejected by risk manager: {signal.asset_id}", level="WARNING")
return

# Calculate position size
current_cash = self.broker.get_cash() if hasattr(self.broker, "get_cash") else 100000
position_size = self.position_sizer(signal, current_cash)

# Get current position
current_position = self._positions.get(signal.asset_id, 0)

# Calculate required trade
trade_quantity = position_size - current_position

if abs(trade_quantity) > 0.001: # Minimum trade threshold
self._submit_rebalance_order(signal.asset_id, trade_quantity)

def _submit_rebalance_order(self, asset_id: AssetId, quantity: float) -> None:
"""Submit order to rebalance to target position."""
if abs(quantity)
<
0.001:
return

# Determine order side
side = OrderSide.BUY if quantity > 0 else OrderSide.SELL
abs_quantity = abs(quantity)

# Create market order for immediate execution
order = Order(
asset_id=asset_id,
order_type=OrderType.MARKET,
side=side,
quantity=abs_quantity,
)

# Submit through broker
if hasattr(self.broker, "submit_order"):
order_id = self.broker.submit_order(order)

# Track pending order
if asset_id not in self._pending_orders:
self._pending_orders[asset_id] = []
self._pending_orders[asset_id].append(order)

self.log(f"Order submitted: {order_id} - {side.value} {abs_quantity} {asset_id}")
else:
self.log("No broker available for order submission", level="ERROR")

def _default_position_sizer(self, signal: StrategySignal, cash: float) -> float:
"""Default position sizing based on signal position and confidence."""
# Use signal position directly, scaled by confidence
base_position = signal.position * signal.confidence

# Simple position sizing - use portion of cash based on signal
if abs(base_position) > 0:
position_value = cash * 0.1 # 10% of cash
return base_position * position_value # Signed position value

return 0.0

def _default_risk_manager(self, signal: StrategySignal) -> bool:
"""Default risk management - always allow signals."""
# Basic checks
if not signal.asset_id:
return False
if abs(signal.position) > 10: # Sanity check on position size
return False
return True

def get_strategy_state(self) -> dict[str, Any]:
"""Get current strategy state for debugging."""
return {
"name": self.name,
"current_positions": self.current_positions,
"target_positions": self._target_positions.copy(),
"last_signals": {k: v.__dict__ for k, v in self._last_signals.items()},
"pending_orders": {k: len(v) for k, v in self._pending_orders.items()},
"data_history_lengths": {k: len(v) for k, v in self._data_history.items()},
}


class DataFrameAdapter(StrategyAdapter):
"""
Adapter for strategies that work with DataFrame-based data.

This adapter maintains a rolling DataFrame of market data that can be
accessed by external strategies for calculations.
"""

def __init__(
self,
external_strategy: ExternalStrategyInterface,
window_size: int = 1000,
**kwargs,
):
"""
Initialize DataFrame adapter.

Args:
external_strategy: External strategy implementation
window_size: Size of rolling data window
**kwargs: Additional arguments for StrategyAdapter
"""
super().__init__(external_strategy, **kwargs)
self.window_size = window_size
self._dataframes: dict[AssetId, pl.DataFrame] = {}

def _update_data_history(self, event: MarketEvent) -> None:
"""Update DataFrame with new market data."""
# Call parent to maintain backward compatibility
super()._update_data_history(event)

# Create new row
new_row = pl.DataFrame(
{
"timestamp": [event.timestamp],
"asset_id": [event.asset_id],
"open": [event.open],
"high": [event.high],
"low": [event.low],
"close": [event.close],
"volume": [event.volume],
},
)

# Update or create DataFrame
if event.asset_id not in self._dataframes:
self._dataframes[event.asset_id] = new_row
else:
self._dataframes[event.asset_id] = pl.concat(
[
self._dataframes[event.asset_id],
new_row,
],
)

# Maintain window size
if len(self._dataframes[event.asset_id]) > self.window_size:
self._dataframes[event.asset_id] = self._dataframes[event.asset_id].tail(
self.window_size,
)

def get_dataframe(self, asset_id: AssetId) -> pl.DataFrame | None:
"""Get DataFrame for asset."""
return self._dataframes.get(asset_id)

def get_all_dataframes(self) -> dict[AssetId, pl.DataFrame]:
"""Get all DataFrames."""
return self._dataframes.copy()
</file>

<file path="src/qengine/strategy/base.py">
"""Base strategy class and interfaces for QEngine."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any

from qengine.core.event import Event, FillEvent, MarketEvent, SignalEvent
from qengine.core.types import AssetId, EventType, OrderSide


class StrategyState(Enum):
"""Strategy lifecycle states."""

INITIALIZED = "initialized"
STARTING = "starting"
RUNNING = "running"
STOPPING = "stopping"
STOPPED = "stopped"


@dataclass
class StrategyContext:
"""Context object containing strategy runtime information."""

start_time: datetime
end_time: datetime
initial_capital: float
commission_model: Any | None = None
slippage_model: Any | None = None
data_feeds: list[Any] = field(default_factory=list)
parameters: dict[str, Any] = field(default_factory=dict)


class Strategy(ABC):
"""
Abstract base class for all trading strategies.

This class defines the interface that all strategies must implement.
Strategies receive events through the on_event method and can submit
orders through the broker interface.
"""

def __init__(self, name: str | None = None):
"""
Initialize the strategy.

Args:
name: Optional name for the strategy
"""
self.name = name or self.__class__.__name__
self.state = StrategyState.INITIALIZED
self.broker = None # Will be injected by the engine
self.data = None # PIT data accessor
self.context = None # Strategy context
self._subscriptions: set[tuple] = set()
self._positions: dict[AssetId, float] = {}
self._orders: list[Any] = []
self._trades: list[Any] = []

def on_start(self) -> None:
"""
Called once when the strategy starts.

Override this method to perform one-time initialization tasks like:
- Setting up indicators
- Subscribing to data feeds
- Initializing internal state
"""

@abstractmethod
def on_event(self, event: Event) -> None:
"""
Process an event.

This is the main method where strategy logic is implemented.
It's called for every event the strategy is subscribed to.

Args:
event: The event to process
"""

def on_market_event(self, event: MarketEvent) -> None:
"""
Process a market data event.

Override this for specialized market data handling.

Args:
event: Market data event
"""

def on_signal_event(self, event: SignalEvent) -> None:
"""
Process an ML signal event.

Override this for signal-based strategies.

Args:
event: Signal event from ML model
"""

def on_fill_event(self, event: FillEvent) -> None:
"""
Process an order fill event.

Override this to track fills and update internal state.

Args:
event: Fill event
"""
# Default implementation updates position tracking
if event.side in [OrderSide.BUY, OrderSide.COVER]:
self._positions[event.asset_id] = (
self._positions.get(event.asset_id, 0) + event.fill_quantity
)
else:
self._positions[event.asset_id] = (
self._positions.get(event.asset_id, 0) - event.fill_quantity
)

def on_end(self) -> None:
"""
Called once when the strategy stops.

Override this to perform cleanup tasks like:
- Closing positions
- Saving state
- Final analysis
"""

def before_trading_start(self) -> None:
"""
Called before the start of each trading day.

Override this for daily preparation tasks like:
- Updating universe
- Recalculating signals
- Adjusting parameters
"""

def after_trading_end(self) -> None:
"""
Called after the end of each trading day.

Override this for end-of-day tasks like:
- Recording metrics
- Rebalancing
- Risk calculations
"""

def subscribe(
self,
asset: AssetId | None = None,
event_type: EventType | None = None,
**kwargs,
) -> None:
"""
Subscribe to specific events.

Args:
asset: Asset to subscribe to (None for all)
event_type: Type of events to receive
**kwargs: Additional subscription parameters
"""
subscription = (asset, event_type, tuple(kwargs.items()))
self._subscriptions.add(subscription)

def unsubscribe(
self,
asset: AssetId | None = None,
event_type: EventType | None = None,
**kwargs,
) -> None:
"""
Unsubscribe from specific events.

Args:
asset: Asset to unsubscribe from
event_type: Type of events to stop receiving
**kwargs: Additional parameters
"""
subscription = (asset, event_type, tuple(kwargs.items()))
self._subscriptions.discard(subscription)

@property
def current_positions(self) -> dict[AssetId, float]:
"""Get current position quantities by asset."""
return self._positions.copy()

@property
def is_flat(self) -> bool:
"""Check if strategy has no positions."""
return all(qty == 0 for qty in self._positions.values())

def log(self, message: str, level: str = "INFO") -> None:
"""
Log a message.

Args:
message: Message to log
level: Log level (INFO, WARNING, ERROR, DEBUG)
"""
timestamp = datetime.now().isoformat()
print(f"[{timestamp}] [{self.name}] [{level}] {message}")

def __repr__(self) -> str:
return f"{self.__class__.__name__}(name='{self.name}', state={self.state})"


class SignalStrategy(Strategy):
"""
Base class for signal-based strategies.

This provides a simpler interface for strategies that primarily
react to ML signals rather than raw market data.
"""

def __init__(self, name: str | None = None, signal_threshold: float = 0.5):
"""
Initialize signal strategy.

Args:
name: Strategy name
signal_threshold: Threshold for acting on signals
"""
super().__init__(name)
self.signal_threshold = signal_threshold
self._signal_history: dict[AssetId, list[float]] = {}

def on_event(self, event: Event) -> None:
"""Route events to appropriate handlers."""
if isinstance(event, SignalEvent):
self.on_signal_event(event)
elif isinstance(event, MarketEvent):
self.on_market_event(event)
elif isinstance(event, FillEvent):
self.on_fill_event(event)

def on_signal_event(self, event: SignalEvent) -> None:
"""
Process signal and make trading decision.

Args:
event: Signal event
"""
# Track signal history
if event.asset_id not in self._signal_history:
self._signal_history[event.asset_id] = []
self._signal_history[event.asset_id].append(event.signal_value)

# Make trading decision based on signal
self.process_signal(event.asset_id, event.signal_value, event.confidence)

@abstractmethod
def process_signal(
self,
asset_id: AssetId,
signal_value: float,
confidence: float | None,
) -> None:
"""
Process a signal and decide on action.

Args:
asset_id: Asset the signal is for
signal_value: Signal value (typically -1 to 1)
confidence: Optional confidence score
"""


class IndicatorStrategy(Strategy):
"""
Base class for indicator-based strategies.

Provides utilities for managing technical indicators.
"""

def __init__(self, name: str | None = None):
"""Initialize indicator strategy."""
super().__init__(name)
self._indicators: dict[str, Any] = {}

def add_indicator(self, name: str, indicator: Any) -> None:
"""
Add a technical indicator.

Args:
name: Name for the indicator
indicator: Indicator instance
"""
self._indicators[name] = indicator

def get_indicator(self, name: str) -> Any:
"""
Get an indicator by name.

Args:
name: Indicator name

Returns:
Indicator instance
"""
return self._indicators.get(name)

def update_indicators(self, price: float) -> None:
"""
Update all indicators with new price.

Args:
price: Latest price
"""
for indicator in self._indicators.values():
if hasattr(indicator, "update"):
indicator.update(price)
</file>

<file path="src/qengine/strategy/crypto_basis_adapter.py">
"""
Crypto Basis Strategy QEngine Adapter
=====================================

Adapter that integrates the CryptoBasisStrategy with QEngine's event-driven architecture.
This allows the basis trading strategy to run within QEngine and benefit from
advanced execution models, slippage simulation, and commission structures.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional

import numpy as np

from qengine.core.types import AssetId
from qengine.strategy.adapters import (
DataFrameAdapter,
ExternalStrategyInterface,
PITData,
StrategySignal,
)


@dataclass
class BasisState:
"""State tracking for basis calculations."""

spot_prices: list[float] = field(default_factory=list)
futures_prices: list[float] = field(default_factory=list)
timestamps: list[datetime] = field(default_factory=list)
basis_history: list[float] = field(default_factory=list)

# Rolling statistics
basis_mean: float | None = None
basis_std: float | None = None
current_z_score: float | None = None

# Position tracking
current_position: float = 0.0
entry_basis: float | None = None
entry_timestamp: datetime | None = None


class CryptoBasisExternalStrategy(ExternalStrategyInterface):
"""
External strategy implementation for crypto basis trading.

This wraps the original CryptoBasisStrategy logic in the interface
required for QEngine integration.
"""

def __init__(
self,
spot_asset_id: AssetId = "BTC",
futures_asset_id: AssetId = "BTC_FUTURE",
lookback_window: int = 120,
entry_threshold: float = 2.0,
exit_threshold: float = 0.5,
max_position: float = 0.3,
min_data_points: int = 50,
):
"""
Initialize crypto basis strategy.

Args:
spot_asset_id: Asset ID for spot prices
futures_asset_id: Asset ID for futures prices
lookback_window: Number of periods for rolling statistics
entry_threshold: Z-score threshold for entry
exit_threshold: Z-score threshold for exit
max_position: Maximum position size
min_data_points: Minimum data points before generating signals
"""
self.spot_asset_id = spot_asset_id
self.futures_asset_id = futures_asset_id
self.lookback_window = lookback_window
self.entry_threshold = entry_threshold
self.exit_threshold = exit_threshold
self.max_position = max_position
self.min_data_points = min_data_points

# State
self.state = BasisState()
self.volatility_lookback = 20

def initialize(self) -> None:
"""Initialize strategy state."""
self.state = BasisState()

def finalize(self) -> None:
"""Cleanup strategy state."""
# Log final statistics
if self.state.basis_history:
total_signals = len([b for b in self.state.basis_history if b != 0])
print(f"[CryptoBasisStrategy] Generated {total_signals} signals")
print(f"[CryptoBasisStrategy] Final position: {self.state.current_position}")

def generate_signal(
self,
timestamp: datetime,
pit_data: PITData,
) -> StrategySignal | None:
"""
Generate trading signal based on basis analysis.

Args:
timestamp: Current timestamp
pit_data: Point-in-time data snapshot

Returns:
Trading signal or None
"""
# Get current prices
spot_price = pit_data.get_price(self.spot_asset_id)
futures_price = pit_data.get_price(self.futures_asset_id)

if spot_price is None or futures_price is None:
return None

# Update state with new data
self._update_state(timestamp, spot_price, futures_price)

# Calculate current statistics if we have enough data
if len(self.state.basis_history) >= 2:
self._calculate_statistics()

# Need minimum data points for signal generation
if len(self.state.basis_history)
< self.min_data_points:
  return None

# Generate signal
signal = self._generate_basis_signal(timestamp)

return signal

def _update_state(
self,
timestamp: datetime,
spot_price: float,
futures_price: float,
) -> None:
"""Update internal state with new price data."""
# Calculate basis
basis = futures_price - spot_price

# Update history
self.state.timestamps.append(timestamp)
self.state.spot_prices.append(spot_price)
self.state.futures_prices.append(futures_price)
self.state.basis_history.append(basis)

# Maintain window size
if len(self.state.basis_history) > self.lookback_window:
self.state.timestamps = self.state.timestamps[-self.lookback_window :]
self.state.spot_prices = self.state.spot_prices[-self.lookback_window :]
self.state.futures_prices = self.state.futures_prices[-self.lookback_window :]
self.state.basis_history = self.state.basis_history[-self.lookback_window :]

def _calculate_statistics(self) -> None:
"""Calculate rolling statistics for basis."""
if len(self.state.basis_history)
<
2:
return

basis_array = np.array(self.state.basis_history)

# Rolling mean and std
self.state.basis_mean = np.mean(basis_array)
self.state.basis_std = np.std(basis_array)

# Current z-score
if self.state.basis_std > 1e-8: # Avoid division by zero
current_basis = self.state.basis_history[-1]
self.state.current_z_score = (
current_basis - self.state.basis_mean
) / self.state.basis_std
else:
self.state.current_z_score = 0.0

def _generate_basis_signal(self, timestamp: datetime) -> StrategySignal | None:
"""Generate trading signal based on basis z-score."""
if self.state.current_z_score is None:
return None

z_score = self.state.current_z_score
current_basis = self.state.basis_history[-1]

# Calculate volatility for position sizing
spot_returns = np.diff(np.log(self.state.spot_prices[-self.volatility_lookback :]))
volatility = np.std(spot_returns) if len(spot_returns) > 1 else 0.01

position = 0.0
confidence = 0.0

# Entry logic
if abs(self.state.current_position)
<
1e-6: # Flat position
if z_score > self.entry_threshold:
# Basis too high: short futures, long spot (negative position)
position = -1.0
confidence = min((z_score - self.entry_threshold) / 2, 1.0)
self.state.entry_basis = current_basis
self.state.entry_timestamp = timestamp

elif z_score
<
-self.entry_threshold:
# Basis too low: long futures, short spot (positive position)
position = 1.0
confidence = min((abs(z_score) - self.entry_threshold) / 2, 1.0)
self.state.entry_basis = current_basis
self.state.entry_timestamp = timestamp

# Exit logic
else:
if self.state.current_position > 0: # Long futures/short spot
if z_score > -self.exit_threshold: # Basis normalized
position = 0.0
confidence = 1.0
elif z_score > self.entry_threshold: # Reversal
position = -1.0
confidence = min((z_score - self.entry_threshold) / 2, 1.0)
else:
position = self.state.current_position # Hold

elif self.state.current_position
<
0: # Short futures/long spot
if z_score
< self.exit_threshold:
# Basis normalized
position = 0.0
confidence = 1.0
elif z_score
<
-self.entry_threshold: # Reversal
position = 1.0
confidence = min((abs(z_score) - self.entry_threshold) / 2, 1.0)
else:
position = self.state.current_position # Hold

# Apply volatility adjustment and position limits
if position != 0:
volatility_scalar = 1 / (1 + volatility * 10) # Reduce size in high vol
position = position * min(confidence * volatility_scalar, self.max_position)

# Update position state
old_position = self.state.current_position
self.state.current_position = position

# Only generate signal if position changed significantly
if abs(position - old_position) > 0.001:
return StrategySignal(
timestamp=timestamp,
asset_id=self.spot_asset_id, # Use spot as primary asset
position=position,
confidence=confidence,
metadata={
"basis": current_basis,
"z_score": z_score,
"volatility": volatility,
"entry_basis": self.state.entry_basis,
"strategy_type": "crypto_basis",
"spot_price": self.state.spot_prices[-1],
"futures_price": self.state.futures_prices[-1],
},
)

return None

def get_current_statistics(self) -> dict[str, float]:
"""Get current basis statistics for monitoring."""
if not self.state.basis_history:
return {}

return {
"current_basis": self.state.basis_history[-1],
"basis_mean": self.state.basis_mean or 0,
"basis_std": self.state.basis_std or 0,
"z_score": self.state.current_z_score or 0,
"current_position": self.state.current_position,
"data_points": len(self.state.basis_history),
}


class CryptoBasisAdapter(DataFrameAdapter):
"""
Complete adapter for crypto basis trading strategy.

This combines the external strategy with DataFrame support
and provides a complete QEngine integration.
"""

def __init__(
self,
spot_asset_id: AssetId = "BTC",
futures_asset_id: AssetId = "BTC_FUTURE",
lookback_window: int = 120,
entry_threshold: float = 2.0,
exit_threshold: float = 0.5,
max_position: float = 0.3,
position_scaling: float = 0.1,
window_size: int = 1000,
**kwargs,
):
"""
Initialize crypto basis adapter.

Args:
spot_asset_id: Asset ID for spot prices
futures_asset_id: Asset ID for futures prices
lookback_window: Rolling window for statistics
entry_threshold: Z-score threshold for entries
exit_threshold: Z-score threshold for exits
max_position: Maximum position size
position_scaling: Scaling factor for position size
**kwargs: Additional arguments for DataFrameAdapter
"""
# Create external strategy
external_strategy = CryptoBasisExternalStrategy(
spot_asset_id=spot_asset_id,
futures_asset_id=futures_asset_id,
lookback_window=lookback_window,
entry_threshold=entry_threshold,
exit_threshold=exit_threshold,
max_position=max_position,
)

# Create custom position sizer
def basis_position_sizer(signal: StrategySignal, cash: float) -> float:
# Scale position based on available cash and signal strength
base_value = cash * position_scaling # Use X% of cash
position_value = base_value * abs(signal.position) * signal.confidence

# Return signed position value
return position_value if signal.position > 0 else -position_value

# Filter kwargs for parent constructor
parent_kwargs = {
k: v for k, v in kwargs.items() if k in ["position_sizer", "risk_manager", "name"]
}

# Initialize adapter
super().__init__(
external_strategy=external_strategy,
window_size=window_size,
position_sizer=basis_position_sizer,
name=f"CryptoBasisAdapter_{spot_asset_id}_{futures_asset_id}",
**parent_kwargs,
)

# Store configuration
self.spot_asset_id = spot_asset_id
self.futures_asset_id = futures_asset_id
self._last_statistics = {}

# Event synchronization for multi-asset basis calculation
self._event_buffer: dict[datetime, dict[AssetId, MarketEvent]] = {}
self._required_assets = {spot_asset_id, futures_asset_id}

def on_start(self) -> None:
"""Start strategy and subscribe to data feeds."""
super().on_start()

# Subscribe to both spot and futures data
self.subscribe(asset=self.spot_asset_id, event_type="market")
self.subscribe(asset=self.futures_asset_id, event_type="market")

self.log(f"Subscribed to {self.spot_asset_id} (spot) and {self.futures_asset_id} (futures)")

def on_market_event(self, event) -> None:
"""Process market events with synchronization for basis calculation."""
# Buffer the event by timestamp and asset
if event.timestamp not in self._event_buffer:
self._event_buffer[event.timestamp] = {}

self._event_buffer[event.timestamp][event.asset_id] = event

# Check if we have both required assets for this timestamp
buffered_assets = set(self._event_buffer[event.timestamp].keys())

if self._required_assets.issubset(buffered_assets):
# We have both spot and futures data - process synchronously
self._process_synchronized_events(event.timestamp)

# Clean up old buffer entries (keep only last 10 timestamps)
timestamps = sorted(self._event_buffer.keys())
if len(timestamps) > 10:
for old_ts in timestamps[:-10]:
del self._event_buffer[old_ts]
else:
# Still waiting for the other asset - update both DataFrame and parent's history
super()._update_data_history(event)

def _process_synchronized_events(self, timestamp: datetime) -> None:
"""Process events when both spot and futures data are available."""
buffered_events = self._event_buffer[timestamp]

# Process both events to update DataFrames AND internal history
for event in buffered_events.values():
# Call parent's update which maintains _data_history dict
super()._update_data_history(event)

# Now create PITData - parent's _create_pit_data should have both prices now
try:
# Create point-in-time data snapshot with both prices
pit_data = self._create_pit_data(timestamp)

# Debug: check if PITData has both prices
spot_price = pit_data.get_price(self.spot_asset_id)
futures_price = pit_data.get_price(self.futures_asset_id)

if spot_price is None or futures_price is None:
self.log(
f"Missing prices in PITData: spot={spot_price}, futures={futures_price}",
level="WARNING",
)
return

# Generate signal from external strategy (now has both prices)
signal = self.external_strategy.generate_signal(timestamp, pit_data)

if signal:
self.log(
f"Signal generated: pos={signal.position:.3f}, conf={signal.confidence:.3f}",
)
self._process_signal(signal)
else:
# Check if we expected a signal but didn't get one
stats = self.external_strategy.get_current_statistics()
if abs(stats.get("z_score", 0)) > 1.0:
self.log(f"Expected signal but got None: z_score={stats.get('z_score', 0):.2f}")

# Update statistics for monitoring
if hasattr(self.external_strategy, "get_current_statistics"):
self._last_statistics = self.external_strategy.get_current_statistics()

# Log all statistics for debugging
self.log(
f"Basis stats: z={self._last_statistics['z_score']:.3f}, "
f"mean={self._last_statistics.get('basis_mean', 0):.1f}, "
f"std={self._last_statistics.get('basis_std', 0):.3f}, "
f"current={self._last_statistics.get('current_basis', 0):.0f}, "
f"data_pts={self._last_statistics.get('data_points', 0)}",
level="INFO",
)

except Exception as e:
self.log(f"Error processing synchronized events: {e}", level="ERROR")

def get_strategy_diagnostics(self) -> dict[str, any]:
"""Get detailed diagnostics for strategy monitoring."""
base_state = self.get_strategy_state()

# Add basis-specific statistics
base_state.update(
{
"basis_statistics": self._last_statistics,
"spot_asset": self.spot_asset_id,
"futures_asset": self.futures_asset_id,
"dataframe_sizes": {
asset: len(df) for asset, df in self.get_all_dataframes().items()
},
},
)

return base_state


def create_crypto_basis_strategy(
spot_asset_id: AssetId = "BTC",
futures_asset_id: AssetId = "BTC_FUTURE",
**strategy_params,
) -> CryptoBasisAdapter:
"""
Factory function to create a crypto basis strategy.

Args:
spot_asset_id: Asset ID for spot prices
futures_asset_id: Asset ID for futures prices
**strategy_params: Strategy parameters

Returns:
Configured CryptoBasisAdapter
"""
return CryptoBasisAdapter(
spot_asset_id=spot_asset_id,
futures_asset_id=futures_asset_id,
**strategy_params,
)
</file>

<file path="src/qengine/strategy/spy_order_flow_adapter.py">
"""
SPY Order Flow Strategy Adapter for QEngine Integration

Adapts the SPYOrderFlowStrategy to work with QEngine's event-driven architecture.
This strategy uses microstructure features from order flow to predict short-term SPY movements.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional

import numpy as np

from qengine.core.types import AssetId
from qengine.strategy.adapters import (
DataFrameAdapter,
ExternalStrategyInterface,
PITData,
StrategySignal,
)


@dataclass
class OrderFlowState:
"""State tracking for SPY order flow strategy."""

# Price and volume history
prices: list[float] = field(default_factory=list)
volumes: list[float] = field(default_factory=list)
timestamps: list[datetime] = field(default_factory=list)

# Order flow features
buy_volumes: list[float] = field(default_factory=list)
sell_volumes: list[float] = field(default_factory=list)
volume_imbalances: list[float] = field(default_factory=list)

# Derived features
price_momentum_5: float = 0.0
price_momentum_20: float = 0.0
volume_momentum_5: float = 0.0
imbalance_ratio: float = 0.5

# Trading state
current_position: float = 0.0
last_signal_time: datetime | None = None
signal_count: int = 0

# Rolling statistics
price_mean_20: float = 0.0
price_std_10: float = 0.0
imbalance_mean: float = 0.0
imbalance_std: float = 0.0


class SPYOrderFlowExternalStrategy(ExternalStrategyInterface):
"""
External SPY order flow strategy implementation.

Uses microstructure features from order flow to predict short-term movements.
Generates directional signals based on order flow imbalances and momentum.
"""

def __init__(
self,
asset_id: AssetId = "SPY",
lookback_window: int = 100,
momentum_window_short: int = 5,
momentum_window_long: int = 20,
imbalance_threshold: float = 0.65,
momentum_threshold: float = 0.002,
min_data_points: int = 20,
signal_cooldown: int = 5, # Minimum bars between signals
):
"""
Initialize SPY order flow strategy.

Args:
asset_id: Asset identifier for SPY
lookback_window: Rolling window for statistics
momentum_window_short: Short momentum calculation window
momentum_window_long: Long momentum calculation window
imbalance_threshold: Threshold for order flow imbalance signals
momentum_threshold: Threshold for momentum signals
min_data_points: Minimum data points before generating signals
signal_cooldown: Minimum bars between signals
"""
self.asset_id = asset_id
self.lookback_window = lookback_window
self.momentum_window_short = momentum_window_short
self.momentum_window_long = momentum_window_long
self.imbalance_threshold = imbalance_threshold
self.momentum_threshold = momentum_threshold
self.min_data_points = min_data_points
self.signal_cooldown = signal_cooldown

# Initialize state
self.state = OrderFlowState()

def initialize(self) -> None:
"""Initialize strategy state (required by interface)."""
self.state = OrderFlowState()
print(f"[SPYOrderFlowStrategy] Initialized with asset {self.asset_id}")

def finalize(self) -> None:
"""Clean up strategy state (required by interface)."""
print(f"[SPYOrderFlowStrategy] Generated {self.state.signal_count} signals")
print(f"[SPYOrderFlowStrategy] Final position: {self.state.current_position}")

def on_start(self) -> None:
"""Initialize strategy state (alias for initialize)."""
self.initialize()

def on_end(self) -> None:
"""Clean up strategy state (alias for finalize)."""
self.finalize()

def generate_signal(self, timestamp: datetime, pit_data: PITData) -> StrategySignal | None:
"""
Generate trading signal based on order flow analysis.

Args:
timestamp: Current timestamp
pit_data: Point-in-time data snapshot

Returns:
Trading signal or None
"""
# Get current market data
price = pit_data.get_price(self.asset_id)

# Get volume from asset data if available
asset_data = pit_data.asset_data.get(self.asset_id, {})
volume = asset_data.get("volume", 0)

if price is None or volume == 0:
return None

# Update state with new data
self._update_state(timestamp, price, volume, pit_data)

# Need minimum data for analysis
if len(self.state.prices)
< self.min_data_points:
  return None

# Check signal cooldown
if self.state.last_signal_time is not None:
# Find the most recent timestamp index
try:
last_signal_idx = self.state.timestamps.index(self.state.last_signal_time)
bars_since_signal = len(self.state.timestamps) - last_signal_idx - 1
except ValueError:
# If timestamp not found, calculate based on current time
bars_since_signal = self.signal_cooldown + 1 # Allow signal

if bars_since_signal
< self.signal_cooldown:
  return None

# Calculate current features
self._calculate_features()

# Generate signal based on order flow and momentum
signal = self._generate_order_flow_signal(timestamp)

if signal:
self.state.signal_count += 1
self.state.last_signal_time = timestamp

return signal

def _update_state(
self,
timestamp: datetime,
price: float,
volume: float,
pit_data: PITData,
) -> None:
"""Update internal state with new market data."""
# Add basic data
self.state.prices.append(price)
self.state.volumes.append(volume)
self.state.timestamps.append(timestamp)

# Extract order flow features from PITData if available
asset_data = pit_data.asset_data.get(self.asset_id, {})

# Get buy/sell volumes (use heuristics if not available)
buy_volume = asset_data.get("buy_volume", volume * 0.5)
sell_volume = asset_data.get("sell_volume", volume * 0.5)

self.state.buy_volumes.append(buy_volume)
self.state.sell_volumes.append(sell_volume)

# Calculate volume imbalance
total_volume = buy_volume + sell_volume + 1e-10
imbalance = (buy_volume - sell_volume) / total_volume
self.state.volume_imbalances.append(imbalance)

# Keep only lookback window
if len(self.state.prices) > self.lookback_window:
self.state.prices = self.state.prices[-self.lookback_window :]
self.state.volumes = self.state.volumes[-self.lookback_window :]
self.state.timestamps = self.state.timestamps[-self.lookback_window :]
self.state.buy_volumes = self.state.buy_volumes[-self.lookback_window :]
self.state.sell_volumes = self.state.sell_volumes[-self.lookback_window :]
self.state.volume_imbalances = self.state.volume_imbalances[-self.lookback_window :]

def _calculate_features(self) -> None:
"""Calculate order flow and momentum features."""
prices = np.array(self.state.prices)
volumes = np.array(self.state.volumes)
imbalances = np.array(self.state.volume_imbalances)

# Price momentum
if len(prices) >= self.momentum_window_short:
self.state.price_momentum_5 = prices[-1] / prices[-self.momentum_window_short] - 1

if len(prices) >= self.momentum_window_long:
self.state.price_momentum_20 = prices[-1] / prices[-self.momentum_window_long] - 1
self.state.price_mean_20 = np.mean(prices[-self.momentum_window_long :])

# Volume momentum
if len(volumes) >= self.momentum_window_short:
self.state.volume_momentum_5 = (
volumes[-1] / np.mean(volumes[-self.momentum_window_short :]) - 1
)

# Price volatility
if len(prices) >= 10:
self.state.price_std_10 = np.std(prices[-10:])

# Imbalance statistics
if len(imbalances) >= 20:
self.state.imbalance_mean = np.mean(imbalances[-20:])
self.state.imbalance_std = np.std(imbalances[-20:])

# Current imbalance ratio
if len(self.state.buy_volumes) > 0:
recent_buy = np.mean(self.state.buy_volumes[-5:])
recent_sell = np.mean(self.state.sell_volumes[-5:])
self.state.imbalance_ratio = recent_buy / (recent_buy + recent_sell + 1e-10)

def _generate_order_flow_signal(self, timestamp: datetime) -> StrategySignal | None:
"""Generate signal based on order flow imbalance and momentum."""
# Signal strength based on multiple factors
signal_strength = 0.0
factors = []

# 1. Order flow imbalance signal
if self.state.imbalance_ratio > self.imbalance_threshold:
signal_strength += 0.4
factors.append("buy_pressure")
elif self.state.imbalance_ratio
<
(1 - self.imbalance_threshold):
signal_strength -= 0.4
factors.append("sell_pressure")

# 2. Price momentum confirmation
if abs(self.state.price_momentum_5) > self.momentum_threshold:
if self.state.price_momentum_5 > 0:
signal_strength += 0.3
factors.append("positive_momentum")
else:
signal_strength -= 0.3
factors.append("negative_momentum")

# 3. Volume surge detection
if self.state.volume_momentum_5 > 0.5: # 50% above average
signal_strength += 0.2 * np.sign(signal_strength)
factors.append("volume_surge")

# 4. Mean reversion opportunity
if len(self.state.prices) >= 20:
price_deviation = (self.state.prices[-1] - self.state.price_mean_20) / (
self.state.price_std_10 + 1e-10
)
if abs(price_deviation) > 2: # 2 standard deviations
signal_strength -= 0.2 * np.sign(price_deviation) # Mean reversion
factors.append("mean_reversion")

# Generate signal if strong enough
threshold = 0.5
if abs(signal_strength) >= threshold:
# Determine position
if signal_strength > 0:
position = min(1.0, signal_strength) # Long
signal_type = "BUY"
else:
position = max(-1.0, signal_strength) # Short
signal_type = "SELL"

# Confidence based on signal strength
confidence = min(1.0, abs(signal_strength) / 1.5)

# Update position tracking
self.state.current_position = position

return StrategySignal(
timestamp=timestamp,
asset_id=self.asset_id,
position=position,
confidence=confidence,
metadata={
"signal_type": signal_type,
"factors": factors,
"imbalance_ratio": round(self.state.imbalance_ratio, 3),
"price_momentum_5": round(self.state.price_momentum_5, 4),
"volume_momentum": round(self.state.volume_momentum_5, 3),
"signal_strength": round(signal_strength, 3),
},
)

return None

def get_current_statistics(self) -> dict[str, any]:
"""Get current strategy statistics."""
return {
"data_points": len(self.state.prices),
"current_position": self.state.current_position,
"imbalance_ratio": self.state.imbalance_ratio,
"price_momentum_5": self.state.price_momentum_5,
"price_momentum_20": self.state.price_momentum_20,
"volume_momentum_5": self.state.volume_momentum_5,
"signal_count": self.state.signal_count,
}


class SPYOrderFlowAdapter(DataFrameAdapter):
"""
Complete adapter for SPY order flow trading strategy.

This combines the external strategy with DataFrame support
and provides complete QEngine integration for order flow analysis.
"""

def __init__(
self,
asset_id: AssetId = "SPY",
lookback_window: int = 100,
momentum_window_short: int = 5,
momentum_window_long: int = 20,
imbalance_threshold: float = 0.65,
momentum_threshold: float = 0.002,
position_scaling: float = 0.2,
window_size: int = 1000,
**kwargs,
):
"""
Initialize SPY order flow adapter.

Args:
asset_id: Asset identifier for SPY
lookback_window: Rolling window for statistics
momentum_window_short: Short momentum window
momentum_window_long: Long momentum window
imbalance_threshold: Order flow imbalance threshold
momentum_threshold: Price momentum threshold
position_scaling: Scaling factor for position size
window_size: DataFrame history window
**kwargs: Additional arguments for DataFrameAdapter
"""
# Create external strategy
external_strategy = SPYOrderFlowExternalStrategy(
asset_id=asset_id,
lookback_window=lookback_window,
momentum_window_short=momentum_window_short,
momentum_window_long=momentum_window_long,
imbalance_threshold=imbalance_threshold,
momentum_threshold=momentum_threshold,
)

# Create custom position sizer for order flow strategy
def order_flow_position_sizer(signal: StrategySignal, cash: float) -> float:
# Scale position based on signal strength and confidence
base_value = cash * position_scaling

# Adjust for confidence
position_value = base_value * abs(signal.position) * signal.confidence

# Apply maximum position limits
max_position = cash * 0.5 # Maximum 50% of capital
position_value = min(position_value, max_position)

# Return signed position value
return position_value if signal.position > 0 else -position_value

# Filter kwargs for parent constructor
parent_kwargs = {k: v for k, v in kwargs.items() if k in ["risk_manager", "name"]}

# Initialize adapter
super().__init__(
external_strategy=external_strategy,
window_size=window_size,
position_sizer=order_flow_position_sizer,
name=f"SPYOrderFlowAdapter_{asset_id}",
**parent_kwargs,
)

# Store configuration
self.asset_id = asset_id
self._last_statistics = {}

def on_start(self) -> None:
"""Start strategy and subscribe to data feeds."""
super().on_start()

# Subscribe to SPY market data
self.subscribe(asset=self.asset_id, event_type="market")

self.log(f"Subscribed to {self.asset_id} order flow data")

def on_market_event(self, event) -> None:
"""Process market events with order flow analysis."""
# Update data history
self._update_data_history(event)

# Process through parent's market event handler
super().on_market_event(event)

# Update statistics for monitoring
if hasattr(self.external_strategy, "get_current_statistics"):
self._last_statistics = self.external_strategy.get_current_statistics()

# Log significant order flow events
if self._last_statistics.get("imbalance_ratio", 0.5):
imbalance = self._last_statistics["imbalance_ratio"]
if imbalance > 0.7 or imbalance
<
0.3:
self.log(
f"Significant order flow: imbalance={imbalance:.3f}, "
f"momentum={self._last_statistics.get('price_momentum_5', 0):.4f}",
level="INFO",
)

def get_strategy_diagnostics(self) -> dict[str, any]:
"""Get detailed diagnostics for strategy monitoring."""
base_state = self.get_strategy_state()

# Add order flow specific diagnostics
order_flow_stats = self._last_statistics.copy() if self._last_statistics else {}

return {
**base_state,
"order_flow_statistics": order_flow_stats,
"strategy_type": "SPY Order Flow Momentum",
"asset": self.asset_id,
}


def create_spy_order_flow_strategy(**kwargs) -> SPYOrderFlowAdapter:
"""
Factory function to create SPY order flow strategy adapter.

Args:
**kwargs: Configuration parameters for the adapter

Returns:
Configured SPYOrderFlowAdapter instance
"""
return SPYOrderFlowAdapter(**kwargs)
</file>

<file path="src/qengine/__init__.py">
"""QEngine - A state-of-the-art event-driven backtesting engine.

QEngine is designed for high-performance backtesting of machine learning-driven
trading strategies with a focus on preventing data leakage and providing
realistic market simulation.
"""

__version__ = "0.1.0"

from qengine.core import Clock, Event, EventBus
from qengine.data import DataFeed
from qengine.engine import BacktestEngine, BacktestResults
from qengine.strategy import Strategy

__all__ = [
"BacktestEngine",
"BacktestResults",
"Clock",
"DataFeed",
"Event",
"EventBus",
"Strategy",
]
</file>

<file path="src/qengine/engine.py">
"""Main backtest engine that orchestrates the simulation."""

import logging
from datetime import datetime
from typing import Any, Optional

import polars as pl

from qengine.core.clock import Clock
from qengine.core.event import EventBus, EventType
from qengine.data.feed import DataFeed
from qengine.execution.broker import Broker
from qengine.portfolio.portfolio import Portfolio
from qengine.reporting.reporter import Reporter
from qengine.strategy.base import Strategy

logger = logging.getLogger(__name__)


class BacktestEngine:
"""Main backtesting engine that coordinates all components.

The engine follows an event-driven architecture where:
1. Data feeds generate market events
2. Strategies consume events and generate signals/orders
3. Broker executes orders and generates fills
4. Portfolio tracks positions and P&L
5. Reporter captures results

Example:
>>> from qengine import BacktestEngine
>>> from qengine.data import ParquetDataFeed
>>> from qengine.strategy import BuyAndHoldStrategy
>>>
>>> engine = BacktestEngine(
... data_feed=ParquetDataFeed("data.parquet"),
... strategy=BuyAndHoldStrategy(),
... initial_capital=100000
... )
>>> results = engine.run()
"""

def __init__(
self,
data_feed: DataFeed,
strategy: Strategy,
broker: Broker | None = None,
portfolio: Portfolio | None = None,
reporter: Reporter | None = None,
initial_capital: float = 100000.0,
currency: str = "USD",
use_priority_queue: bool = True,
):
"""Initialize the backtest engine.

Args:
data_feed: Source of market data events
strategy: Trading strategy to execute
broker: Order execution broker (default: SimulationBroker)
portfolio: Portfolio tracker (default: SimplePortfolio)
reporter: Results reporter (default: InMemoryReporter)
initial_capital: Starting capital
currency: Base currency for the portfolio
use_priority_queue: Use priority queue for event ordering
"""
self.data_feed = data_feed
self.strategy = strategy
self.initial_capital = initial_capital
self.currency = currency

# Create event bus for communication
self.event_bus = EventBus(use_priority_queue=use_priority_queue)

# Create clock for time management
self.clock = Clock()

# Initialize broker if not provided
if broker is None:
from qengine.execution.broker import SimulationBroker

self.broker = SimulationBroker()
else:
self.broker = broker

# Initialize portfolio if not provided
if portfolio is None:
from qengine.portfolio.simple import SimplePortfolio

self.portfolio = SimplePortfolio(initial_capital=initial_capital, currency=currency)
else:
self.portfolio = portfolio

# Initialize reporter if not provided
if reporter is None:
from qengine.reporting.reporter import InMemoryReporter

self.reporter = InMemoryReporter()
else:
self.reporter = reporter

# Wire up event handlers
self._setup_event_handlers()

# Statistics
self.events_processed = 0
self.start_time: datetime | None = None
self.end_time: datetime | None = None

def _setup_event_handlers(self) -> None:
"""Connect components via event subscriptions."""
# Strategy subscribes to market and fill events
self.event_bus.subscribe(EventType.MARKET, self.strategy.on_market_event)
self.event_bus.subscribe(EventType.FILL, self.strategy.on_fill_event)

# Broker subscribes to order events
self.event_bus.subscribe(EventType.ORDER, self.broker.on_order_event)

# Portfolio subscribes to fill events
self.event_bus.subscribe(EventType.FILL, self.portfolio.on_fill_event)

# Reporter subscribes to all events for logging
for event_type in EventType:
self.event_bus.subscribe(event_type, self.reporter.on_event)

def run(
self,
start_date: datetime | None = None,
end_date: datetime | None = None,
max_events: int | None = None,
) -> dict[str, Any]:
"""Run the backtest simulation.

Args:
start_date: Start date for backtest (None = use data start)
end_date: End date for backtest (None = use data end)
max_events: Maximum events to process (for debugging)

Returns:
Dictionary containing backtest results including:
- trades: DataFrame of executed trades
- positions: DataFrame of position history
- returns: Series of strategy returns
- metrics: Performance metrics dict
- events_processed: Number of events processed
"""
logger.info("Starting backtest engine")
self.start_time = datetime.now()

# Initialize components
self.data_feed.initialize(start_date, end_date)
self.strategy.on_start(self.portfolio, self.event_bus)
self.broker.initialize(self.portfolio, self.event_bus)
self.portfolio.initialize()
self.reporter.on_start()

# Initialize clock with data feed's time range
if hasattr(self.data_feed, "get_time_range"):
data_start, data_end = self.data_feed.get_time_range()
self.clock.advance_to(start_date or data_start)

# Main event loop
self.events_processed = 0

while not self.data_feed.is_exhausted:
# Check max events limit
if max_events and self.events_processed >= max_events:
logger.info(f"Reached max events limit: {max_events}")
break

# Get next market event from data feed
market_event = self.data_feed.get_next_event()
if market_event is None:
break

# Update clock
self.clock.advance_to(market_event.timestamp)

# Publish market event
self.event_bus.publish(market_event)

# Process all events in queue (market -> signal -> order -> fill)
events_in_cycle = self.event_bus.process_all()
self.events_processed += events_in_cycle + 1 # +1 for market event

# Update portfolio valuations
self.portfolio.update_market_value(market_event)

# Log progress periodically
if self.events_processed % 10000 == 0:
logger.info(f"Processed {self.events_processed:,} events")

# Finalize
self.strategy.on_end()
self.broker.finalize()
self.portfolio.finalize()
self.reporter.on_end()

self.end_time = datetime.now()
duration = (self.end_time - self.start_time).total_seconds()

logger.info(
f"Backtest complete: {self.events_processed:,} events in {duration:.2f}s "
f"({self.events_processed / duration:.0f} events/sec)",
)

# Compile results
results = self._compile_results()
return results

def _compile_results(self) -> dict[str, Any]:
"""Compile backtest results from all components.

Returns:
Dictionary with comprehensive backtest results
"""
# Get data from components
trades = self.broker.get_trades()
positions = self.portfolio.get_positions()
returns = self.portfolio.get_returns()
metrics = self.portfolio.calculate_metrics()

# Add engine statistics
duration = (self.end_time - self.start_time).total_seconds() if self.end_time else 0

results = {
"trades": trades,
"positions": positions,
"returns": returns,
"metrics": metrics,
"events_processed": self.events_processed,
"duration_seconds": duration,
"events_per_second": self.events_processed / duration if duration > 0 else 0,
"initial_capital": self.initial_capital,
"final_value": self.portfolio.get_total_value(),
"total_return": (self.portfolio.get_total_value() / self.initial_capital - 1) * 100,
}

# Add reporter data if available
if hasattr(self.reporter, "get_report"):
results["report"] = self.reporter.get_report()

return results

def reset(self) -> None:
"""Reset the engine for another run."""
logger.info("Resetting backtest engine")

# Clear event bus
self.event_bus.clear()

# Reset components
self.data_feed.reset()
self.strategy.reset()
self.broker.reset()
self.portfolio.reset()
self.reporter.reset()

# Reset statistics
self.events_processed = 0
self.start_time = None
self.end_time = None

# Re-setup event handlers
self._setup_event_handlers()


class BacktestResults:
"""Container for backtest results with analysis methods."""

def __init__(self, results: dict[str, Any]):
"""Initialize with results dictionary from BacktestEngine.

Args:
results: Results dictionary from engine.run()
"""
self.results = results
self.trades = results.get("trades", pl.DataFrame())
self.positions = results.get("positions", pl.DataFrame())
self.returns = results.get("returns", pl.Series())
self.metrics = results.get("metrics", {})

@property
def total_return(self) -> float:
"""Total return percentage."""
return self.results.get("total_return", 0.0)

@property
def sharpe_ratio(self) -> float:
"""Sharpe ratio of returns."""
return self.metrics.get("sharpe_ratio", 0.0)

@property
def max_drawdown(self) -> float:
"""Maximum drawdown percentage."""
return self.metrics.get("max_drawdown", 0.0)

@property
def win_rate(self) -> float:
"""Percentage of winning trades."""
if self.trades.is_empty():
return 0.0
winning = self.trades.filter(pl.col("pnl") > 0)
return len(winning) / len(self.trades) * 100

def summary(self) -> str:
"""Generate a text summary of results.

Returns:
Formatted summary string
"""
return f"""
Backtest Results Summary
========================
Total Return: {self.total_return:.2f}%
Sharpe Ratio: {self.sharpe_ratio:.2f}
Max Drawdown: {self.max_drawdown:.2f}%
Win Rate: {self.win_rate:.2f}%
Total Trades: {len(self.trades):,}
Events Processed: {self.results.get("events_processed", 0):,}
Duration: {self.results.get("duration_seconds", 0):.2f}s
""".strip()

def to_dict(self) -> dict[str, Any]:
"""Convert to dictionary for serialization.

Returns:
Dictionary of results
"""
return self.results

def save(self, path: str) -> None:
"""Save results to file.

Args:
path: Output file path (supports .parquet, .json, .html)
"""
if path.endswith(".parquet"):
# Save DataFrames to parquet
self.trades.write_parquet(path.replace(".parquet", "_trades.parquet"))
self.positions.write_parquet(path.replace(".parquet", "_positions.parquet"))
elif path.endswith(".json"):
# Save as JSON
import json

with open(path, "w") as f:
# Convert non-serializable objects
data = {
k: v if not isinstance(v, (pl.DataFrame, pl.Series)) else None
for k, v in self.results.items()
}
json.dump(data, f, indent=2, default=str)
elif path.endswith(".html"):
# Generate HTML report
from qengine.reporting.html import generate_html_report

html = generate_html_report(self)
with open(path, "w") as f:
f.write(html)
else:
raise ValueError(f"Unsupported file format: {path}")


__all__ = [
"BacktestEngine",
"BacktestResults",
]
</file>

<file path="README.md">
# QEngine

State-of-the-art event-driven backtesting engine for ML-driven trading strategies with architectural guarantees against
data leakage.

## Installation

```bash
# Development setup (from monorepo root)
make setup
make test-qng # Test qengine

# Or standalone
pip install -e .
```

## Quick Start

```python
import qengine as qe
from qengine.data import ParquetDataFeed
from qengine.strategy import Strategy

# Create strategy
class MomentumStrategy(Strategy):
def on_market_event(self, event, context):
# Access point-in-time safe data
if context.signals['momentum'] > 0.02:
self.submit_order(qe.MarketOrder("AAPL", 100, "BUY"))

# Run backtest
engine = qe.BacktestEngine(
data_feed=ParquetDataFeed("data.parquet"),
strategy=MomentumStrategy(),
initial_capital=100_000
)

results = engine.run()
print(f"Sharpe: {results.sharpe_ratio:.2f}, Return: {results.total_return:.1%}")
```

## Key Features

- **Event-Driven Core**: Point-in-time correctness with no data leakage
- **Advanced Orders**: Market, Limit, Stop, Bracket with realistic execution
- **Execution Models**: Slippage (7 models), Commission (9 models), Market Impact
- **ML Integration**: Strategy adapters for sklearn/torch models
- **Performance**: 8,552 trades/sec, Polars-based, optional Numba JIT
- **Validation**: 100% agreement with VectorBT, 154 unit tests

## Architecture

```
DataFeed  EventBus  Strategy  Orders  Broker  Fills  Portfolio
 
Clock (Time Control) Performance
```

**Core Components:**
- `EventBus`: Priority-queue event routing with ~100k events/sec
- `Clock`: Centralized time control preventing data leakage
- `Strategy`: Base class with lifecycle hooks (on_start, on_market_event, on_fill)
- `Broker`: Realistic order matching with slippage/impact models
- `Portfolio`: Position tracking, P&L, and metrics calculation

## Usage Examples

### Order Types & Execution
```python
# Orders with realistic execution
order = qe.LimitOrder("AAPL", 100, "BUY", limit_price=150.0)
broker = SimulationBroker(
slippage=LinearImpactSlippage(0.1),
commission=PercentageCommission(0.001) # 10bps
)
```

```python
class MLStrategy(qe.SignalStrategy):
def on_market_event(self, event, context):
# ML predictions available in context
signal = context.predictions[event.asset_id]
if signal > 0.6:
self.submit_order(qe.MarketOrder(event.asset_id, 100, "BUY"))
```

## QuantLab Integration

```python
# Future integration (in development)
from qfeatures import Pipeline
from qeval import PurgedWalkForwardCV

# Feature engineering  Model validation  Backtesting
features = Pipeline().fit_transform(data)
validated_model = qeval.validate(model, features)
results = qengine.backtest(validated_model, features)
```

## Development

See [CLAUDE.md](CLAUDE.md) for development guidelines, code standards, and contributing instructions.

## License

Apache License 2.0
</file>

        </files>
        </qengine>