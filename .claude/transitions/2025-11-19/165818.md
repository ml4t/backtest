# Handoff: 2025-11-19 16:58:18 UTC

## Active Work

**Task**: Cross-framework validation - debugging excessive trade count in ml4t.backtest (1158 trades vs 80 VectorBT / 36 Backtrader)

**Location**: `/home/stefan/ml4t/software/backtest/tests/validation/`

**Context**: User continuing from `.claude/transitions/2025-11-19/162429.md` - originally identified position accumulation bug, now investigating duplicate order processing in broker/fill_simulator.

## Current State

### âœ… Completed (DataFeed Interface)

1. **MultiAssetDataFeed Implementation** - Fixed abstract class errors
   - File: `tests/validation/frameworks/qengine_adapter.py:546-590`
   - Added all 5 required abstract methods:
     - `get_next_event()` - Returns MarketEvent with `data_type=MarketDataType.BAR`
     - `is_exhausted` property
     - `peek_next_timestamp()`
     - `reset()`
     - `seek()`
   - Added missing import: `from ml4t.backtest.core.types import MarketDataType`

2. **Strategy Improvements** - Attempted fixes (didn't solve issue)
   - Added pending order tracking (lines 487, 509-510, 526, 537)
   - Added FillEvent handling via `on_fill_event()` (lines 490-494, 539-543)
   - Position check threshold: `abs(current_qty) < 0.001`

### ðŸ”´ Critical Issue - Root Cause Identified

**Problem**: ml4t.backtest produces **1158 trades** vs 80 (VectorBT) / 36 (Backtrader) - 15x more trades!

**Root Cause**: Broker processes the SAME order on EVERY subsequent bar, creating:
- Zero-quantity fills: `FILL: buy 0.000000 @ $169.72`
- Dust fills: `FILL: buy 0.062154 @ $310.23`
- Position accumulation despite position checks

**Evidence from Debug Logging**:
```
[0] 2020-01-22 STOCK11: signal=1, position=0.000000, pending=False
  â†’ SUBMITTED BUY order for 118.9526 shares
  â† FILL: buy 118.952608 @ $168.30, new position=118.952608  (GOOD)
  â† FILL: buy 0.000000 @ $169.72, new position=118.952608    (BUG - same order, next bar!)
  â† FILL: buy 0.000000 @ $169.12, new position=118.952608    (BUG - still processing!)
  ... continues for 20+ bars ...
```

**Trade Log Analysis** (from `tests/validation/trade_logs/trades_ml4t_backtest.csv`):
- Nano-trades: 2.986e-10 shares (worth $0.00000004)
- Consecutive daily BUY orders for same symbol despite having position
- Same price ~$310: Buy Jan 23 (63.7 shares), Buy Jan 24 (0.062 shares), Buy nano on Feb 12-28

### ðŸ”§ Attempted Fixes (All Failed)

1. **Fill Simulator Zero-Quantity Check** âŒ
   - File: `src/ml4t/backtest/execution/fill_simulator.py:235`
   - Added: `if fill_quantity <= 0: return None`
   - Result: No effect - orders still being processed

2. **Broker Skip Check** âŒ
   - File: `src/ml4t/backtest/execution/broker.py:666-672`
   - Added debug logging for `if order.remaining_quantity <= 0: continue`
   - Result: **No debug output** - this check is NEVER triggered
   - Implication: Orders with `remaining_quantity > 0` are reaching fill simulator

3. **Strategy Pending Order Tracking** âŒ
   - Added `self.pending_orders` dict to track submitted orders
   - Clear on `on_fill_event()`
   - Result: Reduced from 1158 to... still 1158 trades (no effect)

## Investigation Findings

### Key Observations

1. **Broker's remaining_quantity check (line 666) never triggers**
   - Orders reaching fill simulator ALWAYS have `remaining_quantity > 0`
   - This means either:
     - Orders aren't being removed from `_open_orders` after fill
     - OR order.remaining_quantity isn't being set to 0 after full fill

2. **Fill simulator zero-check also ineffective**
   - Even with explicit `if fill_quantity <= 0: return None`
   - Still creating zero-quantity fills
   - Suggests `order.remaining_quantity` is NOT 0 when it should be

3. **Order lifecycle unclear**
   - Submit â†’ Fill â†’ Remove should happen
   - Line 747: `self.order_router.remove_order(order)` called if `order.is_filled`
   - But orders seem to persist in `_open_orders[asset_id]` across multiple bars

### Hypotheses (Not Yet Tested)

**Hypothesis A**: `order.update_fill()` doesn't set `remaining_quantity = 0` for full fills
- Check: `src/ml4t/backtest/execution/order.py:320` (update_fill method)
- Verify: After full fill, does `order.remaining_quantity == 0`?
- Verify: Does `order.is_filled == True`?

**Hypothesis B**: Orders aren't removed from `_open_orders` despite `is_filled == True`
- Check: `order_router.remove_order()` at broker.py:747
- Add logging: Track when orders are added vs removed from `_open_orders`

**Hypothesis C**: Execution delay logic re-adds filled orders
- Check: broker.py:626-636 moves pending â†’ open
- Verify: Are filled orders lingering in `_pending_orders` and getting re-activated?

## Recommended Next Steps

### Step 1: Add Order Lifecycle Logging (15 min)

Add comprehensive logging to track order state transitions:

```python
# In broker.py submit_order():
print(f"[SUBMIT] {order.order_id} for {asset_id}: qty={order.quantity}")

# In broker.py on_market_event() before fill attempt:
print(f"[ATTEMPT] {order.order_id}: remaining={order.remaining_quantity}, state={order.state}")

# In fill_simulator.py try_fill_order() after order.update_fill():
print(f"[FILLED] {order.order_id}: filled={fill_quantity}, remaining={order.remaining_quantity}, is_filled={order.is_filled}")

# In broker.py after remove_order():
print(f"[REMOVED] {order.order_id} from _open_orders")
```

Run test and analyze output to see where lifecycle breaks.

### Step 2: Verify order.update_fill() Logic (15 min)

Read `src/ml4t/backtest/execution/order.py:320-380` and verify:
- Line 376: `self.state = OrderState.FILLED` when `remaining == 0`
- Line 380: `self.state = OrderState.PARTIALLY_FILLED` otherwise
- Check if `filled_quantity + self.filled_quantity` calculation is correct
- Verify `self.remaining_quantity` update at end

### Step 3: Check order_router.remove_order() (10 min)

Verify orders are actually removed:
```python
# Before remove_order() call in broker.py:747
print(f"[BEFORE REMOVE] _open_orders[{asset_id}] count: {len(self._open_orders[asset_id])}")

# After remove_order()
print(f"[AFTER REMOVE] _open_orders[{asset_id}] count: {len(self._open_orders[asset_id])}")
```

### Step 4: Compare with Backtrader Source (30 min)

Read Backtrader's broker implementation to understand correct order lifecycle:
- File: `resources/backtrader-master/backtrader/brokers/bbroker.py`
- Find: How orders are removed after fill
- Find: How `remaining_quantity` is tracked
- Compare with ml4t.backtest implementation

## Files Modified This Session

### Core Source Changes

1. **src/ml4t/backtest/execution/fill_simulator.py**
   - Line 235: Added `if fill_quantity <= 0: return None` (didn't fix issue)

2. **src/ml4t/backtest/execution/broker.py**
   - Lines 666-672: Added debug logging for remaining_quantity check (no output = never triggered)

3. **tests/validation/frameworks/qengine_adapter.py**
   - Lines 459-460: Added MarketDataType import
   - Lines 487: Added `self.pending_orders = {}` to strategy
   - Lines 490-494: Added FillEvent handling in `on_event()`
   - Lines 509-510, 526, 537: Added pending order tracking logic
   - Lines 539-543: Added `on_fill_event()` method
   - Lines 546-590: Implemented MultiAssetDataFeed with all abstract methods

### Test Results

**Current State** (after all fixes):
```
ml4t.backtest:  $81,468.99  -18.53%  1158 trades
VectorBT:       $85,231.74  -14.77%    80 trades
Backtrader:     $84,233.93  -15.77%    36 trades
```

**Variance**: 3.76% (exceeds 0.5% threshold)
**Trade Count Discrepancy**: 1158 vs 80 vs 36 (15x more than VectorBT!)

**Test Command**:
```bash
source .venv/bin/activate
python -m pytest tests/validation/test_integrated_framework_alignment.py::TestIntegratedFrameworkAlignment::test_all_frameworks_alignment -xvs
```

## Key Code Locations

### Broker Order Processing
- `src/ml4t/backtest/execution/broker.py:603-820` - `on_market_event()` method
- Line 656: Loop through `_open_orders[asset_id]`
- Line 666: Check `order.remaining_quantity <= 0` (never triggers)
- Line 708: Call `fill_simulator.try_fill_order()`
- Line 747: Call `order_router.remove_order(order)` if `order.is_filled`

### Fill Simulator
- `src/ml4t/backtest/execution/fill_simulator.py:115-300` - `try_fill_order()` method
- Line 231: `fill_quantity = order.remaining_quantity`
- Line 235: NEW check `if fill_quantity <= 0: return None` (didn't help)
- Line 715: Call `order.update_fill()` (in broker, after fill_simulator returns)

### Order State Management
- `src/ml4t/backtest/execution/order.py:146-155` - `is_filled` property
- Line 320: `update_fill()` method
- Line 376: Set `OrderState.FILLED` when fully filled
- Line 380: Set `OrderState.PARTIALLY_FILLED` otherwise

### Validation Test
- `tests/validation/test_integrated_framework_alignment.py:370-450` - Test method
- `tests/validation/frameworks/qengine_adapter.py:439-650` - ml4t.backtest adapter

## Session Context

**Working Directory**: `/home/stefan/ml4t/software/backtest/`
**Last Focus**: Debugging duplicate order processing causing 15x trade count
**Test Status**: FAILING - 3.76% variance, 1158 excess trades
**Package Status**: Reinstalled with `uv pip install -e . --no-deps` (latest changes)

## Important Context from Previous Session

From `.claude/transitions/2025-11-19/162429.md`:

1. **VectorBT Commission Fix** - COMPLETED âœ…
   - Fixed commission extraction in `vectorbt_adapter.py:641-653`
   - VectorBT now correctly shows $1,406 commissions (was $0)

2. **2-Framework Validation** - PASSING âœ…
   - VectorBT vs Backtrader: 0.998% variance (UNDER 1% threshold)
   - Trade counts differ (80 vs 36) but acceptable - different execution logic

3. **ml4t.backtest Multi-Asset Fix** - INCOMPLETE âš ï¸
   - Strategy logic CORRECT (position checks at lines 510, 529)
   - DataFeed interface NOW FIXED (this session)
   - But duplicate order processing remains unresolved

## User Instructions

After I complete this handoff:

1. Run `/clear` (the CLI command)
2. Say: `continue from .claude/transitions/2025-11-19/165818.md`

## Meta Notes

**Session Quality**: Deep investigation, identified root cause, but fix unsuccessful
**Time Spent**: ~2 hours debugging broker/fill_simulator interaction
**Confidence**: HIGH that issue is in order lifecycle (submit â†’ fill â†’ remove)
**Recommended Approach**: Add comprehensive logging before attempting more fixes

---

**Handoff complete. Ready for next session to continue debugging order lifecycle.**
