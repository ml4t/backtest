# Handoff: 2025-11-19 23:37:25 UTC

## Executive Summary

**Project**: ml4t.backtest - Batch processing refactor (from external code review)
**Status**: **CRITICAL BREAKTHROUGH** - Fixed dual-portfolio float precision bug, engine now completes successfully
**Previous Handoff**: `.claude/transitions/2025-11-19/225701.md`
**Work Plan**: `.claude/work/BATCH_PROCESSING_REFACTOR_PLAN.md` (10 tasks, 2 phases)

## Major Achievement This Session

### ✅ Fixed: Dual-Portfolio Float Precision Drift (CRITICAL)

**Root Cause Identified:**
Broker maintained TWO separate Portfolio objects that drifted apart:
- `broker._internal_portfolio` (created in `__init__`, line 132)
- `broker.portfolio` (set via `initialize()`, line 1456)

Both tracked the same fills independently, accumulating tiny rounding errors:
```
Portfolio A: 58.0 shares
Portfolio B: 57.99999884393472 shares
```

After ~10k fills, drift triggered: `ValueError: Cannot remove 58.0 shares, only have 57.99999884393472`

**Fix Applied** (`broker.py:1458`):
```python
def initialize(self, portfolio, event_bus):
    # CRITICAL: Use provided portfolio as _internal_portfolio to avoid drift
    self._internal_portfolio = portfolio  # New line - makes them the same object
    self.portfolio = portfolio
    self.event_bus = event_bus
```

**Impact:**
- ✅ BEFORE: Crashed after ~10k fills with float precision error
- ✅ AFTER: Completes 126k events successfully (17,219 events/sec)
- ✅ BEFORE: Return -27.33% (broken portfolio tracking)
- ✅ AFTER: Return +75.28% (correct tracking)

**Commit**: `a3163d9` - "fix: Eliminate dual-portfolio drift causing float precision crashes"

## Current State

### Backtest Metrics (Engine vs Manual Loop)

| Metric | Manual Loop | Engine | Status |
|---|---|---|---|
| Final Value | $8,701,284 | $1,752,844 | ❌ 10x gap |
| Return | +770.13% | +75.28% | ❌ 10x gap |
| Rebalances | 239 | 239 | ✅ Match |
| Final Positions | 20-30 | 3 | ❌ Major gap |
| Throughput | - | 17,219 evt/s | ✅ Working |
| Completion | ✅ | ✅ | ✅ Both complete |

**Key Issue:** Engine achieves only +75% return vs manual loop's +770%. Only 3 final positions vs 20-30 expected.

### Root Cause Hypothesis

Based on batch processing plan (`.claude/work/BATCH_PROCESSING_REFACTOR_PLAN.md`):

**TASK 1 is likely the fix:** Strategy uses `buy_percent()` which **accumulates positions** instead of calculating deltas.

From plan (line 45-53):
```python
# Current (WRONG) - accumulates positions
def buy_percent(self, asset_id, percent, price):
    dollars_to_spend = portfolio_value * percent  # Ignores current position!
    # Each call ADDS to position
```

The plan prescribes `order_target_percent()` which calculates **delta** between target and current position:
```python
delta_qty = target_qty - current_qty  # Key difference
```

This explains:
- Only 3 final positions (strategy not rebalancing correctly)
- Lower returns (capital not fully deployed)
- Matches observation: Position sizing appears wrong

## Files Modified This Session

### Critical Fixes
1. **src/ml4t/backtest/execution/broker.py** (line 1458)
   - Added `self._internal_portfolio = portfolio` to unify dual portfolios

2. **src/ml4t/backtest/portfolio/portfolio.py**
   - Removed debug logging (lines 126-131, 148-152)

### Temporary Debug Code (Removed)
- Portfolio debug prints showing drift (cleaned up)

## Work Plan Status

**Active Plan**: `.claude/work/BATCH_PROCESSING_REFACTOR_PLAN.md`

**Phase 1 (Correctness) - 6 Tasks:**

| Task | Status | Estimate | Notes |
|---|---|---|---|
| TASK 1: `order_target_percent()` | ❌ **NEXT** | 2h | **Likely fix for +75% vs +770% gap** |
| TASK 2: `process_batch_fills()` | ✅ **EXISTS** | - | Already implemented (line 1197-1287) |
| TASK 3: `stream_by_timestamp()` | ✅ **EXISTS** | - | MultiSymbolDataFeed has this |
| TASK 4: Refactor `engine.run()` | ✅ **DONE** | - | Batch mode working |
| TASK 5: Update example strategy | ❌ **BLOCKED** | 1h | Depends on TASK 1 |
| TASK 6: Integration validation | ❌ **BLOCKED** | 3h | Depends on TASK 1, 5 |

**Phase 2 (Performance) - 4 Tasks:**
- Not started (depends on Phase 1 completion)

## Next Steps (IMMEDIATE)

### Priority 1: Implement `order_target_percent()` (TASK 1)

**File**: `src/ml4t/backtest/strategy/base.py`

**Goal**: Fix position accumulation bug causing 10x return discrepancy

**Implementation** (from plan):
```python
def order_target_percent(self, asset_id: str, target_pct: float):
    """Place order to adjust position to target percent of portfolio equity.

    Calculates DELTA between target and current position (not accumulation).
    """
    # Get current state
    current_equity = self.broker._internal_portfolio.equity
    current_qty = self.get_position(asset_id)
    price = self._current_market_data[asset_id].close

    if price is None or price <= 0:
        return

    # Calculate target quantity
    target_value = current_equity * target_pct
    target_qty = target_value / price

    # Calculate DELTA (key fix)
    delta_qty = target_qty - current_qty

    # Round and submit
    trade_qty = int(delta_qty)
    if abs(trade_qty) > 0:
        side = OrderSide.BUY if trade_qty > 0 else OrderSide.SELL
        order = Order(
            asset_id=asset_id,
            side=side,
            quantity=abs(trade_qty),
            order_type=OrderType.MARKET
        )
        self.broker.submit_order(order)
```

**Additional Changes Needed**:
- Add `_current_market_data` cache to Strategy (populated by engine)
- Keep `buy_percent()` for backward compat with deprecation warning
- Add helper `get_position()` method

**Testing**:
```python
def test_order_target_percent_no_accumulation():
    # Call twice for same asset at 4%
    strategy.order_target_percent("AAPL", 0.04)
    strategy.order_target_percent("AAPL", 0.04)

    # Should result in 4% position, not 8%
    expected = portfolio.equity * 0.04
    actual = position.quantity * price
    assert abs(actual - expected) < expected * 0.01
```

**Expected Impact**: Return should jump from +75% to ~+770%

### Priority 2: Update Example (TASK 5)

**File**: `examples/integrated/top25_using_engine.py`

**Change**:
```python
# BEFORE (accumulates):
for asset_id in top_assets:
    self.buy_percent(asset_id, target_pct, price)

# AFTER (rebalances):
for asset_id in top_assets:
    self.order_target_percent(asset_id, target_pct)
```

**Expected Impact**: Final positions should be ~25 instead of 3

### Priority 3: Validate (TASK 6)

Run both and compare:
```bash
python examples/integrated/top25_using_engine.py      # Should get +770%
python examples/integrated/top25_ml_strategy_complete.py  # Baseline +770%
```

**Success Criteria**:
- ✅ Return: +770% ± 5%
- ✅ Final positions: 20-30
- ✅ No crashes
- ✅ Throughput: >15k events/sec

## Recent Decisions

1. **Unified dual-portfolio architecture** - Both `_internal_portfolio` and `portfolio` now point to same object
2. **Keep dual-portfolio pattern** - For backward compat, just make them point to same instance
3. **Debug logging removed** - Cleaned up temporary prints in portfolio.py
4. **Focus on TASK 1 next** - `order_target_percent()` is likely fix for return discrepancy

## Open Questions

1. **Why only 3 final positions?** - Likely due to accumulation bug (TASK 1 fix expected)
2. **Are fills executing correctly?** - Yes (verified 24 fills on first rebalance)
3. **Is capital fully deployed?** - No (only 3 positions vs 25 target)
4. **Should we audit `process_batch_fills()`?** - After TASK 1, verify it's working correctly

## Session Context

**Working Directory**: `/home/stefan/ml4t/software/backtest/`
**Branch**: `feature/phase-1-ml-data-foundation`
**Virtual Env**: `.venv` (active)
**Last Focus**: Debugging dual-portfolio drift, fixed critical bug
**Success Metric**: Match manual loop returns (+770% ± 5%)

## Architecture Notes (For Memory)

### Dual-Portfolio Pattern (Now Fixed)

**Before (Broken)**:
- Broker created `_internal_portfolio` in `__init__` (line 132)
- Engine created separate `portfolio` and passed to `broker.initialize()` (line 1456)
- TWO DIFFERENT objects tracked the same fills
- Floating-point drift accumulated until crash

**After (Fixed)**:
- Broker still creates `_internal_portfolio` in `__init__`
- BUT `initialize()` replaces it with engine's portfolio (line 1458)
- SAME object, no drift possible
- Backward compatible (external code sees no change)

**Lesson**: When two objects track the same state independently, even tiny float differences compound to crashes. Always share single source of truth.

## References

- **Work Plan**: `.claude/work/BATCH_PROCESSING_REFACTOR_PLAN.md` (10 tasks)
- **Expert Review #1**: `.claude/code_review/20251119/response_01.md`
- **Expert Review #2**: `.claude/code_review/20251119/response_02.md`
- **Manual Loop (Working)**: `examples/integrated/top25_ml_strategy_complete.py` (+770%)
- **Engine Example (Broken)**: `examples/integrated/top25_using_engine.py` (+75%)
- **Previous Handoff**: `.claude/transitions/2025-11-19/225701.md`

## Commands to Continue

```bash
cd /home/stefan/ml4t/software/backtest
source .venv/bin/activate

# Quick verification (should show +75% return, 3 final positions)
python examples/integrated/top25_using_engine.py 2>&1 | tail -20

# Next: Implement TASK 1 (order_target_percent)
# File: src/ml4t/backtest/strategy/base.py
# Add method, then update example to use it
```

## Git Status

**Last Commit**: `a3163d9` - "fix: Eliminate dual-portfolio drift causing float precision crashes"

**Uncommitted Changes**: None (all work committed)

**Branch**: `feature/phase-1-ml-data-foundation`

## Progress Tracking

**Phase 1 Complete**: 40% (2/6 tasks functional)
- ✅ Dual-portfolio bug (not in plan, but critical)
- ✅ TASK 2: Batch fill processing exists
- ✅ TASK 3: Timestamp streaming exists
- ✅ TASK 4: Engine batch mode working
- ❌ TASK 1: `order_target_percent()` (NEXT - likely solves return gap)
- ❌ TASK 5: Update example
- ❌ TASK 6: Validation

**Estimated Time to Phase 1 Complete**: 6 hours (2h + 1h + 3h)

**Blockers**: None (ready to implement TASK 1)

---

**Created**: 2025-11-19 23:37:25 UTC
**Progress**: Major breakthrough - dual-portfolio crash fixed, ready for TASK 1
**Next Agent**: Implement `order_target_percent()` to fix +75% → +770% return gap
