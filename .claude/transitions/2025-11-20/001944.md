# Handoff: 2025-11-20 00:19:44 UTC

## Executive Summary

**Session Focus**: Deep investigation of position accumulation bug causing +34,072% returns (vs +770% target)
**Status**: âœ… Critical discovery - Portfolio fills ARE applied correctly, but positions still accumulate
**Key Finding**: portfolio.on_fill_event() works perfectly, mystery is in position query path

---

## Critical Discovery: Portfolio Fills Work Correctly!

**BREAKTHROUGH**: Added debug logging to `portfolio.on_fill_event()` (portfolio.py:144) and confirmed:

```
PORTFOLIO on_fill_event: STOCK012 BUY 106 â†’ position now 106.0
PORTFOLIO on_fill_event: STOCK036 BUY 150 â†’ position now 150.0
...
```

**This proves**:
âœ… Event bus dispatch IS working
âœ… Portfolio.on_fill_event() IS being called
âœ… Positions ARE being updated correctly
âœ… Event loop sequencing is correct (fills before strategy)

**But the bug persists**: Final result = +34,072% with 121 positions (should be +770% with ~25)

---

## The Mystery Deepens

Despite confirming the architecture works correctly:

1. **Fills are applied**: Portfolio positions update to correct values (106, 150, 210, etc.)
2. **`order_target_percent()` has correct delta calculation**:
   ```python
   delta_qty = target_qty - current_qty  # Should prevent accumulation
   ```
3. **But positions still accumulate exponentially**

**Hypothesis**: When strategy calls `broker.get_position(asset_id)`, it's returning stale/wrong values (possibly 0) despite portfolio being updated.

---

## Architecture Validation (All Confirmed Working)

### 1. Event Bus Dispatch is Synchronous âœ…
**File**: `src/ml4t/backtest/core/clock.py:186`
```python
def dispatch_event(self, event: Event) -> None:
    handlers = self._subscribers.get(event.event_type, [])
    for handler in handlers:
        handler(event)  # Synchronous call
```

### 2. Portfolio Subscription âœ…
**File**: `src/ml4t/backtest/engine.py:204`
```python
self.clock.subscribe(EventType.FILL, self.portfolio.on_fill_event)
```

### 3. Event Loop Sequencing âœ…
**File**: `src/ml4t/backtest/engine.py:496-536`
```python
# PHASE 1: Fill old orders (from previous timestamp)
broker.process_batch_fills(timestamp, market_map)  # Line 496

# PHASE 2: Mark-to-market
for event in events:
    portfolio.on_market_event(event)  # Line 506

# PHASE 3: Strategy logic
strategy.on_timestamp_batch(timestamp, events, context.data)  # Line 534
```

### 4. Unified Portfolio Objects âœ…
**File**: `src/ml4t/backtest/execution/broker.py:1466-1467`
```python
self._internal_portfolio = portfolio  # Same object
self.portfolio = portfolio
```

**Verified**: Both point to THE SAME object, not copies.

---

## Files Modified This Session

### Debug Logging Added

**src/ml4t/backtest/portfolio/portfolio.py:141-144**
```python
# DEBUG: Confirm fill was applied
new_pos = self._tracker.get_position(event.asset_id)
new_qty = new_pos.quantity if new_pos else 0.0
print(f"PORTFOLIO on_fill_event: {event.asset_id[:12]:<12} {event.side.name} {event.fill_quantity:>6.0f} â†’ position now {new_qty:>6.1f}")
```

**Impact**: This logging PROVES fills are being applied correctly. Keep this for next debugging session.

---

## Next Steps (Priority Order)

### IMMEDIATE: Debug Position Query Path

The issue must be in how `broker.get_position()` or `strategy.get_position()` returns values to the strategy.

**Step 1**: Add logging to `broker.get_position()` (broker.py:1327):
```python
def get_position(self, asset_id: AssetId) -> Quantity:
    position = self._internal_portfolio.get_position(asset_id)
    qty = position.quantity if position else 0.0
    print(f"BROKER get_position({asset_id[:12]:<12}): {qty:>6.1f}")  # ADD THIS
    return qty
```

**Step 2**: Add logging to `strategy.get_position()` (base.py:310):
```python
def get_position(self, asset_id: AssetId) -> float:
    if self.broker is None:
        raise ValueError("Broker not initialized.")
    position = self.broker.get_position(asset_id)
    result = position if position is not None else 0.0
    print(f"STRATEGY get_position({asset_id[:12]:<12}): {result:>6.1f}")  # ADD THIS
    return result
```

**Step 3**: Run backtest and compare:
```bash
python examples/integrated/top25_using_engine.py 2>&1 | grep -E "(PORTFOLIO on_fill|BROKER get_position|STRATEGY get_position)" | head -100
```

**Expected Pattern** (if working correctly):
```
PORTFOLIO on_fill_event: STOCK012 BUY 106 â†’ position now 106.0
STRATEGY get_position(STOCK012): 106.0  # Should see the 106!
BROKER get_position(STOCK012): 106.0
```

**Actual Pattern** (suspected):
```
PORTFOLIO on_fill_event: STOCK012 BUY 106 â†’ position now 106.0
STRATEGY get_position(STOCK012): 0.0  # BUG: Sees 0 instead of 106!
```

### HIGH: Investigate Timing of get_position() Calls

**Hypothesis**: Maybe strategy is calling `get_position()` DURING the fill dispatch loop, before all fills complete?

Check when `order_target_percent()` is called relative to fill dispatch in broker.py:
- Line 1293: `dispatch_event(fill_event)` for each fill
- Returns from `process_batch_fills()` at line 1295
- Engine calls strategy at line 534

**Verify**: Are there ANY code paths where strategy could run before `process_batch_fills()` returns?

### MEDIUM: Check Portfolio Equity Calculation

Position accumulation could also be caused by incorrect equity calculation affecting position sizing:

**File**: `src/ml4t/backtest/portfolio/portfolio.py`

Check:
- `portfolio.equity` property
- How unrealized P&L is calculated
- When mark-to-market updates happen

If equity is calculated wrong, `target_qty = (equity * target_pct) / price` will be wrong, causing accumulation.

---

## Current State

**Working Directory**: `/home/stefan/ml4t/software/backtest/`
**Branch**: `feature/phase-1-ml-data-foundation`
**Virtual Environment**: `.venv` (active)
**Last Commit**: `a71853e` - "fix: Eliminate duplicate fill application causing infinite returns"

**Test Results**:
```
Final value: $341,725,262.65
Total return: 34072.53%
Final positions: 121
Rebalances: 239
Throughput: 16,783 events/second
Last order: STOCK499 BUY 23,791 shares (!!!)
```

**Target Metrics**:
```
Total return: +770.13%
Final positions: 20-30
Rebalances: 239
```

---

## Key References

### Previous Handoff
`.claude/transitions/2025-11-20/000223.md` - Documents initial investigation and dual-portfolio fix

### Code Files
- `src/ml4t/backtest/execution/broker.py:1252` - Fill dispatch (removed direct application)
- `src/ml4t/backtest/execution/broker.py:1293` - Event bus dispatch for fills
- `src/ml4t/backtest/execution/broker.py:1327` - `get_position()` query â† DEBUG THIS
- `src/ml4t/backtest/portfolio/portfolio.py:141` - Debug logging (confirms fills work)
- `src/ml4t/backtest/strategy/base.py:310` - Strategy `get_position()` â† DEBUG THIS
- `src/ml4t/backtest/strategy/base.py:640` - `order_target_percent()` implementation
- `src/ml4t/backtest/engine.py:496` - Fill processing phase
- `src/ml4t/backtest/core/clock.py:186` - Synchronous event dispatch

### Test Command
```bash
python examples/integrated/top25_using_engine.py 2>&1 | tee debug.log
```

---

## Investigation Progress

### âœ… Confirmed Working
1. Portfolio.on_fill_event() IS called for every fill
2. Portfolio positions ARE updated correctly (debug logging proves it)
3. Event bus dispatch is synchronous (not asynchronous)
4. Event loop sequencing is correct (fills â†’ mark-to-market â†’ strategy)
5. Portfolio objects are unified (not separate instances)
6. `order_target_percent()` has correct delta calculation logic

### âŒ Still Broken
1. Positions accumulate to 121 (should be ~25)
2. Returns +34,072% (should be +770%)
3. Final orders are HUGE (23,791 shares vs ~100 expected)

### ðŸ” Unknown (Next to Investigate)
1. What does `broker.get_position()` return when strategy queries it?
2. What does `strategy.get_position()` see after fills are applied?
3. Is there a timing issue where strategy queries DURING fill dispatch?
4. Is portfolio equity calculation affecting position sizing?

---

## Pattern Analysis

This is the THIRD occurrence of dual-state tracking drift:
- **October 2025**: `broker.position_tracker` vs `portfolio.positions` (fixed)
- **November 2025 (Session 1)**: `broker._internal_portfolio` vs `broker.portfolio` (fixed)
- **November 2025 (Session 2)**: Portfolio fills applied correctly, but queries return wrong values (current)

**Root Cause Hypothesis**: Not actually dual-state tracking this time - something else in the query path is broken or cached.

---

## Commands to Resume Work

```bash
cd /home/stefan/ml4t/software/backtest
source .venv/bin/activate

# Add logging to broker.get_position() and strategy.get_position()
# (See "IMMEDIATE" section above for exact code)

# Run with full logging
python examples/integrated/top25_using_engine.py 2>&1 | tee debug_full.log

# Filter to see fill â†’ query pattern
grep -E "(PORTFOLIO on_fill|BROKER get_position|STRATEGY get_position)" debug_full.log | head -100

# Look for mismatches (portfolio says 106, strategy sees 0)
```

---

**Created**: 2025-11-20 00:19:44 UTC
**Session Progress**: Proved fills work correctly, isolated issue to position query path
**Ready for**: Add query logging and identify why strategy sees wrong position values
