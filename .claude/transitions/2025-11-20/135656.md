# Handoff: 2025-11-20 13:56:56 UTC

## Active Work
Prepared comprehensive design review package for external architectural feedback on backtesting engine accounting and execution model.

## Current State

### What Was Accomplished
1. **Discovered Critical Bug**: Validation study revealed engine lacks cash constraint enforcement
   - VectorBT (correct): -$3,891 PnL (respects cash limits)
   - Our engine (broken): -$652,580 PnL (executes orders into massive debt)
   - Difference: 99.4%

2. **Created Design Review Documents**:
   - `DESIGN_QUESTIONS.md` (6,800+ words): 41 specific questions across 6 parts
   - `README_REVIEW.md`: Quick start guide for reviewers
   - `README.md`: Updated with honest status and warnings

3. **Repository Cleanup**:
   - Renamed `engine_v2.py` → `engine.py`
   - Renamed `test_engine_v2_validation.py` → `test_validation.py`
   - Removed all "_v2" references and comparisons to old implementation
   - Updated all imports and documentation
   - All 17 tests passing (82% coverage)

### Validation Results (Current State)
```
Test scenario: 250 assets × 252 days × ~11,000 trades

Backtrader (next-bar):    -$647,604, 11,230 trades, 18.7s → 0.39% diff ✓
ml4t.backtest (next-bar): -$650,115, 11,230 trades, 0.6s  → 32x faster

VectorBT (same-bar):      -$3,891,   11,321 trades, 3.4s  → Enforces cash limits
ml4t.backtest (same-bar): -$652,580, 11,271 trades, 0.6s  → NO cash limits ✗
```

**Key insight**: Engine matches Backtrader (0.39%) when both ignore cash constraints, but fails against VectorBT's stricter accounting (99.4% diff).

## Recent Decisions

### 1. Halt Implementation, Seek Expert Review
Rather than patch the cash constraint bug, decided to step back and get architectural guidance on the entire accounting model:
- Long/short position accounting
- Leverage definitions and limits
- Execution sequencing (exits before entries?)
- Cash flow timing (when do exit proceeds become available?)
- Liquidity constraints and market impact

### 2. Design Questions Document Structure
Organized 41 questions into 6 parts:
- Part 1: Accounting Model (10 questions)
- Part 2: Execution Sequencing (8 questions)
- Part 3: Liquidity & Market Impact (7 questions)
- Part 4: Architecture (6 questions - build vs buy?)
- Part 5: Implementation Details (6 questions)
- Part 6: Testing Strategy (4 questions)

### 3. Repository Presentation
- Removed version numbers and comparisons to old code
- Present this as THE implementation seeking review
- Archive already documents history, no need to justify
- Focus on design questions, not "how we got here"

## Critical Issues Identified

### 1. Missing Cash Constraint Enforcement
**Location**: `src/ml4t/backtest/engine.py:_execute_fill()`

Current code:
```python
def _execute_fill(self, order, fill_price):
    commission = self.commission_model.calculate(...)
    total_cost = fill_price * quantity + commission
    self.cash -= total_cost  # Can go negative! No check!
    self._update_position(order)
```

**Impact**: Engine executes ALL orders even when cash is negative, leading to massive unrealistic debt.

### 2. No Leverage Modeling
Questions needing answers:
- Should we use gross exposure (|long| + |short|)?
- Can short proceeds fund long positions (implicit leverage)?
- What's realistic leverage limit for algorithmic trading?

### 3. Unclear Execution Sequencing
Open questions:
- Should exits fill before entries to free cash?
- When do exit proceeds become available (same-bar, next-bar, T+1)?
- How to handle position reversals (long → short)?
- Should we support partial fills when cash insufficient?

### 4. No Market Impact or Liquidity Constraints
- How to execute on zero-volume bars (overnight futures)?
- Do we need market impact for realistic modeling?
- Should we limit order size to % of volume?

## Core Design Questions for Reviewers

### Accounting Model
**Is this correct?**
```python
Account_Value = Cash + Σ(position_qty × current_price)
# Where long positions have positive qty, short have negative qty
```

**How do we enforce leverage?**
- Gross exposure: (|long_value| + |short_value|) / account_value < 2.0?
- Net leverage: (long_value - short_value) / cash?
- Buying power: margin account style?

### Execution Timeline
**For daily bars, is this correct?**
```
Day N 16:00: Market closes
Day N 16:00-23:59: Strategy generates orders
Day N+1 09:30: Market opens
  1. Execute all exit orders → update cash
  2. Execute all entry orders (using updated cash)
Day N+1 16:00: Market closes
```

### Build vs Buy Decision
**Options**:
1. Extend our engine (add accounting) - 2-4 weeks
2. Fork Backtrader (keep accounting, rewrite for speed) - 4-6 weeks
3. Adopt VectorBT (immediate, less flexible)
4. Hybrid (VectorBT for simple, our engine for complex)

**Need recommendation**: Which path makes sense?

## Next Steps

### Immediate (After Review)
1. **Await external feedback** on DESIGN_QUESTIONS.md
2. **Make build-vs-buy decision** based on expert input
3. **Define minimum viable scope** for realistic accounting

### If "Build" Decision
1. Implement cash constraint enforcement
2. Add leverage limit checking
3. Implement exit-before-entry sequencing
4. Add market impact model (if recommended)
5. Re-validate against VectorBT and Backtrader

### If "Adopt" Decision
1. Evaluate VectorBT Pro vs OSS
2. Test integration with our strategy API
3. Benchmark performance vs our engine
4. Document migration path

## Files Modified This Session

### New Files Created
```
DESIGN_QUESTIONS.md        - 41 questions for expert review
README_REVIEW.md           - Quick start for reviewers
```

### Renamed
```
src/ml4t/backtest/engine_v2.py → engine.py
tests/validation/test_engine_v2_validation.py → test_validation.py
```

### Updated
```
src/ml4t/backtest/__init__.py           - Updated import
tests/test_core.py                      - Updated import
tests/validation/test_validation.py     - All references updated
tests/validation/test_vectorbt_pro.py   - Updated import
README.md                               - Removed v2 refs, added warnings
DESIGN_QUESTIONS.md                     - All engine_v2 → engine
README_REVIEW.md                        - All engine_v2 → engine
```

## Technical Context

### Current Implementation
**File**: `src/ml4t/backtest/engine.py` (744 lines)
**Structure**:
- Order, Position, Fill (dataclasses)
- Broker (96 lines) - handles orders, positions, cash
- Engine (118 lines) - event loop orchestration
- ExecutionMode enum (SAME_BAR, NEXT_BAR)
- Commission/Slippage protocols

### Test Coverage
```
17 unit tests: 100% passing
Coverage: 82% (71 lines uncovered)
Validation tests: Reveal cash constraint bug
```

### Performance
```
32x faster than Backtrader
5.7x faster than VectorBT
Polars-based data handling
Event-driven with minimal overhead
```

## Open Questions

### For Reviewers
1. Is our proposed accounting identity correct?
2. What leverage definition should we use?
3. Should exits fill before entries?
4. Do we need market impact modeling?
5. Should we build this or adopt existing framework?

### For Ourselves (After Review)
1. How do we validate accounting without real broker fills?
2. What test scenarios reveal edge cases?
3. Should we match VectorBT, Backtrader, or both?
4. What's minimum scope for "realistic enough"?

## Session-Specific Notes

### VectorBT from_signals() Issues
- VectorBT OSS doesn't have `valuepercent100` size type (Pro only)
- Using `size_type='value'` with fixed dollar amounts worked
- Using `size=2, size_type='valuepercent100'` in Pro worked
- Trade quantities matched exactly after fixing sizing

### Validation Test Evolution
Started with trying to match VectorBT exactly, discovered fundamental differences in how frameworks handle cash constraints. This led to the realization that we need to design our accounting model properly rather than just "match" another framework.

### Repository Organization
```
backtest/
├── src/ml4t/backtest/
│   └── engine.py                    # THE implementation
├── tests/
│   ├── test_core.py                # 17/17 passing
│   └── validation/
│       ├── test_validation.py      # Framework comparison
│       └── test_vectorbt_pro.py    # Separate Pro test
├── archive/                         # Old 19,876-line code
├── DESIGN_QUESTIONS.md             # For reviewers
├── README_REVIEW.md                # Quick start
└── README.md                        # Main docs
```

## Memory Updates Needed

None - this is a transition-specific context. Design decisions will be recorded in permanent memory after external review is complete.

## Debugging Context

### VectorBT Sizing Discovery
The 50x quantity difference (10,149 vs 203) was because:
- VectorBT with `size_type='amount'` and `size=20000` bought $20k worth per asset
- But with `cash_sharing=True`, it was allocating across all assets
- Solution: Use `size_type='valuepercent100'` (Pro) or `size_type='value'` (OSS)

### Cash Constraint Bug Manifestation
When trying to open 50 positions × $20k each:
- Total required: $1M
- Available cash: $1M (minus commissions/slippage)
- Backtrader: Executes most orders, slight shortage → 0.39% diff
- VectorBT: Strictly limits to cash → -$3.9k PnL
- Our engine: Executes ALL, goes into debt → -$652k PnL

## Working Directory
```
/home/stefan/ml4t/software/backtest
```

## Git Status
```
On branch: feature/phase-1-ml-data-foundation

Modified files:
M  src/ml4t/backtest/__init__.py
R  src/ml4t/backtest/engine_v2.py → engine.py
M  tests/test_core.py
R  tests/validation/test_engine_v2_validation.py → test_validation.py
M  tests/validation/test_vectorbt_pro.py

New files:
A  DESIGN_QUESTIONS.md
A  README_REVIEW.md
M  README.md
```

## Key Learnings

1. **Validation is invaluable**: The framework comparison revealed fundamental design flaws we wouldn't have found otherwise.

2. **Speed without correctness is worthless**: 32x faster means nothing if accounting is wrong.

3. **Ask experts early**: Better to get design right before implementation than iterate through bugs.

4. **Clean presentation matters**: Removing "v2" baggage makes the review package more professional.

5. **Be honest about gaps**: The README now clearly states limitations and warnings.

## Continuation Instructions

When resuming this work:

1. **Check for external feedback** on DESIGN_QUESTIONS.md
2. **Review any responses** from trading system architects, framework developers, or researchers
3. **Make build-vs-buy decision** based on feedback
4. **If building**: Start with Part 5 implementation questions (cash update timing, leverage check timing)
5. **If adopting**: Evaluate VectorBT Pro vs OSS vs Backtrader fork

---

**Status**: ⏸️ Awaiting external architectural review
**Next milestone**: Design decision based on expert feedback
**Repository**: Clean and ready for review
**Tests**: All passing (17/17)
