# Handoff: 2025-11-20 00:02:23 UTC

## Executive Summary

**Session Focus**: Fix duplicate fill application bug causing position accumulation
**Status**: ✅ Major bugs fixed, ⚠️ Mystery accumulation pattern discovered
**Result**: Engine now completes without crashes, but returns +34,072% vs target +770%

**Critical Discovery**: We're repeating bug patterns from October 2025 (dual-state tracking drift).

---

## Current State

### What Works ✅
- ✅ Backtests complete successfully (no crashes)
- ✅ 16,736 events/sec throughput
- ✅ Duplicate fill application eliminated
- ✅ Event bus dispatch fixed (`publish()` → `dispatch_event()`)
- ✅ Strategy callback API corrected (`on_data_batch()` → `on_timestamp_batch()`)
- ✅ Comprehensive repository audit completed (1,817 files cataloged)

### What's Broken ⚠️
- ⚠️ Return: +34,072% (should be +770%) - **440x too high!**
- ⚠️ Final positions: 121 (should be ~25) - **5x too many**
- ⚠️ Position accumulation still happening despite `order_target_percent()` implementation
- ⚠️ Baseline manual loop broken (uses old `process_pending_orders()` API)

### Mystery Pattern
Even though we implemented `order_target_percent()` correctly with delta calculation:
```python
delta_qty = target_qty - current_qty  # Should prevent accumulation
```

...positions are STILL accumulating exponentially. This suggests:
1. Either `get_position()` returns stale/wrong data
2. Or fills are being applied multiple times in a different way we haven't found yet
3. Or risk manager is creating additional orders we're not tracking

---

## Files Modified This Session

### Critical Fixes (Commit `a71853e`)

**broker.py:1252** - Removed duplicate fill application
```python
# REMOVED: Direct portfolio application
# self._internal_portfolio.on_fill_event(fill_event)
# Now only dispatches to event bus
```

**broker.py:1293** - Added event bus dispatch
```python
# Dispatch fills to event bus (subscribers apply to portfolio)
if hasattr(self, 'event_bus') and self.event_bus:
    for fill_event in all_fills:
        self.event_bus.dispatch_event(fill_event)
```

**top25_using_engine.py:98** - Fixed callback API
```python
# BEFORE: on_data_batch(timestamp, market_map, context)
# AFTER:  on_timestamp_batch(timestamp, events, context)
```

**base.py:643,674** - Removed debug prints from `order_target_percent()`

### Repository Audit Results

**Created**: `REPOSITORY_AUDIT_2025-11-19.md` (28KB comprehensive analysis)

**Key Findings**:
- 1,817 files total (34.7MB, 934k lines)
- 65 production source files (clean, well-structured)
- 500 test files (comprehensive coverage)
- 104 transition files (1.3MB) ready for archival
- High-value discovery: `.claude/diagnostics/` contains trade comparison tools

**Pattern Identified**: This is the SECOND time we've hit dual-state tracking drift:
- **October**: `broker.position_tracker` vs `portfolio.positions` diverged
- **November**: `broker._internal_portfolio` vs `broker.portfolio` diverged (just fixed)

**Lesson**: Any time we track the SAME state in TWO places, even tiny differences compound to failure.

---

## Recent Decisions

### Architecture Fixes

1. **Single Event Bus Flow** - Fills now follow single path:
   ```
   Broker creates fill → dispatch_event() → Portfolio receives once
   ```
   Previously: Broker applied fill directly AND published to event bus (double application).

2. **Unified Portfolio Instances** - Both `_internal_portfolio` and `portfolio` now point to SAME object:
   ```python
   # broker.py:1458
   self._internal_portfolio = portfolio  # Makes them the same object
   self.portfolio = portfolio
   ```

3. **Strategy Batch API** - Standardized on `on_timestamp_batch()` (base class API):
   ```python
   def on_timestamp_batch(self, timestamp: datetime, events: list[MarketEvent], context: dict)
   ```

### Repository Cleanup Strategy

**Immediate archival candidates** (~1.8MB reduction):
- 94 old transitions (Oct 4 - Nov 17) → `.claude/transitions/archived/`
- 5 completed work streams → `.claude/work/completed/`
- Root completion reports → `.claude/work/completed/`
- Duplicate resources → Delete `resources/resources/`

**Keep (critical debugging context)**:
- `.claude/work/current/004_vectorbt_exact_matching/` - Position sizing analysis
- `.claude/diagnostics/` - Trade comparison tools
- `.claude/code_review/20251119/` - Expert reviews
- `.claude/work/BATCH_PROCESSING_REFACTOR_PLAN.md` - Current work plan

---

## Active Challenges

### Mystery #1: Position Accumulation Despite Delta Calculation

**Expected behavior**:
```python
# order_target_percent() implementation (base.py:640)
current_qty = self.get_position(asset_id)  # Get current
delta_qty = target_qty - current_qty       # Calculate delta
# Submit order for delta only
```

**Actual behavior**:
- 121 final positions (should be 25)
- +34,072% return (should be +770%)
- Return increased 440x from last run (+75% → +34k%)

**Hypothesis**:
1. `get_position()` may be returning 0 when positions exist (stale data)
2. Fills might be applied multiple times through a different code path
3. Risk manager might be creating additional orders we're not seeing

**Evidence needed**:
- Add debug logging to `get_position()` and `order_target_percent()`
- Compare fills applied vs fills generated
- Check if risk manager is creating duplicate orders

### Mystery #2: Why Return Jumped 440x

**Progression**:
- Before fixes: +75% (position accumulation with `buy_percent()`)
- After fixes: +34,072% (position accumulation with `order_target_percent()`)

**This doesn't make sense** - fixing duplicate fill application should REDUCE returns, not increase them 440x.

**Possible causes**:
1. Dispatch timing - fills now applied at different point in event loop
2. Portfolio equity calculation changed (affects position sizing)
3. Strategy seeing different portfolio state than before
4. Risk manager behavior changed

### Mystery #3: Historical Pattern Repetition

From `LAYER2_POSITION_MANAGEMENT.md` (Oct 28):
> "Position sizing was 9.4x larger (2.15 BTC vs 0.23 BTC)"
> "ml4t.backtest avg PnL is 14x higher per trade ($67 vs $4.66)"

**This is the EXACT same pattern we see now**:
- Positions too large by ~10x
- Returns too high by ~10x+

**The bug was "fixed" in October but the SAME pattern reappeared in November.**

**Hypothesis**: The root cause was never actually fixed - only symptoms were treated.

---

## Useful Discoveries from Audit

### 1. Diagnostic Tools (`.claude/diagnostics/`)

**analyze_trade_difference.py** (5.5KB, 167 lines)
```bash
# Compare engine vs manual loop trades
python .claude/diagnostics/analyze_trade_difference.py \
  trades_engine.parquet trades_manual.parquet
```

**Use this** to validate what's different between working manual loop and broken engine.

### 2. VectorBT Behavior Spec

**vectorbt_behavior_spec.md** documents exact rebalancing logic:
```python
# VectorBT from_signals() behavior:
# 1. Calculates target quantity from target percent
# 2. Gets current position quantity
# 3. Calculates delta = target - current
# 4. Only trades the delta (not the full target)
```

This is EXACTLY what `order_target_percent()` should do (and claims to do).

### 3. Trade Gap Analysis Methodology

**TRADE_GAP_ANALYSIS.md** shows how to investigate position sizing:
1. Export trade logs to Parquet
2. Compare quantities between frameworks
3. Analyze P&L per trade
4. Check for re-entry patterns

**Apply this methodology** to current engine vs manual loop comparison.

---

## Next Steps (Priority Order)

### IMMEDIATE: Debug Position Accumulation

**Step 1**: Add comprehensive logging to `order_target_percent()`
```python
# base.py:640
current_qty = self.get_position(asset_id)
print(f"DEBUG {asset_id}: current={current_qty} target={target_qty} delta={delta_qty}")
```

**Step 2**: Compare first rebalance (should be ~25 orders):
```bash
python examples/integrated/top25_using_engine.py 2>&1 | grep "REBALANCE 1" -A 30
```

**Step 3**: Check if `broker.get_position()` returns correct values:
```python
# broker.py:1327 - Add logging
position = self._internal_portfolio.get_position(asset_id)
qty = position.quantity if position else 0.0
print(f"BROKER get_position({asset_id}): {qty}")
return qty
```

**Expected**: First rebalance creates ~25 positions at 4% each. Subsequent rebalances should show:
- Exits for assets dropping out of top 25
- Small adjustments for assets staying in top 25
- New entries for assets entering top 25

**If we see**: All positions showing `current=0` even when they exist, then `get_position()` is broken.

### HIGH: Compare with Baseline Manual Loop

**Step 1**: Fix baseline manual loop (uses old API)
```python
# examples/integrated/top25_ml_strategy_complete.py
# Replace: broker.process_pending_orders()
# With: broker.process_batch_fills(timestamp, market_map)
```

**Step 2**: Run both and compare:
```bash
# Baseline (should show +770%)
python examples/integrated/top25_ml_strategy_complete.py > baseline.log 2>&1

# Engine (currently shows +34k%)
python examples/integrated/top25_using_engine.py > engine.log 2>&1

# Compare
diff baseline.log engine.log | grep -E "Fill|Position|Return"
```

**Step 3**: Use diagnostic tool:
```bash
python .claude/diagnostics/analyze_trade_difference.py \
  baseline_trades.parquet engine_trades.parquet
```

### MEDIUM: Repository Cleanup

Execute archival plan from audit:
```bash
# Archive old transitions
mkdir -p .claude/transitions/archived/2025-10-04_to_2025-11-17
mv .claude/transitions/2025-10-{04,27,28} .claude/transitions/archived/2025-10-04_to_2025-11-17/
mv .claude/transitions/2025-11-0{4,5,11,12,13,14,15,16,17} .claude/transitions/archived/2025-10-04_to_2025-11-17/

# Archive completed work
mkdir -p .claude/work/completed/
mv .claude/work/current/00{2,3,5,6,7}_* .claude/work/completed/

# Delete duplicates
rm -rf resources/resources/
rm coverage.json
```

**Impact**: ~1.8MB reduction, cleaner repo for external code review.

---

## Investigation Questions

1. **Why does `get_position()` return wrong values?**
   - Is portfolio state updated before strategy runs?
   - Is `_internal_portfolio` pointing to correct object?
   - Are positions being cleared between rebalances?

2. **Why did return jump 440x after fixing duplicate fills?**
   - What changed in event loop timing?
   - How is portfolio equity calculated?
   - When does strategy see portfolio updates?

3. **Why are we repeating October's bug pattern?**
   - Was the original fix incomplete?
   - Is there a different code path with same issue?
   - Are we looking at symptoms instead of root cause?

---

## Open Questions

1. **Position Query Timing**: When strategy calls `get_position()`, are fills from current batch already applied?

2. **Event Bus Dispatch**: Does `dispatch_event()` apply fills synchronously or asynchronously?

3. **Risk Manager Interference**: Is risk manager creating additional orders that accumulate?

4. **Portfolio Equity**: How is equity calculated? Does it include unrealized P&L from positions?

5. **Execution Delay**: Are pending orders being activated at correct time (T+1)?

---

## Session Context

**Working Directory**: `/home/stefan/ml4t/software/backtest/`
**Branch**: `feature/phase-1-ml-data-foundation`
**Virtual Environment**: `.venv` (active)
**Last Commit**: `a71853e` - "fix: Eliminate duplicate fill application causing infinite returns"

**Last Test Run**:
```
Final value: $341,725,262.65
Total return: 34072.53%
Final positions: 121
Rebalances: 239
Throughput: 16,736 events/second
```

**Target Metrics** (from manual loop):
```
Total return: +770.13%
Final positions: 20-30
Rebalances: 239
```

**Work Plan**: `.claude/work/BATCH_PROCESSING_REFACTOR_PLAN.md` (TASK 1 implemented but not working correctly)

**Related Handoff**: `.claude/transitions/2025-11-19/233725.md` (previous session's dual-portfolio fix)

**Audit Report**: `REPOSITORY_AUDIT_2025-11-19.md` (28KB, comprehensive file catalog)

---

## Critical References

### Documentation
- `.claude/work/BATCH_PROCESSING_REFACTOR_PLAN.md` - Implementation plan (10 tasks)
- `.claude/code_review/20251119/response_01.md` - Expert review #1 (architecture)
- `.claude/code_review/20251119/response_02.md` - Expert review #2 (diagnosis)
- `.claude/work/current/004_vectorbt_exact_matching/LAYER2_POSITION_MANAGEMENT.md` - October's dual-tracking bug
- `.claude/work/current/004_vectorbt_exact_matching/TRADE_GAP_ANALYSIS.md` - Position sizing investigation
- `.claude/work/current/004_vectorbt_exact_matching/vectorbt_behavior_spec.md` - Correct rebalancing spec

### Code
- `src/ml4t/backtest/strategy/base.py:640` - `order_target_percent()` implementation
- `src/ml4t/backtest/execution/broker.py:1252` - Fill application (removed direct call)
- `src/ml4t/backtest/execution/broker.py:1293` - Event bus dispatch (added)
- `src/ml4t/backtest/execution/broker.py:1327` - `get_position()` implementation
- `src/ml4t/backtest/engine.py:497` - `process_batch_fills()` call
- `examples/integrated/top25_using_engine.py:98` - Strategy batch callback

### Tools
- `.claude/diagnostics/analyze_trade_difference.py` - Trade comparison tool
- `.claude/diagnostics/debug_signal_alignment.py` - Signal timing debugger
- `.claude/diagnostics/verify_alignment.py` - Quick smoke test

---

## Patterns Learned This Session

### Pattern #1: Dual-State Tracking Always Drifts

**Definition**: Tracking the SAME state in TWO separate objects/locations

**Examples**:
- October: `broker.position_tracker` vs `portfolio.positions`
- November: `broker._internal_portfolio` vs `broker.portfolio`
- Current (suspected): `get_position()` cache vs actual portfolio state

**Solution**: Single source of truth - make "duplicates" point to SAME object, not copies.

### Pattern #2: Symptom Fixes vs Root Cause

**Observation**: We "fixed" dual-portfolio drift in October, but same pattern reappeared in November.

**Hypothesis**: We treated symptoms (unified specific instances) but didn't address root cause (architecture allows dual tracking).

**Needed**: Architectural principle that PREVENTS dual-state tracking by design.

### Pattern #3: Event-Driven Timing Bugs

**Problem**: When events are dispatched, timing of state updates matters critically.

**Example**: Portfolio must be updated BEFORE strategy queries positions, but AFTER broker generates fills.

**Solution**: Explicit phase ordering in event loop:
1. Broker generates fills
2. Fills dispatch to portfolio (updates state)
3. Strategy queries portfolio (sees updated state)
4. Strategy submits new orders

**Current suspect**: Step 2-3 ordering may be broken.

---

## Commands to Resume Work

```bash
cd /home/stefan/ml4t/software/backtest
source .venv/bin/activate

# Add debug logging to order_target_percent
# Edit: src/ml4t/backtest/strategy/base.py:640

# Run with logging
python examples/integrated/top25_using_engine.py 2>&1 | tee debug.log

# Check first rebalance
grep "REBALANCE" debug.log | head -30

# Check position queries
grep "current_qty" debug.log | head -50
```

---

**Created**: 2025-11-20 00:02:23 UTC
**Session Progress**: Major architecture fixes completed, mysterious accumulation pattern discovered
**Ready for**: Deep debugging with comprehensive logging to find why delta calculation isn't working
