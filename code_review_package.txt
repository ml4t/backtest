This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.py, examples/integrated/*.py, *.md, pyproject.toml, src/**/*.py, tests/**/*.py, CODE_REVIEW_PROMPT.md, pyproject.toml
- Files matching these patterns are excluded: tests/**, **/__pycache__/**, **/*.pyc, .venv/**, *.egg-info/**, .pytest_cache/**, examples/integrated/data/**, docs/sphinx/build/**, .git/**
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  ml4t/
    backtest/
      accounting/
        __init__.py
        account.py
        gatekeeper.py
        models.py
        policy.py
      __init__.py
      broker.py
      config.py
      datafeed.py
      engine.py
      models.py
      strategy.py
      types.py
CHANGELOG.md
CLAUDE.md
CODE_REVIEW_PROMPT.md
pyproject.toml
README.md
REPOSITORY_AUDIT.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="CODE_REVIEW_PROMPT.md">
# Code Review Request: ml4t.backtest Engine

## What We're Building

An event-driven backtesting engine for quantitative trading strategies with:
- Institutional-grade execution fidelity
- Point-in-time correctness (no look-ahead bias)
- Configurable behavior to match other frameworks (VectorBT, Backtrader, Zipline)
- Support for ML-driven signals

## What to Review

Please review the implementation for:

### 1. **Core Execution Logic Correctness**
- `src/ml4t/backtest/broker.py` - Order execution, position tracking, fill simulation
- `src/ml4t/backtest/engine.py` - Event loop orchestration
- Are fills calculated correctly within OHLC bounds?
- Is position tracking consistent across buy/sell operations?

### 2. **Accounting & Constraints**
- `src/ml4t/backtest/accounting/` - Account policies (cash vs margin)
- `src/ml4t/backtest/accounting/gatekeeper.py` - Order validation
- Are buying power calculations correct for cash accounts?
- Are margin requirements properly enforced?

### 3. **Data Flow**
- `src/ml4t/backtest/datafeed.py` - Price + signal data iteration
- `src/ml4t/backtest/types.py` - Core data structures
- Is the strategy receiving correct OHLCV + signals at each timestamp?

### 4. **Configuration System**
- `src/ml4t/backtest/config.py` - Centralized configuration
- `src/ml4t/backtest/models.py` - Commission/slippage models
- Are the preset configurations reasonable defaults?

### 5. **API Design**
- `src/ml4t/backtest/strategy.py` - Strategy interface
- `src/ml4t/backtest/__init__.py` - Public API exports
- Is the strategy interface intuitive for users?
- Are the right things exported at the package level?

## Key Use Cases to Consider

1. **Single-asset, long-only strategy with ML signals**
   ```python
   class MLStrategy(Strategy):
       def on_data(self, timestamp, data, context, broker):
           signal = data["AAPL"]["signals"]["ml_score"]
           if signal > 0.7 and broker.get_position("AAPL") is None:
               broker.submit_order("AAPL", 100)
   ```

2. **Multi-asset with position sizing**
   - Equal-weighted across assets
   - Cash constraint enforcement

3. **Event-driven entries and exits**
   - Stop-loss and take-profit
   - Trailing stops

## Known Limitations

- No bracket orders (OCO, OTO) yet
- No multi-leg strategies (pairs, spreads)
- Execution assumes daily bars (no intraday simulation yet)

## What We DON'T Want

- Over-engineering or premature abstraction
- Excessive error handling for impossible states
- Documentation for documentation's sake

## Files Included

```
src/ml4t/backtest/
├── __init__.py          - Package exports
├── broker.py            - Core execution
├── config.py            - Configuration
├── datafeed.py          - Data iteration
├── engine.py            - Event loop
├── models.py            - Commission/slippage
├── strategy.py          - Strategy interface
├── types.py             - Core types
└── accounting/
    ├── account.py       - Account state
    ├── gatekeeper.py    - Order validation
    ├── models.py        - Position model
    └── policy.py        - Account policies

tests/
├── test_core.py         - Engine tests
└── accounting/          - Accounting tests
```

## Output Expected

Please provide:
1. **Bugs found** - Critical issues that would cause incorrect results
2. **Design concerns** - Architectural issues or code smells
3. **Improvement suggestions** - Nice-to-haves for later
4. **Questions** - Anything unclear about intent or design
</file>

<file path="REPOSITORY_AUDIT.md">
# Repository Audit - 2025-11-22

## Current State: CHAOS

### Line Count Breakdown

| Directory | Lines | % of Total | Status |
|-----------|-------|------------|--------|
| **src/** | 2,735 | 0.4% | KEEP - Core engine |
| **tests/accounting/** | 2,186 | 0.3% | KEEP - Unit tests |
| **tests/test_core.py** | 501 | <0.1% | KEEP - Unit tests |
| **tests/validation/** | 32,643 | 4.4% | REVIEW - Mostly bloat |
| **archive/** | 69,889 | 9.5% | DELETE - Already archived |
| **resources/** | 630,843 | 85.3% | MOVE OUT - Reference code |
| **Total** | 739,544 | 100% | |

### Core Engine (KEEP): 2,735 lines

```
src/ml4t/backtest/
├── __init__.py              (92)   - Package exports
├── broker.py                (463)  - Core broker logic
├── config.py                (439)  - Configuration
├── datafeed.py              (89)   - Data feed
├── engine.py                (263)  - Backtest engine
├── models.py                (111)  - Data models
├── strategy.py              (28)   - Strategy base
├── types.py                 (100)  - Type definitions
└── accounting/
    ├── __init__.py          (27)
    ├── account.py           (223)
    ├── gatekeeper.py        (272)
    ├── models.py            (92)
    └── policy.py            (536)
```

### Tests to KEEP: ~3,200 lines

```
tests/
├── __init__.py
├── test_core.py             (501)  - Core engine tests
├── accounting/
│   ├── test_account.py
│   ├── test_gatekeeper.py   (518)
│   ├── test_models.py
│   └── test_policy.py
└── conftest.py              (shared fixtures)
```

### Validation Directory: NEEDS COMPLETE RESTRUCTURE

Current state (32,643 lines):
- 27 markdown report files (DELETE - historical noise)
- 50+ Python files (REVIEW each)
- Multiple duplicated scripts
- Debug scripts that should never have been committed

## Proposed Clean Structure

```
backtest/
├── src/ml4t/backtest/       # Core engine (2,735 lines)
├── tests/                   # Unit/integration tests
│   ├── conftest.py
│   ├── test_core.py
│   └── accounting/
├── validation/              # Per-framework validation (SEPARATE from pytest)
│   ├── README.md            # Validation strategy document
│   ├── common/              # Shared utilities
│   │   ├── data.py          # Test data generation
│   │   ├── signals.py       # Signal generation
│   │   └── compare.py       # Trade/P&L comparison
│   ├── vectorbt_pro/        # VectorBT Pro validation
│   │   ├── venv/            # Dedicated venv (or symlink)
│   │   ├── run_validation.py
│   │   └── scenarios/       # Test scenarios
│   ├── backtrader/          # Backtrader validation
│   │   ├── venv/
│   │   ├── run_validation.py
│   │   └── scenarios/
│   └── zipline/             # Zipline validation (optional)
├── docs/                    # Documentation
├── pyproject.toml
└── CLAUDE.md
```

## Files to DELETE

### 1. archive/ directory (69,889 lines)
Already archived, should be removed entirely or moved to a separate repo.

### 2. resources/ directory (630,843 lines)
Reference framework source code. Should be:
- Moved to a separate location outside this repo
- Downloaded on-demand when needed for reference

### 3. tests/validation/ cleanup

**DELETE - Markdown reports (27 files):**
- ADAPTER_IMPLEMENTATION_GUIDE.md
- ALIGNMENT_SUCCESS_REPORT.md
- BACKTRADER_ALIGNMENT_SUCCESS.md
- COMPREHENSIVE_VALIDATION_REPORT.md
- FRAMEWORK_ALIGNMENT_RESULTS.md
- FRAMEWORK_GUIDE.md
- INTEGRATED_VALIDATION_STATUS.md
- NEXT_OPEN_FIX_DESIGN.md
- PROGRESS_REPORT.md
- RECONCILIATION_FINDINGS.md
- SIGNAL_BASED_VALIDATION.md
- SIGNAL_BASED_VALIDATION_PLAN.md
- SIGNAL_DIVERSITY_RESULTS.md
- SIGNAL_VALIDATION_ARCHITECTURE.md
- STATUS.md
- SYSTEMATIC_DIFFERENCES_ANALYSIS.md
- TASK-001_COMPLETION_REPORT.md
- TASK-003_COMPLETION_REPORT.md
- TRADE_COMPARISON_DESIGN.md
- VALIDATION_ARCHITECTURE.md
- VALIDATION_FINDINGS.md
- VALIDATION_REPORT.md
- VALIDATION_RESULTS.md
- VALIDATION_ROADMAP.md
- VALIDATION_SUMMARY.md
- VARIANCE_ANALYSIS.md
- VECTORBTPRO_INITIAL_FINDINGS.md

**DELETE - Debug/temporary scripts:**
- analyze_trade_variance.py
- analyze_variance.py
- check_final_trades.py
- check_vectorbt_34th_trade.py
- debug_final_signal.py
- debug_multi_asset.py
- debug_vectorbt_real.py
- debug_vectorbt_trades.py
- detailed_trade_comparison.py
- diagnose_differences.py
- diagnose_execution_timing.py
- expose_the_truth.py
- final_truth_test.py
- quick_test.py
- simple_trade_comparison.py
- verify_actual_agreement.py
- verify_vectorbt_execution.py
- verify_vectorbt_real.py
- zipline_bundle_free_example.py
- trade_comparison_fixed.txt
- trade_comparison_output.txt
- coverage.json

**DELETE - Redundant directories:**
- baselines/
- comparison/
- docs/
- htmlcov/
- results/
- test_cases/

## Action Plan

### Phase 1: Immediate Cleanup
1. Delete `archive/` directory
2. Move `resources/` outside repo (or delete - can be re-downloaded)
3. Delete all markdown reports in tests/validation/
4. Delete all debug scripts in tests/validation/

### Phase 2: Restructure Validation
1. Create new `validation/` directory at repo root
2. Move only essential adapters and test infrastructure
3. One directory per framework with isolated venv
4. Document validation strategy

### Phase 3: Verify Quality
1. Run pre-commit (ruff, mypy)
2. Ensure all kept tests pass
3. Prepare code review package

## Expected Final State

| Directory | Lines | Purpose |
|-----------|-------|---------|
| src/ | 2,735 | Core backtest engine |
| tests/ | ~3,000 | Unit tests (pytest) |
| validation/ | ~2,000 | Per-framework validation scripts |
| docs/ | ~500 | Essential documentation |
| **Total** | ~8,000 | Clean, focused codebase |

**Reduction: 739,544 → ~8,000 lines (99% reduction)**
</file>

<file path="src/ml4t/backtest/accounting/__init__.py">
"""Accounting module for backtesting engine.

Provides proper accounting constraints for both cash accounts (no leverage, no shorts)
and margin accounts (leverage enabled, shorts allowed).

Key Components:
- Position: Unified position tracking with cost basis
- AccountPolicy: Interface for account type constraints
- CashAccountPolicy: Cash account constraints (cash >= 0, no shorts)
- MarginAccountPolicy: Margin account constraints (NLV/BP/MM calculations)
- AccountState: Account state management and position tracking
- Gatekeeper: Order validation before execution
"""

from .account import AccountState
from .gatekeeper import Gatekeeper
from .models import Position
from .policy import AccountPolicy, CashAccountPolicy, MarginAccountPolicy

__all__ = [
    "Position",
    "AccountPolicy",
    "CashAccountPolicy",
    "MarginAccountPolicy",
    "AccountState",
    "Gatekeeper",
]
</file>

<file path="src/ml4t/backtest/accounting/account.py">
"""Account state management.

This module provides the AccountState class that tracks cash, positions, and
delegates validation to the appropriate AccountPolicy.
"""

from .models import Position
from .policy import AccountPolicy


class AccountState:
    """Account state ledger with policy-based constraints.

    AccountState is the central ledger that tracks:
    - Cash balance
    - Open positions
    - Account policy (cash vs margin)

    It delegates all validation and constraint checking to the AccountPolicy,
    making it easy to support different account types.

    Example:
        >>> from ml4t.backtest.accounting import AccountState, CashAccountPolicy
        >>> policy = CashAccountPolicy()
        >>> account = AccountState(initial_cash=100000.0, policy=policy)
        >>> account.buying_power
        100000.0
    """

    def __init__(self, initial_cash: float, policy: AccountPolicy):
        """Initialize account state.

        Args:
            initial_cash: Starting cash balance
            policy: AccountPolicy instance (CashAccountPolicy or MarginAccountPolicy)
        """
        self.cash = initial_cash
        self.positions: dict[str, Position] = {}
        self.policy = policy

    @property
    def total_equity(self) -> float:
        """Calculate total account equity (Net Liquidating Value).

        For both cash and margin accounts:
            NLV = Cash + Σ(position.market_value)

        Returns:
            Total account equity
        """
        return self.cash + sum(p.market_value for p in self.positions.values())

    @property
    def buying_power(self) -> float:
        """Calculate available buying power for new long positions.

        Delegates to policy:
        - Cash account: buying_power = max(0, cash)
        - Margin account: buying_power = (NLV - MM) / initial_margin_rate

        Returns:
            Available buying power in dollars
        """
        return self.policy.calculate_buying_power(self.cash, self.positions)

    def allows_short_selling(self) -> bool:
        """Check if short selling is allowed.

        Delegates to policy:
        - Cash account: False
        - Margin account: True

        Returns:
            True if short selling allowed, False otherwise
        """
        return self.policy.allows_short_selling()

    def mark_to_market(self, current_prices: dict[str, float]) -> None:
        """Update positions with current market prices.

        This is called at the end of each bar to update unrealized P&L.

        Args:
            current_prices: Dictionary mapping asset -> current_price
        """
        for asset, position in self.positions.items():
            if asset in current_prices:
                position.current_price = current_prices[asset]

    def get_position(self, asset: str) -> Position | None:
        """Get position for a specific asset.

        Args:
            asset: Asset identifier

        Returns:
            Position object if exists, None otherwise
        """
        return self.positions.get(asset)

    def get_position_quantity(self, asset: str) -> float:
        """Get quantity for a specific asset (0 if no position).

        Args:
            asset: Asset identifier

        Returns:
            Position quantity (positive=long, negative=short, 0=flat)
        """
        pos = self.positions.get(asset)
        return pos.quantity if pos else 0.0

    def apply_fill(self, asset: str, quantity_delta: float, fill_price: float, timestamp) -> float:
        """Apply a fill to the account, updating position and cash.

        This method handles both long and short positions correctly:
        - Long positions (quantity > 0): Cash decreases when buying, increases when selling
        - Short positions (quantity < 0): Cash increases when shorting, decreases when covering

        Args:
            asset: Asset identifier
            quantity_delta: Signed quantity change (positive=buy, negative=sell/short)
            fill_price: Fill price per unit
            timestamp: Fill timestamp

        Returns:
            Cash change (positive=cash in, negative=cash out)

        Examples:
            Open long (buy 100 @ $150):
                quantity_delta=+100, fill_price=$150
                cash_change = -$15,000 (paid to buy)

            Close long (sell 100 @ $160):
                quantity_delta=-100, fill_price=$160
                cash_change = +$16,000 (received from sale)

            Open short (sell 100 @ $150):
                quantity_delta=-100, fill_price=$150
                cash_change = +$15,000 (proceeds from short sale)

            Close short (buy 100 @ $145):
                quantity_delta=+100, fill_price=$145
                cash_change = -$14,500 (paid to cover short)

        Note:
            Commission should be handled separately by the caller.
            This method only handles the asset position and base cash flow.
        """

        # Calculate cash flow: negative for buys, positive for sells/shorts
        # Formula: cash_change = -quantity_delta × fill_price
        # Works for both longs and shorts:
        #   - Buy (quantity_delta > 0): cash decreases (negative change)
        #   - Sell/Short (quantity_delta < 0): cash increases (positive change)
        cash_change = -quantity_delta * fill_price

        # Update cash balance
        self.cash += cash_change

        # Update position
        pos = self.positions.get(asset)
        if pos is None:
            # New position (long or short)
            if quantity_delta != 0:
                self.positions[asset] = Position(
                    asset=asset,
                    quantity=quantity_delta,
                    avg_entry_price=fill_price,
                    current_price=fill_price,
                    entry_time=timestamp,
                    bars_held=0,
                )
        else:
            # Existing position - update quantity and cost basis
            old_qty = pos.quantity
            new_qty = old_qty + quantity_delta

            if new_qty == 0:
                # Position fully closed
                del self.positions[asset]
            elif (old_qty > 0 and new_qty < 0) or (old_qty < 0 and new_qty > 0):
                # Position reversal (long → short or short → long)
                # Close old position, open new position in opposite direction
                del self.positions[asset]
                self.positions[asset] = Position(
                    asset=asset,
                    quantity=new_qty,
                    avg_entry_price=fill_price,
                    current_price=fill_price,
                    entry_time=timestamp,
                    bars_held=0,
                )
            elif abs(new_qty) > abs(old_qty):
                # Adding to existing position (same direction)
                # Update weighted average entry price
                old_cost = abs(old_qty) * pos.avg_entry_price
                new_cost = abs(quantity_delta) * fill_price
                total_cost = old_cost + new_cost
                pos.avg_entry_price = total_cost / abs(new_qty)
                pos.quantity = new_qty
            else:
                # Partial close (reducing position size)
                # Entry price remains unchanged for partial closes
                pos.quantity = new_qty

        return cash_change

    def __repr__(self) -> str:
        """String representation for debugging."""
        policy_name = self.policy.__class__.__name__
        num_positions = len(self.positions)
        return (
            f"AccountState("
            f"cash=${self.cash:,.2f}, "
            f"equity=${self.total_equity:,.2f}, "
            f"positions={num_positions}, "
            f"policy={policy_name})"
        )
</file>

<file path="src/ml4t/backtest/accounting/gatekeeper.py">
"""Order validation gatekeeper.

This module provides the Gatekeeper class that validates orders before execution,
ensuring they meet account policy constraints and preventing invalid trades.
"""

from ..models import CommissionModel
from ..types import Order, OrderSide
from .account import AccountState


class Gatekeeper:
    """Pre-execution order validation to enforce account constraints.

    The Gatekeeper is the critical component that prevents invalid orders from
    executing. It checks account policy constraints (cash limits, short selling,
    margin requirements) BEFORE orders are filled.

    Key Responsibilities:
    - Validate orders against account policy constraints
    - Distinguish reducing (exit) orders from opening (entry) orders
    - Include commission in cost calculations
    - Prevent unlimited debt bug (line 587 in engine.py)

    Example:
        >>> from ml4t.backtest.accounting import AccountState, CashAccountPolicy, Gatekeeper
        >>> from ml4t.backtest.engine import Order, OrderSide, OrderType, PercentageCommission
        >>> policy = CashAccountPolicy()
        >>> account = AccountState(initial_cash=100000.0, policy=policy)
        >>> commission_model = PercentageCommission(rate=0.001)
        >>> gatekeeper = Gatekeeper(account, commission_model)
        >>>
        >>> # Validate a buy order
        >>> order = Order(asset="AAPL", side=OrderSide.BUY, quantity=100)
        >>> valid, reason = gatekeeper.validate_order(order, price=150.0)
        >>> print(valid)  # True (have enough cash)
    """

    def __init__(self, account: AccountState, commission_model: CommissionModel):
        """Initialize gatekeeper with account and commission model.

        Args:
            account: AccountState instance to validate against
            commission_model: CommissionModel for calculating transaction costs
        """
        self.account = account
        self.commission_model = commission_model

    def validate_order(self, order: Order, price: float) -> tuple[bool, str]:
        """Validate order before execution.

        This is the main validation entry point called by the Broker before
        executing any order. It performs the following checks:

        1. Detect position reversals (long→short or short→long)
        2. Check if order is reducing existing position
        3. Reducing orders always approved (closing positions frees capital)
        4. Opening orders and reversals validated via account policy
        5. Commission included in cost calculation

        Args:
            order: Order to validate
            price: Expected fill price

        Returns:
            (is_valid, rejection_reason) tuple:
                - is_valid: True if order can proceed, False if rejected
                - rejection_reason: Human-readable explanation (empty if valid)

        Examples:
            Reducing order (always approved):
                >>> # Current: Long 100 shares, Order: Sell 50
                >>> valid, reason = gatekeeper.validate_order(sell_order, 150.0)
                >>> assert valid == True
                >>> assert reason == ""

            Position reversal (cash account):
                >>> # Current: Long 100, Order: Sell 150 (reverse to short 50)
                >>> valid, reason = gatekeeper.validate_order(sell_order, 150.0)
                >>> assert valid == False
                >>> assert "Position reversal not allowed" in reason

            Position reversal (margin account):
                >>> # Current: Long 100, Order: Sell 150 (reverse to short 50)
                >>> valid, reason = gatekeeper.validate_order(sell_order, 150.0)
                >>> # valid depends on buying power for new short 50 position

            Opening order (validated):
                >>> # No position, Order: Buy 100 shares @ $150
                >>> valid, reason = gatekeeper.validate_order(buy_order, 150.0)
                >>> # valid depends on cash: need $15,000 + commission

            Rejected order:
                >>> # Cash account trying to short
                >>> short_order = Order(asset="AAPL", side=OrderSide.SELL, quantity=100)
                >>> valid, reason = gatekeeper.validate_order(short_order, 150.0)
                >>> assert valid == False
                >>> assert "Short selling not allowed" in reason
        """
        # Get current position quantity (0 if no position)
        current_qty = self.account.get_position_quantity(order.asset)

        # Determine order direction (positive=buy, negative=sell)
        order_qty_delta = self._calculate_quantity_delta(order.side, order.quantity)

        # Check for position reversal (long→short or short→long)
        # This is a special case that requires different validation
        if self._is_reversal(current_qty, order_qty_delta):
            # Cash accounts don't allow reversals (no short selling)
            if not self.account.policy.allows_short_selling():
                return False, "Position reversal not allowed in cash account"

            # Margin accounts: Reversal is conceptually split into:
            # 1. Close existing position (always approved - reduces risk)
            # 2. Open new opposite position (must validate buying power)
            #
            # We validate via validate_position_change which correctly handles
            # the buying power requirement for the new opposite position
            commission = self.commission_model.calculate(order.asset, order.quantity, price)
            return self.account.policy.validate_position_change(
                asset=order.asset,
                current_quantity=current_qty,
                quantity_delta=order_qty_delta,
                price=price,
                current_positions=self.account.positions,
                cash=self.account.cash - commission,
            )

        # Check if this is a reducing order (closing/reducing existing position)
        if self._is_reducing_order(current_qty, order_qty_delta):
            # Reducing orders always allowed (frees up capital)
            return True, ""

        # This is an opening order (new position or adding to existing)
        # Calculate commission to include in cost
        commission = self.commission_model.calculate(order.asset, order.quantity, price)

        # Validate based on whether we have an existing position
        if current_qty == 0.0:
            # New position - use validate_new_position
            new_qty = order_qty_delta  # Full order quantity
            return self.account.policy.validate_new_position(
                asset=order.asset,
                quantity=new_qty,
                price=price,
                current_positions=self.account.positions,
                cash=self.account.cash - commission,  # Account for commission cost
            )
        else:
            # Adding to existing position - use validate_position_change
            return self.account.policy.validate_position_change(
                asset=order.asset,
                current_quantity=current_qty,
                quantity_delta=order_qty_delta,
                price=price,
                current_positions=self.account.positions,
                cash=self.account.cash - commission,  # Account for commission cost
            )

    def _is_reversal(self, current_qty: float, order_qty_delta: float) -> bool:
        """Check if order reverses position (long → short or short → long).

        A reversal occurs when an order causes the position to change sign,
        creating a new opposite position. This is distinct from simply closing
        a position (where the result would be zero or same sign).

        Args:
            current_qty: Current position quantity (positive=long, negative=short)
            order_qty_delta: Order quantity delta (positive=buy, negative=sell)

        Returns:
            True if order reverses position, False otherwise

        Examples:
            Reversals (returns True):
                >>> gatekeeper._is_reversal(100, -150)  # Long 100, sell 150 → short 50
                True
                >>> gatekeeper._is_reversal(-100, 150)  # Short 100, buy 150 → long 50
                True

            Non-reversals (returns False):
                >>> gatekeeper._is_reversal(0, 100)     # No position, buy 100
                False
                >>> gatekeeper._is_reversal(100, -100)  # Long 100, sell 100 → flat
                False
                >>> gatekeeper._is_reversal(100, -50)   # Long 100, sell 50 → long 50
                False
                >>> gatekeeper._is_reversal(100, 50)    # Long 100, buy 50 → long 150
                False

        Note:
            Position reversals are only allowed in margin accounts. Cash accounts
            do not support short selling and therefore cannot have reversals.
        """
        if current_qty == 0.0:
            # No existing position - cannot reverse
            return False

        new_qty = current_qty + order_qty_delta

        # Check if signs differ between current and new position
        # (both must be non-zero for a true reversal)
        return (current_qty > 0 and new_qty < 0) or (current_qty < 0 and new_qty > 0)

    def _calculate_quantity_delta(self, side: OrderSide, quantity: float) -> float:
        """Convert order side and quantity to signed delta.

        Args:
            side: BUY or SELL
            quantity: Order quantity (always positive)

        Returns:
            Signed quantity delta (positive=buy, negative=sell)

        Examples:
            >>> gatekeeper._calculate_quantity_delta(OrderSide.BUY, 100)
            100.0
            >>> gatekeeper._calculate_quantity_delta(OrderSide.SELL, 100)
            -100.0
        """
        return quantity if side == OrderSide.BUY else -quantity

    def _is_reducing_order(self, current_qty: float, order_qty_delta: float) -> bool:
        """Check if order reduces existing position.

        A reducing order is one that moves the position closer to flat (zero).

        Args:
            current_qty: Current position quantity (positive=long, negative=short)
            order_qty_delta: Order quantity delta (positive=buy, negative=sell)

        Returns:
            True if order reduces position, False if opens/adds

        Examples:
            Reducing orders:
                >>> gatekeeper._is_reducing_order(100, -50)  # Long 100, sell 50
                True
                >>> gatekeeper._is_reducing_order(-100, 50)  # Short 100, buy 50
                True
                >>> gatekeeper._is_reducing_order(100, -100)  # Closing
                True

            Opening/Adding orders:
                >>> gatekeeper._is_reducing_order(0, 100)    # No position, buy
                False
                >>> gatekeeper._is_reducing_order(100, 50)   # Long 100, buy more
                False
                >>> gatekeeper._is_reducing_order(100, -150) # Reversal (long->short)
                False  # Not just reducing, this reverses position!

        Note:
            Position reversals (e.g., long 100 -> short 50) are NOT reducing orders
            because they require opening a new short position. These must be validated.
        """
        if current_qty == 0.0:
            # No position - this is opening, not reducing
            return False

        # Check if order and position have opposite signs
        if current_qty > 0 and order_qty_delta < 0:
            # Long position, sell order - reducing if not reversing
            new_qty = current_qty + order_qty_delta
            return new_qty >= 0  # True if still long or flat, False if reverses to short
        elif current_qty < 0 and order_qty_delta > 0:
            # Short position, buy order - reducing if not reversing
            new_qty = current_qty + order_qty_delta
            return new_qty <= 0  # True if still short or flat, False if reverses to long
        else:
            # Same sign - this is adding to position, not reducing
            return False
</file>

<file path="src/ml4t/backtest/accounting/models.py">
"""Data models for accounting system.

This module defines the core data structures used throughout the accounting system,
including the unified Position class that works for both cash and margin accounts.
"""

from dataclasses import dataclass
from datetime import datetime


@dataclass
class Position:
    """Unified position tracking for both long and short positions.

    This class replaces the simple Position class from engine.py and adds:
    - Weighted average cost basis tracking
    - Mark-to-market price tracking
    - Support for negative quantities (short positions)
    - Market value and unrealized P&L calculations

    Attributes:
        asset: Asset identifier (e.g., "AAPL", "BTC-USD")
        quantity: Position size (positive=long, negative=short)
        avg_entry_price: Weighted average entry price (cost basis)
        current_price: Latest mark-to-market price
        entry_time: Timestamp when position was first opened
        bars_held: Number of bars this position has been held

    Examples:
        Long position:
            Position("AAPL", 100, 150.0, 155.0, datetime.now(), 5)
            -> quantity=100, unrealized_pnl=+$500

        Short position:
            Position("AAPL", -100, 150.0, 145.0, datetime.now(), 3)
            -> quantity=-100, unrealized_pnl=+$500 (price dropped)
    """

    asset: str
    quantity: float  # Positive for long, negative for short
    avg_entry_price: float  # Weighted average cost basis
    current_price: float  # Last known market price for mark-to-market
    entry_time: datetime
    bars_held: int = 0

    @property
    def market_value(self) -> float:
        """Current market value of the position.

        For long positions: positive value (asset on balance sheet)
        For short positions: negative value (liability on balance sheet)

        Returns:
            Market value = quantity × current_price

        Examples:
            Long 100 @ $150: market_value = +$15,000
            Short 100 @ $150: market_value = -$15,000
        """
        return self.quantity * self.current_price

    @property
    def unrealized_pnl(self) -> float:
        """Unrealized profit/loss on the position.

        Calculated as the difference between current price and average entry
        price, multiplied by quantity. Works correctly for both long and short.

        Returns:
            Unrealized P&L = (current_price - avg_entry_price) × quantity

        Examples:
            Long 100, bought @ $150, now @ $155:
                unrealized_pnl = (155 - 150) × 100 = +$500

            Short 100, sold @ $150, now @ $145:
                unrealized_pnl = (145 - 150) × (-100) = +$500

            Short 100, sold @ $150, now @ $155:
                unrealized_pnl = (155 - 150) × (-100) = -$500
        """
        return (self.current_price - self.avg_entry_price) * self.quantity

    def __repr__(self) -> str:
        """String representation for debugging."""
        direction = "LONG" if self.quantity > 0 else "SHORT"
        return (
            f"Position({direction} {abs(self.quantity):.2f} {self.asset} "
            f"@ ${self.avg_entry_price:.2f}, "
            f"current ${self.current_price:.2f}, "
            f"PnL ${self.unrealized_pnl:+.2f})"
        )
</file>

<file path="src/ml4t/backtest/accounting/policy.py">
"""Account policy implementations for different account types.

This module defines the AccountPolicy interface and implementations for cash
and margin accounts, enabling flexible constraint enforcement based on account type.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .models import Position


class AccountPolicy(ABC):
    """Abstract base class for account-specific trading constraints.

    Different account types (cash, margin, portfolio margin) have different rules
    for what trades are allowed. This interface defines the contract that all
    account policies must implement.

    The policy pattern allows the engine to support multiple account types without
    complex conditional logic or parallel systems.
    """

    @abstractmethod
    def calculate_buying_power(self, cash: float, positions: dict[str, Position]) -> float:
        """Calculate available buying power for new long positions.

        Args:
            cash: Current cash balance (can be negative for margin accounts)
            positions: Dictionary of current positions {asset: Position}

        Returns:
            Available buying power in dollars. Must be >= 0.

        Note:
            This is used to determine if a new BUY order can be placed.
            For cash accounts: buying_power = max(0, cash)
            For margin accounts: buying_power = (NLV - MM) / initial_margin_rate
        """
        pass

    @abstractmethod
    def allows_short_selling(self) -> bool:
        """Whether this account type allows short selling.

        Returns:
            True if short selling is allowed, False otherwise.

        Note:
            Cash accounts: False (cannot short)
            Margin accounts: True (can short with margin requirements)
        """
        pass

    @abstractmethod
    def validate_new_position(
        self,
        asset: str,
        quantity: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -> tuple[bool, str]:
        """Validate whether a new position can be opened.

        This is the core validation method called by the Gatekeeper before
        executing any order.

        Args:
            asset: Asset identifier (e.g., "AAPL")
            quantity: Desired position size (positive=long, negative=short)
            price: Expected fill price
            current_positions: Current positions {asset: Position}
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple:
                - is_valid: True if order can proceed, False if rejected
                - reason: Human-readable explanation (empty if valid)

        Examples:
            Cash account rejecting short:
                (False, "Short selling not allowed in cash account")

            Cash account rejecting insufficient funds:
                (False, "Insufficient cash: need $10,000, have $5,000")

            Margin account allowing trade:
                (True, "")

        Note:
            This method must be fast (called on every order). Keep validation
            logic simple and avoid unnecessary calculations.
        """
        pass

    @abstractmethod
    def validate_position_change(
        self,
        asset: str,
        current_quantity: float,
        quantity_delta: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -> tuple[bool, str]:
        """Validate a change to an existing position.

        This handles adding to or reducing existing positions, including
        position reversals (long -> short or short -> long).

        Args:
            asset: Asset identifier
            current_quantity: Current position size (0 if no position)
            quantity_delta: Change in position (positive=buy, negative=sell)
            price: Expected fill price
            current_positions: All current positions
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple

        Examples:
            Adding to long position: current=100, delta=+50
            Closing long position: current=100, delta=-100
            Reversing position: current=100, delta=-200 (cash account rejects)

        Note:
            Position reversals (sign change) are particularly important for
            cash accounts, which must reject them.
        """
        pass


class CashAccountPolicy(AccountPolicy):
    """Account policy for cash accounts (no leverage, no shorts).

    Cash accounts are the simplest account type:
    - Cannot go negative (no borrowing)
    - Cannot short sell (no borrowing shares)
    - Buying power = available cash only
    - Position reversals not allowed (must close, then re-open)

    This is appropriate for:
    - Retail investors with no margin approval
    - Tax-advantaged accounts (IRA, 401k)
    - Conservative risk management
    """

    def calculate_buying_power(self, cash: float, positions: dict[str, Position]) -> float:
        """Cash account buying power is simply positive cash balance.

        Args:
            cash: Current cash balance
            positions: Ignored for cash accounts

        Returns:
            max(0, cash) - Cannot use margin
        """
        return max(0.0, cash)

    def allows_short_selling(self) -> bool:
        """Cash accounts cannot short sell.

        Returns:
            False - Short selling not allowed
        """
        return False

    def validate_new_position(
        self,
        asset: str,
        quantity: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -> tuple[bool, str]:
        """Validate new position for cash account.

        Checks:
        1. No short positions (quantity must be > 0)
        2. Sufficient cash to cover purchase

        Args:
            asset: Asset identifier
            quantity: Desired position size
            price: Expected fill price
            current_positions: Current positions (unused)
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple
        """
        # Check 1: No short selling
        if quantity < 0:
            return False, "Short selling not allowed in cash account"

        # Check 2: Sufficient cash
        order_cost = quantity * price
        if order_cost > cash:
            return (
                False,
                f"Insufficient cash: need ${order_cost:.2f}, have ${cash:.2f}",
            )

        return True, ""

    def validate_position_change(
        self,
        asset: str,
        current_quantity: float,
        quantity_delta: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -> tuple[bool, str]:
        """Validate position change for cash account.

        Checks:
        1. No position reversals (sign change)
        2. For increases: sufficient cash
        3. For decreases: not exceeding current position

        Args:
            asset: Asset identifier
            current_quantity: Current position size (0 if none)
            quantity_delta: Change in position
            price: Expected fill price
            current_positions: All current positions
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple
        """
        new_quantity = current_quantity + quantity_delta

        # Check 1: No position reversals (long -> short or short -> long)
        if current_quantity != 0 and (
            (current_quantity > 0 and new_quantity < 0)
            or (current_quantity < 0 and new_quantity > 0)
        ):
            return (
                False,
                f"Position reversal not allowed in cash account "
                f"(current: {current_quantity:.2f}, delta: {quantity_delta:.2f})",
            )

        # Check 2: No short positions
        if new_quantity < 0:
            return False, "Short positions not allowed in cash account"

        # Check 3: For increases (buying), check cash
        if quantity_delta > 0:
            order_cost = quantity_delta * price
            if order_cost > cash:
                return (
                    False,
                    f"Insufficient cash: need ${order_cost:.2f}, have ${cash:.2f}",
                )

        # Check 4: For decreases (selling), check position size
        if quantity_delta < 0 and abs(quantity_delta) > abs(current_quantity):
            return (
                False,
                f"Cannot sell {abs(quantity_delta):.2f}, only have {abs(current_quantity):.2f}",
            )

        return True, ""


class MarginAccountPolicy(AccountPolicy):
    """Account policy for margin accounts (leverage enabled, shorts allowed).

    Margin accounts enable more sophisticated trading strategies:
    - Can use leverage (borrow cash to increase buying power)
    - Can short sell (borrow shares to sell)
    - Buying power calculated from Net Liquidation Value and margin requirements
    - Subject to initial margin (IM) and maintenance margin (MM) requirements

    Key Formulas:
        NLV = cash + sum(position.market_value)
        MM = sum(abs(position.market_value) × maintenance_margin_rate)
        BP = (NLV - MM) / initial_margin_rate

    This is appropriate for:
    - Experienced traders with margin approval
    - Hedge funds and institutional accounts
    - Strategies requiring leverage or short selling
    - Market-neutral and pairs trading strategies

    Args:
        initial_margin: Initial margin requirement (default 0.5 = 50% = Reg T)
        maintenance_margin: Maintenance margin requirement (default 0.25 = 25%)

    Examples:
        >>> # Standard Reg T margin (50% initial, 25% maintenance)
        >>> policy = MarginAccountPolicy(initial_margin=0.5, maintenance_margin=0.25)
        >>>
        >>> # Conservative margin (100% initial = no leverage)
        >>> policy = MarginAccountPolicy(initial_margin=1.0, maintenance_margin=0.5)
        >>>
        >>> # Aggressive margin (lower requirements)
        >>> policy = MarginAccountPolicy(initial_margin=0.25, maintenance_margin=0.15)
    """

    def __init__(self, initial_margin: float = 0.5, maintenance_margin: float = 0.25) -> None:
        """Initialize margin account policy.

        Args:
            initial_margin: Initial margin requirement (0.0-1.0)
                - 0.5 = 50% = Reg T standard (2x leverage)
                - 1.0 = 100% = no leverage
                - Lower values = more leverage (higher risk)

            maintenance_margin: Maintenance margin requirement (0.0-1.0)
                - 0.25 = 25% = Reg T standard
                - Must be < initial_margin
                - Below this triggers margin call

        Raises:
            ValueError: If margin parameters are invalid
        """
        if not 0.0 < initial_margin <= 1.0:
            raise ValueError(f"Initial margin must be in (0.0, 1.0], got {initial_margin}")
        if not 0.0 < maintenance_margin <= 1.0:
            raise ValueError(f"Maintenance margin must be in (0.0, 1.0], got {maintenance_margin}")
        if maintenance_margin >= initial_margin:
            raise ValueError(
                f"Maintenance margin ({maintenance_margin}) must be < "
                f"initial margin ({initial_margin})"
            )

        self.initial_margin = initial_margin
        self.maintenance_margin = maintenance_margin

    def calculate_buying_power(self, cash: float, positions: dict[str, Position]) -> float:
        """Calculate buying power for margin account.

        Formula:
            NLV = cash + sum(position.market_value for all positions)
            MM = sum(abs(position.market_value) × maintenance_margin for all positions)
            BP = (NLV - MM) / initial_margin

        Args:
            cash: Current cash balance (can be negative)
            positions: Dictionary of current positions {asset: Position}

        Returns:
            Available buying power in dollars. Can be negative if account is
            underwater (below maintenance margin).

        Examples:
            Cash only account (no positions):
                cash=$100k, positions={}
                NLV = $100k, MM = $0
                BP = ($100k - $0) / 0.5 = $200k (2x leverage)

            Long position:
                cash=$50k, long 1000 shares @ $100 = $100k market value
                NLV = $50k + $100k = $150k
                MM = $100k × 0.25 = $25k
                BP = ($150k - $25k) / 0.5 = $250k

            Short position:
                cash=$150k, short 1000 shares @ $100 = -$100k market value
                NLV = $150k + (-$100k) = $50k
                MM = |-$100k| × 0.25 = $25k
                BP = ($50k - $25k) / 0.5 = $50k

            Underwater account (margin call):
                cash=-$10k, long 1000 shares @ $50 = $50k market value
                NLV = -$10k + $50k = $40k
                MM = $50k × 0.25 = $12.5k
                BP = ($40k - $12.5k) / 0.5 = $55k
                (Still has buying power, but NLV < initial investment)

        Note:
            Buying power can be negative if the account is severely underwater,
            indicating that positions must be liquidated to meet margin requirements.
        """
        # Calculate Net Liquidation Value (NLV)
        total_market_value = sum(pos.market_value for pos in positions.values())
        nlv = cash + total_market_value

        # Calculate Maintenance Margin requirement (MM)
        # Use absolute value because short positions have negative market value
        maintenance_margin_requirement = sum(
            abs(pos.market_value) * self.maintenance_margin for pos in positions.values()
        )

        # Calculate Buying Power (BP)
        # Available equity above maintenance margin, leveraged by initial margin
        buying_power = (nlv - maintenance_margin_requirement) / self.initial_margin

        return buying_power

    def allows_short_selling(self) -> bool:
        """Margin accounts allow short selling.

        Returns:
            True - Short selling is allowed with appropriate margin
        """
        return True

    def validate_new_position(
        self,
        asset: str,
        quantity: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -> tuple[bool, str]:
        """Validate new position for margin account.

        Checks:
        1. Sufficient buying power for the order
        2. Order doesn't create excessive leverage

        Args:
            asset: Asset identifier
            quantity: Desired position size (positive=long, negative=short)
            price: Expected fill price
            current_positions: Current positions
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple

        Note:
            Unlike cash accounts, margin accounts allow:
            - Short positions (negative quantity)
            - Negative cash (borrowing)
            - Multiple positions simultaneously
        """
        # Calculate order cost (positive for both long and short)
        order_cost = abs(quantity * price)

        # Calculate current buying power
        buying_power = self.calculate_buying_power(cash, current_positions)

        # Check: Sufficient buying power
        if order_cost > buying_power:
            return (
                False,
                f"Insufficient buying power: need ${order_cost:.2f}, "
                f"have ${buying_power:.2f} (IM={self.initial_margin:.1%})",
            )

        return True, ""

    def validate_position_change(
        self,
        asset: str,
        current_quantity: float,
        quantity_delta: float,
        price: float,
        current_positions: dict[str, Position],
        cash: float,
    ) -> tuple[bool, str]:
        """Validate position change for margin account.

        Margin accounts are more permissive than cash accounts:
        - Allow position reversals (long -> short, short -> long)
        - Allow adding to short positions
        - Only constraint is buying power

        Args:
            asset: Asset identifier
            current_quantity: Current position size (0 if none)
            quantity_delta: Change in position
            price: Expected fill price
            current_positions: All current positions
            cash: Current cash balance

        Returns:
            (is_valid, reason) tuple

        Examples:
            Adding to long: current=100, delta=+50 -> OK if BP sufficient
            Closing long: current=100, delta=-100 -> Always OK (reduces risk)
            Reversing long->short: current=100, delta=-200 -> OK if BP sufficient
            Adding to short: current=-100, delta=-50 -> OK if BP sufficient
        """
        new_quantity = current_quantity + quantity_delta

        # Determine if this is increasing or reducing risk
        is_closing = (current_quantity > 0 and quantity_delta < 0) or (
            current_quantity < 0 and quantity_delta > 0
        )

        # For closing trades, check we're not over-closing
        if is_closing and abs(new_quantity) < abs(current_quantity):
            # Partial close - always allowed (reduces risk)
            return True, ""
            # Position reversal or over-close - validate new portion

        # For opening or reversing, check buying power
        # Calculate the portion that increases risk
        if current_quantity == 0:
            # Opening new position
            risk_increase = abs(quantity_delta * price)
        elif (current_quantity > 0 and new_quantity > current_quantity) or (
            current_quantity < 0 and new_quantity < current_quantity
        ):
            # Adding to existing position
            risk_increase = abs(quantity_delta * price)
        else:
            # Reversing position - need margin for the new opposite position
            # Example: long 100 -> short 100 requires margin for short 100
            risk_increase = abs(new_quantity * price)

        # Calculate buying power
        buying_power = self.calculate_buying_power(cash, current_positions)

        # Validate sufficient buying power
        if risk_increase > buying_power:
            return (
                False,
                f"Insufficient buying power: need ${risk_increase:.2f}, "
                f"have ${buying_power:.2f} (IM={self.initial_margin:.1%})",
            )

        return True, ""
</file>

<file path="src/ml4t/backtest/broker.py">
"""Broker for order execution and position management."""

from datetime import datetime

from .models import CommissionModel, NoCommission, NoSlippage, SlippageModel
from .types import ExecutionMode, Fill, Order, OrderSide, OrderStatus, OrderType, Position, Trade


class Broker:
    """Broker interface - same for backtest and live trading."""

    def __init__(
        self,
        initial_cash: float = 100000.0,
        commission_model: CommissionModel | None = None,
        slippage_model: SlippageModel | None = None,
        execution_mode: ExecutionMode = ExecutionMode.SAME_BAR,
        account_type: str = "cash",
        initial_margin: float = 0.5,
        maintenance_margin: float = 0.25,
    ):
        # Import accounting classes here to avoid circular imports
        from .accounting import (
            AccountState,
            CashAccountPolicy,
            Gatekeeper,
            MarginAccountPolicy,
        )

        self.initial_cash = initial_cash
        self.cash = initial_cash
        self.commission_model = commission_model or NoCommission()
        self.slippage_model = slippage_model or NoSlippage()
        self.execution_mode = execution_mode

        # Create AccountState with appropriate policy
        if account_type == "cash":
            policy = CashAccountPolicy()
        elif account_type == "margin":
            policy = MarginAccountPolicy(
                initial_margin=initial_margin, maintenance_margin=maintenance_margin
            )
        else:
            raise ValueError(f"Unknown account_type: '{account_type}'. Must be 'cash' or 'margin'")

        self.account = AccountState(initial_cash=initial_cash, policy=policy)
        self.account_type = account_type
        self.initial_margin = initial_margin
        self.maintenance_margin = maintenance_margin

        # Create Gatekeeper for order validation
        self.gatekeeper = Gatekeeper(self.account, self.commission_model)

        self.positions: dict[str, Position] = {}
        self.orders: list[Order] = []
        self.pending_orders: list[Order] = []
        self.fills: list[Fill] = []
        self.trades: list[Trade] = []
        self._order_counter = 0
        self._current_time: datetime | None = None
        self._current_prices: dict[str, float] = {}  # close prices
        self._current_opens: dict[str, float] = {}  # open prices for next-bar execution
        self._current_volumes: dict[str, float] = {}
        self._current_signals: dict[str, dict[str, float]] = {}
        self._orders_this_bar: list[Order] = []  # Orders placed this bar (for next-bar mode)

    def get_position(self, asset: str) -> Position | None:
        return self.positions.get(asset)

    def get_cash(self) -> float:
        return self.cash

    def get_account_value(self) -> float:
        value = self.cash
        for asset, pos in self.positions.items():
            price = self._current_prices.get(asset, pos.entry_price)
            value += pos.quantity * price
        return value

    def submit_order(
        self,
        asset: str,
        quantity: float,
        side: OrderSide | None = None,
        order_type: OrderType = OrderType.MARKET,
        limit_price: float | None = None,
        stop_price: float | None = None,
        trail_amount: float | None = None,
    ) -> Order:
        if side is None:
            side = OrderSide.BUY if quantity > 0 else OrderSide.SELL
            quantity = abs(quantity)

        self._order_counter += 1
        order = Order(
            asset=asset,
            side=side,
            quantity=quantity,
            order_type=order_type,
            limit_price=limit_price,
            stop_price=stop_price,
            trail_amount=trail_amount,
            order_id=f"ORD-{self._order_counter}",
            created_at=self._current_time,
        )
        self.orders.append(order)
        self.pending_orders.append(order)

        # Track orders placed this bar for next-bar execution mode
        if self.execution_mode == ExecutionMode.NEXT_BAR:
            self._orders_this_bar.append(order)

        return order

    def submit_bracket(
        self,
        asset: str,
        quantity: float,
        take_profit: float,
        stop_loss: float,
        entry_type: OrderType = OrderType.MARKET,
        entry_limit: float | None = None,
    ) -> tuple[Order, Order, Order]:
        """Submit entry with take-profit and stop-loss."""
        entry = self.submit_order(asset, quantity, order_type=entry_type, limit_price=entry_limit)

        tp = self.submit_order(
            asset, quantity, OrderSide.SELL, OrderType.LIMIT, limit_price=take_profit
        )
        tp.parent_id = entry.order_id

        sl = self.submit_order(
            asset, quantity, OrderSide.SELL, OrderType.STOP, stop_price=stop_loss
        )
        sl.parent_id = entry.order_id

        return entry, tp, sl

    def update_order(self, order_id: str, **kwargs) -> bool:
        """Update pending order parameters (stop_price, limit_price, quantity, trail_amount)."""
        for order in self.pending_orders:
            if order.order_id == order_id:
                for key, value in kwargs.items():
                    if hasattr(order, key):
                        setattr(order, key, value)
                return True
        return False

    def cancel_order(self, order_id: str) -> bool:
        for order in self.pending_orders:
            if order.order_id == order_id:
                order.status = OrderStatus.CANCELLED
                self.pending_orders.remove(order)
                return True
        return False

    def close_position(self, asset: str) -> Order | None:
        pos = self.positions.get(asset)
        if pos and pos.quantity != 0:
            side = OrderSide.SELL if pos.quantity > 0 else OrderSide.BUY
            return self.submit_order(asset, abs(pos.quantity), side)
        return None

    def get_order(self, order_id: str) -> Order | None:
        """Get order by ID."""
        for order in self.orders:
            if order.order_id == order_id:
                return order
        return None

    def get_pending_orders(self, asset: str | None = None) -> list[Order]:
        """Get pending orders, optionally filtered by asset."""
        if asset is None:
            return list(self.pending_orders)
        return [o for o in self.pending_orders if o.asset == asset]

    def _is_exit_order(self, order: Order) -> bool:
        """Check if order is an exit (reducing existing position).

        Exit orders are:
        - SELL when we have a long position (reducing long)
        - BUY when we have a short position (covering short)
        - Does NOT reverse the position

        Args:
            order: Order to check

        Returns:
            True if order is reducing an existing position, False otherwise
        """
        pos = self.positions.get(order.asset)
        if pos is None or pos.quantity == 0:
            return False  # No position, so this is entry, not exit

        # Calculate signed quantity delta
        signed_qty = order.quantity if order.side == OrderSide.BUY else -order.quantity

        # Check if opposite sign (reducing) and doesn't reverse
        if pos.quantity > 0 and signed_qty < 0:
            # Long position, sell order
            new_qty = pos.quantity + signed_qty
            return new_qty >= 0  # Exit if still long or flat, not reversal
        elif pos.quantity < 0 and signed_qty > 0:
            # Short position, buy order
            new_qty = pos.quantity + signed_qty
            return new_qty <= 0  # Exit if still short or flat, not reversal
        else:
            # Same sign - adding to position, not exiting
            return False

    def _update_time(
        self,
        timestamp: datetime,
        prices: dict[str, float],
        opens: dict[str, float],
        volumes: dict[str, float],
        signals: dict[str, dict],
    ):
        self._current_time = timestamp
        self._current_prices = prices
        self._current_opens = opens
        self._current_volumes = volumes
        self._current_signals = signals

        # In next-bar mode, move orders from this bar to pending for next bar
        if self.execution_mode == ExecutionMode.NEXT_BAR:
            # Orders placed last bar are now eligible for execution
            pass  # They're already in pending_orders
            # Clear orders placed this bar (will be processed next bar)
            self._orders_this_bar = []

        for pos in self.positions.values():
            pos.bars_held += 1

    def _process_orders(self, use_open: bool = False):
        """Process pending orders against current prices with exit-first sequencing.

        Exit-first sequencing ensures capital efficiency:
        1. Process all exit orders first (closing positions frees capital)
        2. Update account equity after exits
        3. Process all entry orders with updated buying power

        This prevents rejecting entry orders when we have pending exits that
        would free up capital.

        Args:
            use_open: If True, use open prices (for next-bar mode at bar start)
        """
        # Split orders into exits and entries
        exit_orders = []
        entry_orders = []

        for order in self.pending_orders[:]:
            # In next-bar mode, skip orders placed this bar
            if self.execution_mode == ExecutionMode.NEXT_BAR and order in self._orders_this_bar:
                continue

            if self._is_exit_order(order):
                exit_orders.append(order)
            else:
                entry_orders.append(order)

        filled_orders = []

        # Phase 1: Process exit orders (always allowed - frees capital)
        for order in exit_orders:
            # Get execution price based on mode
            if use_open and self.execution_mode == ExecutionMode.NEXT_BAR:
                price = self._current_opens.get(order.asset)
            else:
                price = self._current_prices.get(order.asset)

            if price is None:
                continue

            fill_price = self._check_fill(order, price)
            if fill_price is not None:
                self._execute_fill(order, fill_price)
                filled_orders.append(order)

        # Phase 2: Update account equity after exits
        self.account.mark_to_market(self._current_prices)

        # Phase 3: Process entry orders (validated via Gatekeeper)
        for order in entry_orders:
            # Get execution price based on mode
            if use_open and self.execution_mode == ExecutionMode.NEXT_BAR:
                price = self._current_opens.get(order.asset)
            else:
                price = self._current_prices.get(order.asset)

            if price is None:
                continue

            fill_price = self._check_fill(order, price)
            if fill_price is not None:
                # CRITICAL: Validate order before executing
                valid, rejection_reason = self.gatekeeper.validate_order(order, fill_price)

                if valid:
                    self._execute_fill(order, fill_price)
                    filled_orders.append(order)
                else:
                    # Reject order
                    order.status = OrderStatus.REJECTED
                    # Note: rejection_reason could be logged here if needed

        # Remove filled/rejected orders from pending
        for order in filled_orders:
            if order in self.pending_orders:
                self.pending_orders.remove(order)
            if order in self._orders_this_bar:
                self._orders_this_bar.remove(order)

        # Also remove rejected orders
        for order in self.pending_orders[:]:
            if order.status == OrderStatus.REJECTED:
                self.pending_orders.remove(order)

    def _check_fill(self, order: Order, price: float) -> float | None:
        """Check if order should fill, return fill price or None."""
        if order.order_type == OrderType.MARKET:
            return price
        elif order.order_type == OrderType.LIMIT:
            if (
                order.side == OrderSide.BUY
                and price <= order.limit_price
                or order.side == OrderSide.SELL
                and price >= order.limit_price
            ):
                return order.limit_price
        elif order.order_type == OrderType.STOP:
            if (
                order.side == OrderSide.BUY
                and price >= order.stop_price
                or order.side == OrderSide.SELL
                and price <= order.stop_price
            ):
                return price
        elif order.order_type == OrderType.TRAILING_STOP and order.side == OrderSide.SELL:
            new_stop = price - order.trail_amount
            if order.stop_price is None or new_stop > order.stop_price:
                order.stop_price = new_stop
            if price <= order.stop_price:
                return price
        return None

    def _execute_fill(self, order: Order, base_price: float):
        """Execute a fill and update positions."""
        volume = self._current_volumes.get(order.asset)

        # Calculate slippage
        slippage = self.slippage_model.calculate(order.asset, order.quantity, base_price, volume)
        fill_price = base_price + slippage if order.side == OrderSide.BUY else base_price - slippage

        # Calculate commission
        commission = self.commission_model.calculate(order.asset, order.quantity, fill_price)

        fill = Fill(
            order_id=order.order_id,
            asset=order.asset,
            side=order.side,
            quantity=order.quantity,
            price=fill_price,
            timestamp=self._current_time,
            commission=commission,
            slippage=slippage,
        )
        self.fills.append(fill)

        order.status = OrderStatus.FILLED
        order.filled_at = self._current_time
        order.filled_price = fill_price
        order.filled_quantity = order.quantity

        # Update position
        pos = self.positions.get(order.asset)
        signed_qty = order.quantity if order.side == OrderSide.BUY else -order.quantity

        if pos is None:
            if signed_qty != 0:
                self.positions[order.asset] = Position(
                    asset=order.asset,
                    quantity=signed_qty,
                    entry_price=fill_price,
                    entry_time=self._current_time,
                )
        else:
            old_qty = pos.quantity
            new_qty = old_qty + signed_qty

            if new_qty == 0:
                # Position closed
                pnl = (fill_price - pos.entry_price) * old_qty - commission
                trade = Trade(
                    asset=order.asset,
                    entry_time=pos.entry_time,
                    exit_time=self._current_time,
                    entry_price=pos.entry_price,
                    exit_price=fill_price,
                    quantity=abs(old_qty),
                    pnl=pnl,
                    pnl_percent=(fill_price - pos.entry_price) / pos.entry_price
                    if pos.entry_price
                    else 0,
                    bars_held=pos.bars_held,
                    commission=commission,
                    slippage=slippage,
                    entry_signals=self._current_signals.get(order.asset, {}),
                    exit_signals=self._current_signals.get(order.asset, {}),
                )
                self.trades.append(trade)
                del self.positions[order.asset]
            elif (old_qty > 0) != (new_qty > 0):
                # Position flipped
                pnl = (fill_price - pos.entry_price) * old_qty - commission
                self.trades.append(
                    Trade(
                        asset=order.asset,
                        entry_time=pos.entry_time,
                        exit_time=self._current_time,
                        entry_price=pos.entry_price,
                        exit_price=fill_price,
                        quantity=abs(old_qty),
                        pnl=pnl,
                        pnl_percent=(fill_price - pos.entry_price) / pos.entry_price
                        if pos.entry_price
                        else 0,
                        bars_held=pos.bars_held,
                        commission=commission,
                        slippage=slippage,
                    )
                )
                self.positions[order.asset] = Position(
                    asset=order.asset,
                    quantity=new_qty,
                    entry_price=fill_price,
                    entry_time=self._current_time,
                )
            else:
                # Position scaled
                if abs(new_qty) > abs(old_qty):
                    total_cost = pos.entry_price * abs(old_qty) + fill_price * abs(signed_qty)
                    pos.entry_price = total_cost / abs(new_qty)
                pos.quantity = new_qty

        # Update cash
        cash_change = -signed_qty * fill_price - commission
        self.cash += cash_change

        # Update AccountState (import Position from accounting)
        from .accounting import Position as AcctPosition

        # Sync position to AccountState
        broker_pos = self.positions.get(order.asset)
        if broker_pos is None:
            # Position was closed, remove from account
            if order.asset in self.account.positions:
                del self.account.positions[order.asset]
        else:
            # Update or create position in account
            self.account.positions[order.asset] = AcctPosition(
                asset=broker_pos.asset,
                quantity=broker_pos.quantity,
                avg_entry_price=broker_pos.entry_price,
                current_price=self._current_prices.get(order.asset, broker_pos.entry_price),
                entry_time=broker_pos.entry_time,
                bars_held=broker_pos.bars_held,
            )

        # Update account cash
        self.account.cash = self.cash

        # Cancel sibling bracket orders on fill
        if order.parent_id:
            for o in self.pending_orders[:]:
                if o.parent_id == order.parent_id and o.order_id != order.order_id:
                    o.status = OrderStatus.CANCELLED
                    self.pending_orders.remove(o)
</file>

<file path="src/ml4t/backtest/config.py">
"""
Backtest Configuration

Centralized configuration for all backtesting behavior. This allows:
1. Consistent behavior across all backtests
2. Easy replication of other frameworks (Backtrader, VectorBT, Zipline)
3. Clear documentation of all configurable behaviors
4. No code changes needed - just swap configuration files

Usage:
    from ml4t.backtest import BacktestConfig

    # Load default config
    config = BacktestConfig()

    # Load preset (e.g., backtrader-compatible)
    config = BacktestConfig.from_preset("backtrader")

    # Load from file
    config = BacktestConfig.from_yaml("my_config.yaml")
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from pathlib import Path

import yaml


class FillTiming(str, Enum):
    """When orders are filled relative to signal generation."""

    SAME_BAR = "same_bar"  # Fill on same bar as signal (look-ahead bias risk)
    NEXT_BAR_OPEN = "next_bar_open"  # Fill at next bar's open (most realistic)
    NEXT_BAR_CLOSE = "next_bar_close"  # Fill at next bar's close


class ExecutionPrice(str, Enum):
    """Price used for order execution."""

    CLOSE = "close"  # Use bar's close price
    OPEN = "open"  # Use bar's open price
    VWAP = "vwap"  # Volume-weighted average price (requires volume data)
    MID = "mid"  # (high + low) / 2


class ShareType(str, Enum):
    """Type of share quantities allowed."""

    FRACTIONAL = "fractional"  # Allow fractional shares (0.5, 1.234, etc.)
    INTEGER = "integer"  # Round down to whole shares (like most real brokers)


class SizingMethod(str, Enum):
    """How position size is calculated."""

    PERCENT_OF_PORTFOLIO = "percent_of_portfolio"  # % of total portfolio value
    PERCENT_OF_CASH = "percent_of_cash"  # % of available cash only
    FIXED_VALUE = "fixed_value"  # Fixed dollar amount per position
    FIXED_SHARES = "fixed_shares"  # Fixed number of shares


class SignalProcessing(str, Enum):
    """How signals are processed relative to existing positions."""

    CHECK_POSITION = "check_position"  # Only act if no existing position (event-driven)
    PROCESS_ALL = "process_all"  # Process all signals regardless (vectorized)


class CommissionModel(str, Enum):
    """Commission calculation method."""

    NONE = "none"  # No commission
    PERCENTAGE = "percentage"  # % of trade value
    PER_SHARE = "per_share"  # Fixed amount per share
    PER_TRADE = "per_trade"  # Fixed amount per trade
    TIERED = "tiered"  # Volume-based tiers


class SlippageModel(str, Enum):
    """Slippage calculation method."""

    NONE = "none"  # No slippage
    PERCENTAGE = "percentage"  # % of price
    FIXED = "fixed"  # Fixed dollar amount
    VOLUME_BASED = "volume_based"  # Based on trade size vs volume


@dataclass
class BacktestConfig:
    """
    Complete configuration for backtesting behavior.

    All behavioral differences between frameworks are captured here.
    Load presets to match specific frameworks exactly.
    """

    # === Execution Timing ===
    fill_timing: FillTiming = FillTiming.NEXT_BAR_OPEN
    execution_price: ExecutionPrice = ExecutionPrice.CLOSE

    # === Position Sizing ===
    share_type: ShareType = ShareType.FRACTIONAL
    sizing_method: SizingMethod = SizingMethod.PERCENT_OF_PORTFOLIO
    default_position_pct: float = 0.10  # 10% of portfolio per position

    # === Signal Processing ===
    signal_processing: SignalProcessing = SignalProcessing.CHECK_POSITION
    accumulate_positions: bool = False  # Allow adding to existing positions

    # === Commission ===
    commission_model: CommissionModel = CommissionModel.PERCENTAGE
    commission_rate: float = 0.001  # 0.1% per trade
    commission_per_share: float = 0.0  # $ per share (if per_share model)
    commission_per_trade: float = 0.0  # $ per trade (if per_trade model)
    commission_minimum: float = 0.0  # Minimum commission per trade

    # === Slippage ===
    slippage_model: SlippageModel = SlippageModel.PERCENTAGE
    slippage_rate: float = 0.001  # 0.1%
    slippage_fixed: float = 0.0  # $ per share (if fixed model)

    # === Cash Management ===
    initial_cash: float = 100000.0
    allow_negative_cash: bool = False
    cash_buffer_pct: float = 0.0  # Reserve this % of cash (0 = use all)

    # === Order Handling ===
    reject_on_insufficient_cash: bool = True
    partial_fills_allowed: bool = False

    # === Account Type ===
    account_type: str = "cash"  # "cash" or "margin"
    margin_requirement: float = 0.5  # 50% margin requirement

    # === Metadata ===
    preset_name: str | None = None  # Name of preset this was loaded from

    def to_dict(self) -> dict:
        """Convert config to dictionary for serialization."""
        return {
            "execution": {
                "fill_timing": self.fill_timing.value,
                "execution_price": self.execution_price.value,
            },
            "position_sizing": {
                "share_type": self.share_type.value,
                "sizing_method": self.sizing_method.value,
                "default_position_pct": self.default_position_pct,
            },
            "signals": {
                "signal_processing": self.signal_processing.value,
                "accumulate_positions": self.accumulate_positions,
            },
            "commission": {
                "model": self.commission_model.value,
                "rate": self.commission_rate,
                "per_share": self.commission_per_share,
                "per_trade": self.commission_per_trade,
                "minimum": self.commission_minimum,
            },
            "slippage": {
                "model": self.slippage_model.value,
                "rate": self.slippage_rate,
                "fixed": self.slippage_fixed,
            },
            "cash": {
                "initial": self.initial_cash,
                "allow_negative": self.allow_negative_cash,
                "buffer_pct": self.cash_buffer_pct,
            },
            "orders": {
                "reject_on_insufficient_cash": self.reject_on_insufficient_cash,
                "partial_fills_allowed": self.partial_fills_allowed,
            },
            "account": {
                "type": self.account_type,
                "margin_requirement": self.margin_requirement,
            },
        }

    @classmethod
    def from_dict(cls, data: dict, preset_name: str | None = None) -> BacktestConfig:
        """Create config from dictionary."""
        exec_cfg = data.get("execution", {})
        sizing_cfg = data.get("position_sizing", {})
        signal_cfg = data.get("signals", {})
        comm_cfg = data.get("commission", {})
        slip_cfg = data.get("slippage", {})
        cash_cfg = data.get("cash", {})
        order_cfg = data.get("orders", {})
        acct_cfg = data.get("account", {})

        return cls(
            # Execution
            fill_timing=FillTiming(exec_cfg.get("fill_timing", "next_bar_open")),
            execution_price=ExecutionPrice(exec_cfg.get("execution_price", "close")),
            # Sizing
            share_type=ShareType(sizing_cfg.get("share_type", "fractional")),
            sizing_method=SizingMethod(sizing_cfg.get("sizing_method", "percent_of_portfolio")),
            default_position_pct=sizing_cfg.get("default_position_pct", 0.10),
            # Signals
            signal_processing=SignalProcessing(
                signal_cfg.get("signal_processing", "check_position")
            ),
            accumulate_positions=signal_cfg.get("accumulate_positions", False),
            # Commission
            commission_model=CommissionModel(comm_cfg.get("model", "percentage")),
            commission_rate=comm_cfg.get("rate", 0.001),
            commission_per_share=comm_cfg.get("per_share", 0.0),
            commission_per_trade=comm_cfg.get("per_trade", 0.0),
            commission_minimum=comm_cfg.get("minimum", 0.0),
            # Slippage
            slippage_model=SlippageModel(slip_cfg.get("model", "percentage")),
            slippage_rate=slip_cfg.get("rate", 0.001),
            slippage_fixed=slip_cfg.get("fixed", 0.0),
            # Cash
            initial_cash=cash_cfg.get("initial", 100000.0),
            allow_negative_cash=cash_cfg.get("allow_negative", False),
            cash_buffer_pct=cash_cfg.get("buffer_pct", 0.0),
            # Orders
            reject_on_insufficient_cash=order_cfg.get("reject_on_insufficient_cash", True),
            partial_fills_allowed=order_cfg.get("partial_fills_allowed", False),
            # Account
            account_type=acct_cfg.get("type", "cash"),
            margin_requirement=acct_cfg.get("margin_requirement", 0.5),
            # Metadata
            preset_name=preset_name,
        )

    def to_yaml(self, path: str | Path) -> None:
        """Save config to YAML file."""
        path = Path(path)
        with open(path, "w") as f:
            yaml.dump(self.to_dict(), f, default_flow_style=False, sort_keys=False)

    @classmethod
    def from_yaml(cls, path: str | Path) -> BacktestConfig:
        """Load config from YAML file."""
        path = Path(path)
        with open(path) as f:
            data = yaml.safe_load(f)
        return cls.from_dict(data, preset_name=path.stem)

    @classmethod
    def from_preset(cls, preset: str) -> BacktestConfig:
        """
        Load a predefined configuration preset.

        Available presets:
        - "default": Sensible defaults for general use
        - "backtrader": Match Backtrader's default behavior
        - "vectorbt": Match VectorBT's default behavior
        - "zipline": Match Zipline's default behavior
        - "realistic": Conservative settings for realistic simulation
        """
        presets = {
            "default": cls._default_preset(),
            "backtrader": cls._backtrader_preset(),
            "vectorbt": cls._vectorbt_preset(),
            "zipline": cls._zipline_preset(),
            "realistic": cls._realistic_preset(),
        }

        if preset not in presets:
            available = ", ".join(presets.keys())
            raise ValueError(f"Unknown preset '{preset}'. Available: {available}")

        config = presets[preset]
        config.preset_name = preset
        return config

    @classmethod
    def _default_preset(cls) -> BacktestConfig:
        """Default configuration - balanced between realism and ease of use."""
        return cls(
            fill_timing=FillTiming.NEXT_BAR_OPEN,
            execution_price=ExecutionPrice.OPEN,
            share_type=ShareType.FRACTIONAL,
            sizing_method=SizingMethod.PERCENT_OF_PORTFOLIO,
            default_position_pct=0.10,
            signal_processing=SignalProcessing.CHECK_POSITION,
            accumulate_positions=False,
            commission_model=CommissionModel.PERCENTAGE,
            commission_rate=0.001,
            slippage_model=SlippageModel.PERCENTAGE,
            slippage_rate=0.001,
            initial_cash=100000.0,
            allow_negative_cash=False,
            cash_buffer_pct=0.0,
            reject_on_insufficient_cash=True,
            partial_fills_allowed=False,
        )

    @classmethod
    def _backtrader_preset(cls) -> BacktestConfig:
        """
        Match Backtrader's default behavior.

        Key characteristics:
        - INTEGER shares (rounds down to whole shares)
        - Next-bar execution (COO disabled by default)
        - Check position state before acting
        - Percentage commission
        """
        return cls(
            fill_timing=FillTiming.NEXT_BAR_OPEN,
            execution_price=ExecutionPrice.OPEN,
            share_type=ShareType.INTEGER,  # Key difference!
            sizing_method=SizingMethod.PERCENT_OF_PORTFOLIO,
            default_position_pct=0.10,
            signal_processing=SignalProcessing.CHECK_POSITION,
            accumulate_positions=False,
            commission_model=CommissionModel.PERCENTAGE,
            commission_rate=0.001,
            slippage_model=SlippageModel.PERCENTAGE,
            slippage_rate=0.001,
            initial_cash=100000.0,
            allow_negative_cash=False,
            cash_buffer_pct=0.0,
            reject_on_insufficient_cash=True,
            partial_fills_allowed=False,
        )

    @classmethod
    def _vectorbt_preset(cls) -> BacktestConfig:
        """
        Match VectorBT's default behavior.

        Key characteristics:
        - FRACTIONAL shares
        - Same-bar execution (vectorized)
        - Process ALL signals (no position state check)
        - Percentage fees
        """
        return cls(
            fill_timing=FillTiming.SAME_BAR,  # Vectorized = same bar
            execution_price=ExecutionPrice.CLOSE,
            share_type=ShareType.FRACTIONAL,
            sizing_method=SizingMethod.PERCENT_OF_PORTFOLIO,
            default_position_pct=0.10,
            signal_processing=SignalProcessing.PROCESS_ALL,  # Key difference!
            accumulate_positions=False,  # Use accumulate=False
            commission_model=CommissionModel.PERCENTAGE,
            commission_rate=0.001,
            slippage_model=SlippageModel.PERCENTAGE,
            slippage_rate=0.001,
            initial_cash=100000.0,
            allow_negative_cash=False,
            cash_buffer_pct=0.0,
            reject_on_insufficient_cash=False,  # VectorBT is more permissive
            partial_fills_allowed=True,
        )

    @classmethod
    def _zipline_preset(cls) -> BacktestConfig:
        """
        Match Zipline's default behavior.

        Key characteristics:
        - Next-bar execution (order on bar N, fill on bar N+1)
        - Integer shares
        - Per-share commission (IB-style)
        - Volume-based slippage
        """
        return cls(
            fill_timing=FillTiming.NEXT_BAR_OPEN,
            execution_price=ExecutionPrice.OPEN,
            share_type=ShareType.INTEGER,
            sizing_method=SizingMethod.PERCENT_OF_PORTFOLIO,
            default_position_pct=0.10,
            signal_processing=SignalProcessing.CHECK_POSITION,
            accumulate_positions=False,
            commission_model=CommissionModel.PER_SHARE,  # Zipline uses per-share
            commission_rate=0.0,
            commission_per_share=0.005,  # $0.005 per share (IB-style)
            commission_minimum=1.0,  # $1 minimum
            slippage_model=SlippageModel.VOLUME_BASED,  # Key difference!
            slippage_rate=0.1,  # 10% of bar volume
            initial_cash=100000.0,
            allow_negative_cash=False,
            cash_buffer_pct=0.0,
            reject_on_insufficient_cash=True,
            partial_fills_allowed=True,  # Volume-based = partial fills
        )

    @classmethod
    def _realistic_preset(cls) -> BacktestConfig:
        """
        Conservative settings for realistic simulation.

        Key characteristics:
        - Integer shares (like real brokers)
        - Next-bar execution (no look-ahead)
        - Higher costs (more conservative)
        - Cash buffer (margin of safety)
        """
        return cls(
            fill_timing=FillTiming.NEXT_BAR_OPEN,
            execution_price=ExecutionPrice.OPEN,
            share_type=ShareType.INTEGER,
            sizing_method=SizingMethod.PERCENT_OF_PORTFOLIO,
            default_position_pct=0.05,  # Smaller positions
            signal_processing=SignalProcessing.CHECK_POSITION,
            accumulate_positions=False,
            commission_model=CommissionModel.PERCENTAGE,
            commission_rate=0.002,  # Higher commission
            slippage_model=SlippageModel.PERCENTAGE,
            slippage_rate=0.002,  # Higher slippage
            initial_cash=100000.0,
            allow_negative_cash=False,
            cash_buffer_pct=0.02,  # 2% cash buffer
            reject_on_insufficient_cash=True,
            partial_fills_allowed=False,
        )

    def describe(self) -> str:
        """Return human-readable description of configuration."""
        lines = [
            f"BacktestConfig (preset: {self.preset_name or 'custom'})",
            "=" * 50,
            "",
            "Execution:",
            f"  Fill timing: {self.fill_timing.value}",
            f"  Execution price: {self.execution_price.value}",
            "",
            "Position Sizing:",
            f"  Share type: {self.share_type.value}",
            f"  Sizing method: {self.sizing_method.value}",
            f"  Default position: {self.default_position_pct:.1%}",
            "",
            "Signal Processing:",
            f"  Processing: {self.signal_processing.value}",
            f"  Accumulate: {self.accumulate_positions}",
            "",
            "Costs:",
            f"  Commission: {self.commission_model.value} @ {self.commission_rate:.2%}",
            f"  Slippage: {self.slippage_model.value} @ {self.slippage_rate:.2%}",
            "",
            "Cash:",
            f"  Initial: ${self.initial_cash:,.0f}",
            f"  Buffer: {self.cash_buffer_pct:.1%}",
            f"  Reject insufficient: {self.reject_on_insufficient_cash}",
        ]
        return "\n".join(lines)


# Export presets directory path for users who want to load custom YAML files
PRESETS_DIR = Path(__file__).parent / "presets"
</file>

<file path="src/ml4t/backtest/datafeed.py">
"""Polars-based multi-asset data feed."""

from datetime import datetime
from typing import Any

import polars as pl


class DataFeed:
    """Polars-based multi-asset data feed with signals and context."""

    def __init__(
        self,
        prices_path: str | None = None,
        signals_path: str | None = None,
        context_path: str | None = None,
        prices_df: pl.DataFrame | None = None,
        signals_df: pl.DataFrame | None = None,
        context_df: pl.DataFrame | None = None,
    ):
        self.prices = (
            prices_df
            if prices_df is not None
            else (pl.scan_parquet(prices_path).collect() if prices_path else None)
        )
        self.signals = (
            signals_df
            if signals_df is not None
            else (pl.scan_parquet(signals_path).collect() if signals_path else None)
        )
        self.context = (
            context_df
            if context_df is not None
            else (pl.scan_parquet(context_path).collect() if context_path else None)
        )

        if self.prices is None:
            raise ValueError("prices_path or prices_df required")

        self._timestamps = self._get_timestamps()
        self._idx = 0

    def _get_timestamps(self) -> list[datetime]:
        ts = self.prices.select("timestamp").unique()
        if self.signals is not None:
            ts = ts.vstack(self.signals.select("timestamp").unique())
        if self.context is not None:
            ts = ts.vstack(self.context.select("timestamp").unique())
        return sorted(ts.unique().to_series().to_list())

    def __iter__(self):
        self._idx = 0
        return self

    def __next__(self) -> tuple[datetime, dict[str, dict], dict[str, Any]]:
        if self._idx >= len(self._timestamps):
            raise StopIteration

        ts = self._timestamps[self._idx]
        self._idx += 1

        # Get prices for all assets at this timestamp
        assets_data = {}
        prices_at_ts = self.prices.filter(pl.col("timestamp") == ts)
        for row in prices_at_ts.iter_rows(named=True):
            asset = row["asset"]
            assets_data[asset] = {
                "open": row.get("open"),
                "high": row.get("high"),
                "low": row.get("low"),
                "close": row.get("close"),
                "volume": row.get("volume"),
                "signals": {},
            }

        # Add signals for each asset
        if self.signals is not None:
            signals_at_ts = self.signals.filter(pl.col("timestamp") == ts)
            for row in signals_at_ts.iter_rows(named=True):
                asset = row["asset"]
                if asset in assets_data:
                    for k, v in row.items():
                        if k not in ("timestamp", "asset"):
                            assets_data[asset]["signals"][k] = v

        # Get context at this timestamp
        context_data = {}
        if self.context is not None:
            ctx_at_ts = self.context.filter(pl.col("timestamp") == ts)
            if len(ctx_at_ts) > 0:
                row = ctx_at_ts.row(0, named=True)
                for k, v in row.items():
                    if k != "timestamp":
                        context_data[k] = v

        return ts, assets_data, context_data
</file>

<file path="src/ml4t/backtest/strategy.py">
"""Base strategy class for backtesting."""

from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any


class Strategy(ABC):
    """Base strategy class."""

    @abstractmethod
    def on_data(
        self,
        timestamp: datetime,
        data: dict[str, dict],
        context: dict[str, Any],
        broker: Any,  # Avoid circular import, use Any for broker type
    ) -> None:
        """Called for each timestamp with all available data."""
        pass

    def on_start(self, broker: Any) -> None:  # noqa: B027
        """Called before backtest starts."""
        pass

    def on_end(self, broker: Any) -> None:  # noqa: B027
        """Called after backtest ends."""
        pass
</file>

<file path="src/ml4t/backtest/types.py">
"""Core types for backtesting engine."""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

# === Enums ===


class OrderType(Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"
    TRAILING_STOP = "trailing_stop"


class OrderSide(Enum):
    BUY = "buy"
    SELL = "sell"


class OrderStatus(Enum):
    PENDING = "pending"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class ExecutionMode(Enum):
    """Order execution timing mode."""

    SAME_BAR = "same_bar"  # Orders fill at current bar's close (default)
    NEXT_BAR = "next_bar"  # Orders fill at next bar's open (like Backtrader)


# === Dataclasses ===


@dataclass
class Order:
    asset: str
    side: OrderSide
    quantity: float
    order_type: OrderType = OrderType.MARKET
    limit_price: float | None = None
    stop_price: float | None = None
    trail_amount: float | None = None
    parent_id: str | None = None
    order_id: str = ""
    status: OrderStatus = OrderStatus.PENDING
    created_at: datetime | None = None
    filled_at: datetime | None = None
    filled_price: float | None = None
    filled_quantity: float = 0.0


@dataclass
class Position:
    asset: str
    quantity: float
    entry_price: float
    entry_time: datetime
    bars_held: int = 0

    def unrealized_pnl(self, current_price: float) -> float:
        return (current_price - self.entry_price) * self.quantity

    def pnl_percent(self, current_price: float) -> float:
        if self.entry_price == 0:
            return 0.0
        return (current_price - self.entry_price) / self.entry_price


@dataclass
class Fill:
    order_id: str
    asset: str
    side: OrderSide
    quantity: float
    price: float
    timestamp: datetime
    commission: float = 0.0
    slippage: float = 0.0


@dataclass
class Trade:
    """Completed round-trip trade."""

    asset: str
    entry_time: datetime
    exit_time: datetime
    entry_price: float
    exit_price: float
    quantity: float
    pnl: float
    pnl_percent: float
    bars_held: int
    commission: float = 0.0
    slippage: float = 0.0
    entry_signals: dict[str, float] = field(default_factory=dict)
    exit_signals: dict[str, float] = field(default_factory=dict)
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to ml4t.backtest will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added - Phase 1b: ML Signal Integration Examples & Testing (2025-11-15)

#### New Examples
- **ML Strategy Example** (`examples/ml_strategy_example.py`)
  - Complete working demonstration of ML signal integration
  - Realistic ML predictions with confidence scores (80% bull, 65% bear accuracy)
  - Market-wide context integration (VIX, regime indicators)
  - All 9 helper methods in action (size_by_confidence, buy_percent, close_position, etc.)
  - 2-year backtest with regime changes (bull → bear transitions)
  - Sample data generation with 252 trading days

#### New Test Fixtures
- **ML Signal Test Fixtures** (`tests/fixtures/ml_signal_data.py`)
  - 9 pytest fixtures for rapid ML strategy testing
  - 6 market scenarios: bull, bear, high-vol, low-vol, trending, mean-reverting
  - Realistic ML predictions with scenario-specific accuracy (60-85%)
  - VIX and regime indicators time-aligned with prices
  - Valid OHLC bars (high ≥ open/close ≥ low)
  - Reproducible (seed=42 default)
  - Global fixtures available in all tests
  - Comprehensive documentation (503 lines) and usage examples (163 lines)

#### New Tests
- **Helper Method Tests** (`tests/unit/test_strategy_helpers.py`)
  - 13 comprehensive tests for all 9 helper methods
  - Standard helpers: `get_position`, `get_cash`, `get_portfolio_value`, `buy_percent`, `sell_percent`, `close_position`
  - ML helpers: `size_by_confidence`, `rebalance_to_weights`, `get_unrealized_pnl_pct`
  - Error handling validation (broker not initialized)
  - Increased `strategy/base.py` coverage: 35% → 74%

- **ML Fixture Validation** (`tests/unit/test_ml_fixtures.py`)
  - 24 tests validating fixture data quality
  - OHLC validity checks
  - Signal range validation
  - Context data verification
  - Scenario-specific characteristic validation

- **ContextCache Performance Benchmarks** (`tests/benchmarks/test_context_memory.py`)
  - 7 benchmark scenarios measuring memory efficiency
  - Minimal context (8 indicators): 1.9-2.0x memory savings
  - Large context (50+ indicators): 5.0-5.2x memory savings
  - Scales tested: 10, 100, 500 assets
  - Event counts: 2.5K, 25K, 126K events
  - Comprehensive results analysis (208 lines)

#### Test Results
- **535 total tests** (up from 498)
- **81% coverage** (up from 77%)
- **Zero regressions**
- Strategy base class coverage: 35% → 74%

### Fixed

#### Critical Bug Fix (2025-11-15)
- **Broker Injection** (`src/ml4t/backtest/engine.py:120`)
  - Fixed `ValueError: "Broker not initialized"` when using helper methods
  - Engine now sets `strategy.broker = self.broker` after strategy initialization
  - Helper methods require broker reference to query positions, cash, portfolio value
  - Affected methods: all 9 helper methods (get_position, buy_percent, etc.)
  - **Impact:** Critical - helper methods were unusable without this fix

---

### Added - Phase 1: ML Signal Integration Core (2025-11-15)

#### Signal Support in Events
- **MarketEvent.signals** (`src/ml4t/backtest/core/event.py`)
  - New `signals: dict[str, float]` field for ML predictions
  - Supports unlimited signals (entry/exit probabilities, confidence, volatility forecasts)
  - Clean separation of price data (OHLCV) vs signal data (ML predictions)
  - Point-in-time safe: signals computed externally with proper temporal alignment

#### DataFeed Signal Extraction
- **signal_columns parameter** (`src/ml4t/backtest/data/feed.py`)
  - `ParquetDataFeed` and `CSVDataFeed` now accept `signal_columns: list[str]`
  - Automatically extracts specified columns into `event.signals` dict
  - Remaining columns treated as OHLCV price data
  - Example: `signal_columns=["prediction", "confidence"]` → `event.signals = {"prediction": 0.72, "confidence": 0.85}`

#### Strategy Helper Methods (9 new methods)
- **Standard Trading Helpers** (`src/ml4t/backtest/strategy/base.py`)
  - `get_position(asset_id: str) -> int` - Get current position (shares held)
  - `get_cash() -> float` - Get available cash
  - `get_portfolio_value() -> float` - Get total portfolio value (cash + positions)
  - `buy_percent(asset_id, percent, price)` - Buy as percentage of portfolio
  - `sell_percent(asset_id, percent, price)` - Sell as percentage of portfolio
  - `close_position(asset_id: str)` - Close entire position (liquidate)

- **ML-Specific Helpers** (`src/ml4t/backtest/strategy/base.py`)
  - `size_by_confidence(asset_id, confidence, max_percent, price)` - Kelly-like position sizing
  - `rebalance_to_weights(target_weights, current_prices)` - Portfolio rebalancing
  - `get_unrealized_pnl_pct(asset_id: str) -> float | None` - P&L tracking for exits

- **Features:**
  - Concise, readable strategy code (eliminates boilerplate)
  - Type-safe with comprehensive docstrings
  - Error handling: raises `ValueError` if broker not initialized
  - Realistic position sizing (respects cash constraints)
  - +429 lines of implementation and documentation

#### Context Integration
- **Context Class** (`src/ml4t/backtest/core/context.py`)
  - `Context` dataclass for market-wide indicators (VIX, SPY, regime)
  - Immutable, shared across all assets per timestamp
  - Clean separation from asset-specific signals

- **ContextCache** (`src/ml4t/backtest/core/context.py`)
  - Timestamp-based caching for memory efficiency
  - **Measured savings:** 2-5x memory reduction (tracemalloc benchmarks)
  - Scales with context richness: 2x (minimal) → 5x (50+ indicators)
  - Recommended for multi-asset strategies (100+ stocks)

- **BacktestEngine Integration** (`src/ml4t/backtest/engine.py`)
  - New `context_data: dict[datetime, dict[str, float]]` parameter
  - Engine passes context dict to `strategy.on_market_event(event, context)`
  - ContextCache automatically enabled for memory efficiency

#### Breaking Changes
- **Strategy.on_market_event signature** (`src/ml4t/backtest/strategy/base.py`)
  - **Old:** `def on_market_event(self, event)`
  - **New:** `def on_market_event(self, event, context=None)`
  - **Migration:** Add `context=None` parameter (backward compatible)
  - **Impact:** All internal strategies updated (adapters, crypto_basis_adapter)
  - **Rationale:** Enables context-aware trading logic (VIX filtering, regime switching)

- **Dual Dispatch Migration Path**
  - Strategies can implement both `on_market_event(event, context)` and `on_event(event)`
  - Engine calls `on_market_event` if implemented, falls back to `on_event`
  - Smooth migration: old strategies work without changes, new strategies get context

#### Documentation
- **Memory Files** (`.claude/memory/`)
  - `ml_architecture_proposal.md` (1,388 lines) - Complete architecture design
  - `multi_source_context_architecture.md` - Context design patterns
  - `project_state.md` - Updated with Phase 1 status

- **Code Reviews** (`.claude/reviews/20251115/`)
  - Architectural review request (1,150 lines)
  - Integration analysis (740 lines)
  - Multiple signals analysis (773 lines)
  - Synthesis and recommendations (1,066 lines)

- **Transitions** (`.claude/transitions/2025-11-16/`)
  - Three handoff documents tracking development progress
  - Design decisions, implementation notes, test results

#### Test Coverage
- **498 total tests** (all passing)
- **79% coverage** (up from 77%)
- **Zero regressions**
- New modules fully tested (Context, ContextCache, helper methods)

#### Files Modified (Phase 1)
- `src/ml4t/backtest/core/__init__.py` - Export Context, ContextCache
- `src/ml4t/backtest/core/context.py` - NEW (228 lines)
- `src/ml4t/backtest/core/event.py` - Add signals dict to MarketEvent
- `src/ml4t/backtest/data/feed.py` - Add signal_columns parameter
- `src/ml4t/backtest/engine.py` - Context integration, broker injection
- `src/ml4t/backtest/strategy/base.py` - 9 helper methods (+429 lines)
- `src/ml4t/backtest/strategy/adapters.py` - Update on_market_event signature
- `src/ml4t/backtest/strategy/crypto_basis_adapter.py` - Update on_market_event signature
- `tests/unit/test_engine.py` - Update for new signature

**Total Changes:** +1,082 lines, -36 lines (11 files modified, 1 new file)

---

## Historical Releases

### [0.2.0] - 2025-09-15

#### Fixed - Critical Issues Resolved
- **Event Flow**: Complete event routing from market data to portfolio
- **Temporal Accuracy**: Execution delay prevents lookahead bias
- **Multi-Feed Sync**: Stable ordering for multiple data feeds
- **P&L Calculations**: Clarified for all asset classes (options, FX, crypto)
- **Cash Constraints**: Robust handling prevents negative fill quantities
- **Corporate Actions**: Integrated stock splits, dividends processing

#### Test Coverage
- 159 tests including edge cases and integration
- Comprehensive validation suite
- See `docs/DELIVERY_SUMMARY.md` for details

### [0.1.0] - 2025-01-15

#### Added - Initial Release
- Event-driven backtesting engine
- Advanced order types (Market, Limit, Stop, StopLimit)
- Execution models (slippage, commission, market impact)
- Multi-asset support
- Portfolio tracking and analytics
- VectorBT validation (100% agreement)

---

## Notes

### Version Numbering
- **Phase releases** (Phase 1, Phase 1b): Pre-1.0 development, not yet versioned
- **0.x.x releases**: Beta stage, API may change
- **1.0.0 release**: Stable API, semantic versioning enforced

### Breaking Change Policy
- **Pre-1.0**: Breaking changes documented but expected
- **Post-1.0**: Major version bump required for breaking changes

### Performance Metrics
- **Event processing**: 8,000-12,000 events/sec (ML strategies)
- **Memory efficiency**: 2-5x savings with ContextCache (multi-asset)
- **Test coverage**: 81% overall, 74% strategy base class

---

[Unreleased]: https://github.com/ml4t/backtest/compare/v0.2.0...HEAD
[0.2.0]: https://github.com/ml4t/backtest/compare/v0.1.0...v0.2.0
[0.1.0]: https://github.com/ml4t/backtest/releases/tag/v0.1.0
</file>

<file path="src/ml4t/backtest/models.py">
"""Pluggable commission and slippage models."""

from typing import Protocol, runtime_checkable

# === Protocols ===


@runtime_checkable
class CommissionModel(Protocol):
    """Protocol for commission calculation."""

    def calculate(self, asset: str, quantity: float, price: float) -> float: ...


@runtime_checkable
class SlippageModel(Protocol):
    """Protocol for slippage/market impact calculation."""

    def calculate(
        self, asset: str, quantity: float, price: float, volume: float | None
    ) -> float: ...


# === Commission Models ===


class NoCommission:
    """Zero commission."""

    def calculate(self, asset: str, quantity: float, price: float) -> float:
        return 0.0


class PercentageCommission:
    """Commission as percentage of trade value."""

    def __init__(self, rate: float = 0.001):
        self.rate = rate

    def calculate(self, asset: str, quantity: float, price: float) -> float:
        return abs(quantity * price * self.rate)


class PerShareCommission:
    """Fixed commission per share with optional minimum."""

    def __init__(self, per_share: float = 0.005, minimum: float = 1.0):
        self.per_share = per_share
        self.minimum = minimum

    def calculate(self, asset: str, quantity: float, price: float) -> float:
        return max(abs(quantity) * self.per_share, self.minimum)


class TieredCommission:
    """Tiered commission based on trade value."""

    def __init__(self, tiers: list[tuple[float, float]]):
        # [(threshold, rate), ...] e.g. [(10000, 0.001), (50000, 0.0008), (inf, 0.0005)]
        self.tiers = sorted(tiers, key=lambda x: x[0])

    def calculate(self, asset: str, quantity: float, price: float) -> float:
        value = abs(quantity * price)
        for threshold, rate in self.tiers:
            if value <= threshold:
                return value * rate
        return value * self.tiers[-1][1]


class CombinedCommission:
    """Combined percentage + fixed commission per trade."""

    def __init__(self, percentage: float = 0.0, fixed: float = 0.0):
        self.percentage = percentage
        self.fixed = fixed

    def calculate(self, asset: str, quantity: float, price: float) -> float:
        value = abs(quantity * price)
        return value * self.percentage + self.fixed


# === Slippage Models ===


class NoSlippage:
    """Zero slippage."""

    def calculate(self, asset: str, quantity: float, price: float, volume: float | None) -> float:
        return 0.0


class FixedSlippage:
    """Fixed slippage per share."""

    def __init__(self, amount: float = 0.01):
        self.amount = amount

    def calculate(self, asset: str, quantity: float, price: float, volume: float | None) -> float:
        return abs(quantity) * self.amount


class PercentageSlippage:
    """Slippage as percentage of price (per-unit price adjustment)."""

    def __init__(self, rate: float = 0.001):
        self.rate = rate

    def calculate(self, asset: str, quantity: float, price: float, volume: float | None) -> float:
        # Return per-unit price adjustment (not total dollars)
        # Broker adds this to fill price: fill = base_price ± slippage
        return price * self.rate


class VolumeShareSlippage:
    """Slippage based on order size vs volume (market impact)."""

    def __init__(self, impact_factor: float = 0.1):
        self.impact_factor = impact_factor

    def calculate(self, asset: str, quantity: float, price: float, volume: float | None) -> float:
        if volume is None or volume == 0:
            return 0.0
        volume_fraction = abs(quantity) / volume
        impact = volume_fraction * self.impact_factor
        # Return per-unit price adjustment (not total dollars)
        return price * impact
</file>

<file path="CLAUDE.md">
# CLAUDE.md - ml4t.backtest Development Guidelines

## Project Understanding
@.claude/PROJECT_MAP.md

## Context & Location

**You are in**: `/home/stefan/ml4t/software/backtest/` (ml4t.backtest library)
**Parent directory**: `/home/stefan/ml4t/software/` (multi-library coordination)
**Sibling libraries**: `../data/`, `../features/`, `../evaluation/`
**Integration projects**: `../projects/` (use ml4t.backtest in workflows)

**Division of Labor**: See `../.claude/memory/division_of_labor.md` for when to work here vs parent directory.

**Work in THIS directory for**:
- Event-driven execution engine improvements
- Order types and execution logic
- Position tracking and portfolio management
- Broker simulation and fill models
- Unit tests for ml4t.backtest functionality
- API improvements and documentation

**Work in PARENT directory for**:
- Multi-library workflows using ml4t.backtest + others
- Integration testing in `../projects/`
- Validation studies (e.g., VectorBT exact matching)

## Vision & Goals

ml4t.backtest provides an event-driven backtesting engine with institutional-grade execution fidelity.

**Core Mission**: Replicate real trading conditions with point-in-time correctness and realistic execution.

## Key Architecture

- **Event-Driven**: Market, signal, order, fill events
- **Point-in-Time Safety**: No look-ahead bias
- **Vectorized Hybrid**: Event-driven control + vectorized execution
- **Pluggable Components**: Broker, commission, slippage models
- **Performance**: 100k+ events/second

## Critical Known Issues

### Position Sync Issue (Fixed)
**Problem**: Dual position tracking
- `broker.position_tracker`: Updated on fills (source of truth)
- `broker.portfolio.positions`: Separate object (stale after fills)

**Solution**: Strategies query `broker.get_position()` instead of `portfolio.positions.get()`.

See `../projects/crypto_futures/` for validation work.

### VectorBT OSS/Pro Conflict (Critical)
**Problem**: VectorBT OSS and Pro CANNOT coexist in the same environment.
Both register a pandas `.vbt` accessor which collide. Running OSS imports before Pro causes:
```
AttributeError: 'OHLCVDFAccessor' object has no attribute 'has_ohlc'
```

**Solution**: Use separate virtual environments (ALL ALREADY EXIST):
```
.venv                 - Main development (VectorBT OSS)
.venv-vectorbt-pro    - VectorBT Pro only (for Pro-specific tests)
.venv-vectorbt        - VectorBT OSS only
.venv-backtrader      - Backtrader only
.venv-zipline         - Zipline only
.venv-validation      - Combined validation (BROKEN - OSS/Pro conflict)
```

**To run tests with VectorBT Pro:**
```bash
source .venv-vectorbt-pro/bin/activate
python -m pytest tests/validation/ -q
```

**Test conftest.py behavior**: Don't import VectorBT OSS if Pro is available to avoid accessor conflict.

### Python 3.12 Traceback Formatting Bug
**Problem**: `traceback.format_exc()` can crash with `RuntimeError: generator raised StopIteration` when formatting certain exception chains (especially from Zipline).

**Solution**: Wrap traceback calls in try/except:
```python
try:
    result.errors.append(traceback.format_exc())
except RuntimeError:
    result.errors.append(f"Exception type: {type(e).__name__}")
```

### Zipline Bundle/Symbol Resolution (Excluded)
**Problem**: Zipline `run_algorithm()` has environment-specific bundle/symbol issues.
The bundle may have AAPL registered but `symbol('AAPL')` fails at runtime.

**Decision**: Zipline excluded from cross-framework validation (see AD-001 in docs).
Test file `test_zipline_adapter.py` is fully skipped.

## Development Standards

- **Python**: 3.9+ with type hints
- **Testing**: pytest with comprehensive coverage
- **Linting**: ruff (100 char line length)
- **Performance**: Numba JIT for hot paths
- **Quality**: Pre-commit hooks
- **Correctness**: No look-ahead bias, point-in-time accuracy

## Projects Awareness

`../projects/` uses ml4t.backtest for:
- Strategy backtesting
- VectorBT replication and validation
- Execution fidelity testing
- Performance benchmarking

**Integration Work**: The VectorBT exact matching study (`../projects/crypto_futures/`) validates ml4t.backtest produces identical results to VectorBT Pro.

Coordinate breaking changes through parent `.claude/`.

## Key Validation Requirements

When modifying execution logic:
1. Ensure point-in-time correctness (no look-ahead)
2. Test same-bar re-entry scenarios
3. Validate position sync after fills
4. Check against VectorBT reference results
5. Verify fill prices are within OHLC bounds

## 🚨 CRITICAL: Framework Source Code Availability

**ALL BENCHMARK FRAMEWORKS HAVE COMPLETE SOURCE CODE LOCALLY AVAILABLE**

**Locations**:
- ✅ **Zipline-reloaded**: `resources/zipline-reloaded-main/src/zipline/`
- ✅ **Backtrader**: `resources/backtrader-master/backtrader/`
- ✅ **VectorBT OSS**: `resources/vectorbt/vectorbt/`
- ✅ **VectorBT Pro**: `resources/vectorbt.pro-main/vectorbtpro/`

### Zero Tolerance Policy for "I Don't Know"

**NEVER ACCEPTABLE**:
- ❌ "Unclear how VectorBT executes fills"
- ❌ "Need to research Backtrader's order logic"
- ❌ "Not sure why Zipline produces different results"

**ALWAYS REQUIRED**:
1. Read the actual source code (`Read resources/framework/relevant_file.py`)
2. Cite specific files and line numbers
3. Explain the exact implementation difference with code evidence
4. Document findings in validation report

### Investigation Protocol (Mandatory)

When frameworks produce different results:

```bash
# 1. Search for relevant code
grep -rn "fill.*price\|execution" resources/vectorbt/vectorbt/portfolio/
grep -rn "fill.*price\|execution" resources/backtrader-master/backtrader/brokers/

# 2. Read the implementation
Read resources/vectorbt/vectorbt/portfolio/base.py
Read resources/backtrader-master/backtrader/brokers/bbroker.py

# 3. Compare and cite specific lines
# Example: "VectorBT fills at close (base.py:3245),
#           Backtrader fills at next open (bbroker.py:467)"

# 4. Use Serena for semantic search (if available)
mcp__serena__find_symbol("from_signals", "resources/vectorbt/")
```

**This is not optional. This is mandatory for all validation work.**

### Key Framework Files

**VectorBT OSS/Pro**:
- Portfolio API: `portfolio/base.py` (from_signals, from_orders, from_holding)
- Numba execution: `portfolio/nb/from_signals.py` (vectorized fill logic)
- Orders: `portfolio/orders.py` (order types, execution)

**Backtrader**:
- Broker: `brokers/bbroker.py` (order execution, COO/COC, fills)
- Orders: `order.py` (order types, status)
- Cerebro: `cerebro.py` (engine orchestration)

**Zipline**:
- Execution: `finance/execution.py` (order placement, fills)
- Commission: `finance/commission.py` (PerShare, PerTrade, PerDollar)
- Slippage: `finance/slippage.py` (FixedSlippage, VolumeShareSlippage)

## References

- Event-driven architecture patterns
- VectorBT Pro fill model documentation
- Position tracking best practices
- Framework source code in `resources/` (see above)
</file>

<file path="README.md">
# ml4t.backtest - Event-Driven Backtesting Engine

**Status**: Beta - Accounting System Complete
**Current version**: 0.2.0
**Performance**: 30x faster than Backtrader
**Accounting**: Cash and margin accounts with proper constraints

---

## Overview

ml4t.backtest is a high-performance, event-driven backtesting engine for quantitative trading strategies with institutional-grade accounting.

### Key Features

- ✅ **Realistic Accounting**: Cash and margin account support with proper constraints
- ✅ **Performance**: 30x faster than Backtrader, 5x faster than VectorBT
- ✅ **Point-in-Time Correctness**: No look-ahead bias
- ✅ **Flexible Execution**: Same-bar and next-bar modes
- ✅ **Comprehensive Testing**: 160+ tests with 69% coverage
- ✅ **Type-Safe**: Full type hints with mypy validation

---

## Installation

```bash
pip install ml4t-backtest
```

Or for development:

```bash
git clone https://github.com/yourusername/ml4t-backtest
cd ml4t-backtest
uv sync  # or pip install -e .
```

---

## Quick Start

```python
import polars as pl
from datetime import datetime, timedelta
from ml4t.backtest import Engine, Strategy, DataFeed, PerShareCommission

# Create sample data
dates = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(100)]
data = pl.DataFrame({
    "timestamp": dates,
    "asset": ["AAPL"] * 100,
    "open": [100 + i * 0.5 for i in range(100)],
    "high": [101 + i * 0.5 for i in range(100)],
    "low": [99 + i * 0.5 for i in range(100)],
    "close": [100 + i * 0.5 for i in range(100)],
    "volume": [1_000_000] * 100,
})

# Define strategy
class SimpleStrategy(Strategy):
    def on_data(self, timestamp, data, context, broker):
        if "AAPL" not in data:
            return

        price = data["AAPL"]["close"]
        position = broker.get_position("AAPL")

        # Buy on day 1, sell on day 50
        if timestamp.day == 1 and (position is None or position.quantity == 0):
            broker.submit_order("AAPL", 100)  # Buy 100 shares
        elif timestamp.day == 50 and position and position.quantity > 0:
            broker.submit_order("AAPL", -position.quantity)  # Sell all

# Run backtest
feed = DataFeed(prices_df=data)
strategy = SimpleStrategy()

engine = Engine(
    feed,
    strategy,
    initial_cash=50_000.0,
    account_type="cash",  # or "margin"
    commission_model=PerShareCommission(0.01),
)

results = engine.run()

print(f"Final Value: ${results['final_value']:,.2f}")
print(f"Total Return: {results['total_return_pct']:.2f}%")
print(f"Total Trades: {results['num_trades']}")
```

---

## Account Types

ml4t.backtest supports two account types with realistic constraints:

### Cash Account

Cash accounts enforce strict constraints:
- ✅ **No leverage**: Can only trade with available cash
- ✅ **No short selling**: Cannot hold negative positions
- ✅ **Buying power = cash**: Simple calculation
- ✅ **Order rejection**: Orders rejected if insufficient cash

**Example: Cash Account**

```python
from ml4t.backtest import Engine, Strategy, DataFeed

class BuyAndHoldStrategy(Strategy):
    def on_data(self, timestamp, data, context, broker):
        if "AAPL" not in data:
            return

        position = broker.get_position("AAPL")

        # Try to buy on first day
        if timestamp.day == 1 and (position is None or position.quantity == 0):
            price = data["AAPL"]["close"]
            # Try to buy $60,000 worth (will be rejected with $50k initial cash)
            quantity = int(60_000 / price)
            order = broker.submit_order("AAPL", quantity)

            if order is None:
                print(f"Order rejected: Insufficient cash")
                # Adjust to affordable quantity
                quantity = int(broker.account.cash / price)
                broker.submit_order("AAPL", quantity)

# Run with cash account
engine = Engine(
    feed,
    strategy,
    initial_cash=50_000.0,
    account_type="cash",  # Cash account (default)
)

results = engine.run()
```

**Constraints Enforced**:
- Orders exceeding available cash are rejected
- Short selling attempts are rejected
- Exit orders always execute (closing positions)

### Margin Account

Margin accounts allow leverage and short selling:
- ✅ **Leverage enabled**: Can trade up to 2x cash (50% initial margin)
- ✅ **Short selling allowed**: Can hold negative positions
- ✅ **Margin requirements**: Initial and maintenance margin enforced
- ✅ **Buying power formula**: `(NLV - MM) / IM`

**Example: Margin Account**

```python
from ml4t.backtest import Engine, Strategy, DataFeed

class FlippingStrategy(Strategy):
    """Strategy that flips between long and short positions."""

    def __init__(self):
        self.bar_count = 0

    def on_data(self, timestamp, data, context, broker):
        if "AAPL" not in data:
            return

        self.bar_count += 1
        position = broker.get_position("AAPL")
        current_qty = position.quantity if position else 0

        # Odd bars: long, Even bars: short
        target_qty = 100 if (self.bar_count % 2 == 1) else -100
        order_qty = target_qty - current_qty

        if order_qty != 0:
            broker.submit_order("AAPL", order_qty)

# Run with margin account
engine = Engine(
    feed,
    strategy,
    initial_cash=50_000.0,
    account_type="margin",  # Margin account
    initial_margin=0.5,     # 50% initial margin (2x leverage)
    maintenance_margin=0.25,  # 25% maintenance margin
)

results = engine.run()
```

**Margin Calculations**:
- **Net Liquidation Value (NLV)**: `cash + sum(position_values)`
- **Maintenance Margin (MM)**: `sum(abs(position_values) × maintenance_margin)`
- **Buying Power (BP)**: `(NLV - MM) / initial_margin`

**Constraints Enforced**:
- Orders exceeding buying power are rejected
- Position reversals (long→short) are split into close + open
- Short positions tracked with negative quantities
- Margin calls enforced when equity falls below maintenance margin

---

## Order Rejection Scenarios

Understanding when orders are rejected helps design robust strategies.

### Cash Account Rejections

```python
class CashAccountStrategy(Strategy):
    def on_data(self, timestamp, data, context, broker):
        price = data["AAPL"]["close"]
        cash = broker.account.cash

        # Scenario 1: Insufficient cash
        expensive_quantity = int(100_000 / price)  # Try to buy $100k worth
        order = broker.submit_order("AAPL", expensive_quantity)
        if order is None:
            print(f"Rejected: Insufficient cash (have ${cash:.0f}, need $100,000)")

        # Scenario 2: Attempted short sale
        order = broker.submit_order("AAPL", -100)  # Try to short 100 shares
        if order is None:
            print(f"Rejected: Cash accounts cannot short sell")

        # Scenario 3: Successful purchase
        affordable_quantity = int(cash / price)
        order = broker.submit_order("AAPL", affordable_quantity)
        if order is not None:
            print(f"Accepted: Bought {affordable_quantity} shares")
```

### Margin Account Rejections

```python
class MarginAccountStrategy(Strategy):
    def on_data(self, timestamp, data, context, broker):
        price = data["AAPL"]["close"]
        position = broker.get_position("AAPL")

        # Get buying power (includes leverage)
        buying_power = broker.get_buying_power()

        # Scenario 1: Within buying power (accepted)
        quantity = int(buying_power / price)
        order = broker.submit_order("AAPL", quantity)
        if order is not None:
            print(f"Accepted: Bought {quantity} shares using leverage")

        # Scenario 2: Exceeds buying power (rejected)
        excessive_quantity = int((buying_power * 2) / price)
        order = broker.submit_order("AAPL", excessive_quantity)
        if order is None:
            print(f"Rejected: Exceeds buying power")

        # Scenario 3: Position reversal (split into close + open)
        if position and position.quantity > 0:
            # Going from long 100 to short 100 (reversal)
            reversal_order = broker.submit_order("AAPL", -200)
            # Internally split into: close 100, then open -100
            # Both must satisfy margin requirements
```

---

## API Reference

### Engine

```python
Engine(
    feed: DataFeed,
    strategy: Strategy,
    initial_cash: float = 100_000.0,
    account_type: str = "cash",  # "cash" or "margin"
    initial_margin: float = 0.5,  # For margin accounts only
    maintenance_margin: float = 0.25,  # For margin accounts only
    commission_model: Optional[CommissionModel] = None,
    slippage_model: Optional[SlippageModel] = None,
    execution_mode: ExecutionMode = ExecutionMode.SAME_BAR,
)
```

**Parameters**:
- `feed`: DataFeed object containing price data
- `strategy`: Strategy object implementing trading logic
- `initial_cash`: Starting cash amount (default: $100,000)
- `account_type`: `"cash"` (no leverage, no shorts) or `"margin"` (leverage + shorts)
- `initial_margin`: Initial margin requirement (default: 0.5 = 50% = 2x leverage)
- `maintenance_margin`: Maintenance margin requirement (default: 0.25 = 25%)
- `commission_model`: Commission model (default: no commission)
- `slippage_model`: Slippage model (default: no slippage)
- `execution_mode`: When orders fill (default: SAME_BAR)

**Returns**: Dictionary with results:
```python
{
    "initial_cash": float,
    "final_value": float,
    "total_return": float,
    "total_return_pct": float,
    "max_drawdown": float,
    "max_drawdown_pct": float,
    "num_trades": int,
    "winning_trades": int,
    "losing_trades": int,
    "win_rate": float,
    "total_commission": float,
    "total_slippage": float,
    "trades": List[Trade],
    "equity_curve": List[Tuple[datetime, float]],
    "fills": List[Fill],
}
```

### Strategy

```python
class Strategy:
    def on_start(self, broker: Broker):
        """Called once before backtest starts."""
        pass

    def on_data(self, timestamp: datetime, data: Dict[str, Dict[str, float]],
                context: Any, broker: Broker):
        """Called on each bar/tick.

        Args:
            timestamp: Current event timestamp
            data: Dict[asset, Dict[field, value]] - e.g., {"AAPL": {"close": 150.0}}
            context: Context object (reserved for future use)
            broker: Broker interface for order submission
        """
        pass

    def on_end(self, broker: Broker):
        """Called once after backtest ends."""
        pass
```

### Broker API

```python
# Submit orders
order = broker.submit_order(asset: str, quantity: int) -> Optional[Order]
# Returns None if order rejected, Order object if accepted

# Get positions
position = broker.get_position(asset: str) -> Optional[Position]
# Returns None if no position, Position object otherwise

# Query account
cash = broker.account.cash  # Available cash
equity = broker.account.equity  # Total account value
positions = broker.account.positions  # Dict[asset, Position]
buying_power = broker.get_buying_power()  # Available buying power
```

---

## Commission Models

```python
from ml4t.backtest import NoCommission, PerShareCommission, PercentageCommission, TieredCommission

# No commission (default)
NoCommission()

# Per-share commission (e.g., $0.01/share)
PerShareCommission(0.01)

# Percentage commission (e.g., 0.1% = 10bps)
PercentageCommission(0.001)

# Tiered commission
TieredCommission(tiers=[
    (0, 10_000, 0.01),    # $0.01/share for 0-10k shares
    (10_000, 100_000, 0.005),  # $0.005/share for 10k-100k
    (100_000, float('inf'), 0.001),  # $0.001/share for 100k+
])
```

---

## Slippage Models

```python
from ml4t.backtest import NoSlippage, FixedSlippage, PercentageSlippage, VolumeShareSlippage

# No slippage (default)
NoSlippage()

# Fixed slippage (e.g., $0.05 per share)
FixedSlippage(0.05)

# Percentage slippage (e.g., 0.05% = 5bps)
PercentageSlippage(0.0005)

# Volume-based slippage
VolumeShareSlippage(
    volume_limit=0.025,  # 2.5% of bar volume
    price_impact=0.1,    # 10% price impact if limit hit
)
```

---

## Validation

ml4t.backtest has been validated against industry-standard frameworks:

- **vs Backtrader**: 0.39% P&L difference (same-bar mode)
- **vs VectorBT**: <1% difference (cash-constrained mode)
- **Test Coverage**: 69% with 160+ tests

See `tests/validation/` for validation studies.

---

## Performance

Benchmarks on 250 assets × 252 trading days:

| Framework | Runtime | vs ml4t.backtest |
|-----------|---------|------------------|
| **ml4t.backtest** | 0.6s | 1x |
| **VectorBT** | 3.4s | 5.7x slower |
| **Backtrader** | 18.7s | 31x slower |

---

## Testing

```bash
# Run all tests
pytest

# Run unit tests only
pytest tests/unit/

# Run validation tests
pytest tests/validation/

# Run with coverage
pytest --cov=src/ml4t/backtest --cov-report=html
```

---

## Examples

See `examples/` directory for:
- Simple moving average crossover
- ML-based strategies
- Multi-asset portfolios
- Crypto basis trading
- Commission and slippage demos

---

## Documentation

- **Architecture**: See `.claude/memory/` for design decisions
- **Margin Calculations**: See `docs/margin_calculations.md` (coming soon)
- **Trade Schema**: See `.claude/reference/TRADE_SCHEMA.md`

---

## Contributing

Contributions welcome! Please:

1. Fork the repository
2. Create a feature branch
3. Add tests for new functionality
4. Ensure all tests pass (`pytest`)
5. Submit a pull request

---

## License

MIT License - See LICENSE file

---

## Changelog

### v0.2.0 (2025-11-20)
- ✅ Complete accounting system overhaul
- ✅ Cash account support with proper constraints
- ✅ Margin account support (leverage + short selling)
- ✅ Position reversal handling
- ✅ 160+ tests with validation studies
- ✅ Exit-first order sequencing

### v0.1.0 (2025-01-20)
- Initial prototype
- Event-driven architecture
- Basic order execution
- Performance benchmarks

---

**Status**: Beta - Accounting system complete, ready for testing
**Last updated**: 2025-11-20
</file>

<file path="src/ml4t/backtest/__init__.py">
"""ml4t.backtest - Minimal event-driven backtesting engine.

A clean, extensible backtesting engine with:
- Multi-asset support
- Polars-first data handling
- Pluggable commission/slippage models
- Same-bar and next-bar execution modes
- Live trading compatible interface
"""

__version__ = "0.2.0"

# Import from modules
from .broker import Broker
from .config import (
    PRESETS_DIR,
    BacktestConfig,
    ExecutionPrice,
    FillTiming,
    ShareType,
    SignalProcessing,
    SizingMethod,
)
from .config import (
    CommissionModel as CommissionModelType,
)
from .config import (
    SlippageModel as SlippageModelType,
)
from .datafeed import DataFeed
from .engine import BacktestEngine, Engine, run_backtest
from .models import (
    CombinedCommission,
    CommissionModel,
    FixedSlippage,
    NoCommission,
    NoSlippage,
    PercentageCommission,
    PercentageSlippage,
    PerShareCommission,
    SlippageModel,
    TieredCommission,
    VolumeShareSlippage,
)
from .strategy import Strategy
from .types import (
    ExecutionMode,
    Fill,
    Order,
    OrderSide,
    OrderStatus,
    OrderType,
    Position,
    Trade,
)

__all__ = [
    # Types
    "OrderType",
    "OrderSide",
    "OrderStatus",
    "ExecutionMode",
    "Order",
    "Position",
    "Fill",
    "Trade",
    # Models
    "CommissionModel",
    "SlippageModel",
    "NoCommission",
    "PercentageCommission",
    "PerShareCommission",
    "TieredCommission",
    "CombinedCommission",
    "NoSlippage",
    "FixedSlippage",
    "PercentageSlippage",
    "VolumeShareSlippage",
    # Core
    "DataFeed",
    "Broker",
    "Strategy",
    "Engine",
    "BacktestEngine",  # Backward compatibility alias
    "run_backtest",
    # Configuration
    "BacktestConfig",
    "FillTiming",
    "ExecutionPrice",
    "ShareType",
    "SizingMethod",
    "SignalProcessing",
    "CommissionModelType",
    "SlippageModelType",
    "PRESETS_DIR",
]
</file>

<file path="pyproject.toml">
# ml4t.backtest - Event-driven backtesting with institutional-grade correctness guarantees
# Independent package configuration for standalone distribution

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.version]
path = "src/ml4t/backtest/__init__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/ml4t"]
namespaces = true

[tool.hatch.build.targets.sdist]
include = [
    "/src",
    "/tests",
    "/README.md",
    "/LICENSE",
    "/CHANGELOG.md",
]

[project]
name = "ml4t-backtest"
dynamic = ["version"]
description = "State-of-the-art event-driven backtesting engine for quantitative trading"
readme = "README.md"
license = { text = "MIT" }
authors = [
    { name = "QuantLab Team", email = "info@quantlab.io" },
]
maintainers = [
    { name = "QuantLab Contributors", email = "dev@quantlab.io" },
]
keywords = [
    "finance",
    "backtesting",
    "trading",
    "simulation",
    "event-driven",
    "quantitative-finance",
    "algorithmic-trading",
    "portfolio",
    "risk-management",
    "execution",
    "polars",
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Financial and Insurance Industry",
    "Intended Audience :: Developers",
    "Intended Audience :: Science/Research",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Topic :: Office/Business :: Financial :: Investment",
    "Topic :: Scientific/Engineering :: Information Analysis",
    "Topic :: Software Development :: Libraries :: Application Frameworks",
    "Typing :: Typed",
]
requires-python = ">=3.11"

# Core dependencies
dependencies = [
    # Data processing
    "polars>=0.20.0",
    "pandas>=2.0.0",
    "numpy>=1.24.0",
    "pyarrow>=14.0.0",
    "tables>=3.8.0",  # PyTables for HDF5 support
    # Event system
    "sortedcontainers>=2.4.0", # Efficient priority queue
    # Performance optimization
    "numba>=0.57.0",
    # Configuration and validation
    "pydantic>=1.10.0,<3.0.0",  # Configuration schema and validation
    "PyYAML>=6.0.0",  # YAML configuration support
    # Utilities
    "structlog>=23.0.0",
    "python-dateutil>=2.8.0",
    # Market calendars (needed for clock module)
    "pandas-market-calendars>=4.0.0",
    "pytest>=8.4.2",
]

[project.optional-dependencies]
# Visualization and reporting
viz = [
    "plotly>=5.15.0",
    "matplotlib>=3.7.0",
    "dash>=2.11.0",  # Interactive dashboards
]

# Advanced execution models
advanced = [
    "networkx>=3.0",  # Order routing graphs
    "cvxpy>=1.3.0",  # Portfolio optimization
]

# Comparison libraries (for benchmarking)
comparison = [
    "vectorbt>=0.24.0",
    "backtrader>=1.9.0",
    "zipline-reloaded>=2.4.0",
]

# Development dependencies
dev = [
    "pytest>=7.4.0",
    "pytest-cov>=4.1.0",
    "pytest-xdist>=3.3.0",
    "pytest-timeout>=2.1.0",
    "pytest-benchmark>=4.0.0",
    "pytest-asyncio>=0.21.0",
    "hypothesis>=6.80.0",
    "ruff>=0.1.0",
    "mypy>=1.5.0",
    "ipython>=8.14.0",
    "ipdb>=0.13.0",
    "pre-commit>=3.3.0",
]

# Documentation dependencies
docs = [
    "sphinx>=7.0.0",
    "sphinx-rtd-theme>=1.3.0",
    "sphinx-autodoc-typehints>=1.24.0",
    "myst-parser>=2.0.0",
    "nbsphinx>=0.9.0",
]

# All optional dependencies
all = [
    "ml4t-backtest[viz,advanced,dev,docs]",
]

[project.urls]
Homepage = "https://github.com/ml4t/ml4t-backtest"
Documentation = "https://ml4t-backtest.readthedocs.io"
Repository = "https://github.com/ml4t/ml4t-backtest"
Issues = "https://github.com/ml4t/ml4t-backtest/issues"
Changelog = "https://github.com/ml4t/ml4t-backtest/blob/main/CHANGELOG.md"

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = [
    "-ra",
    "--strict-markers",
    "--ignore=tests/private",  # Exclude private/commercial dependency tests
    "--ignore=tests/validation",  # Exclude optional cross-framework validation tests
    "--cov=ml4t.backtest",
    "--cov-report=term-missing",
    "--cov-report=html",
]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "integration: marks tests as integration tests",
    "benchmark: marks benchmark tests",
    "unit: marks unit tests",
    "private: requires commercial dependencies (vectorbtpro) - excluded by default",
    "requires_comparison: requires optional comparison frameworks (vectorbt, backtrader, zipline)",
]
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::PendingDeprecationWarning",
    "ignore::UserWarning:vectorbt",  # VectorBT accessor registration warnings
    "ignore::tables.NaturalNameWarning",  # PyTables naming warnings
    "ignore::FutureWarning:zipline",  # Zipline compatibility warnings
    "ignore::pytest.PytestReturnNotNoneWarning",  # Some tests return values for direct execution
]

[tool.ruff]
line-length = 100
target-version = "py311"
fix = true

[tool.ruff.lint]
select = [
    "E",    # pycodestyle errors
    "W",    # pycodestyle warnings
    "F",    # pyflakes
    "I",    # isort
    "B",    # flake8-bugbear
    "C4",   # flake8-comprehensions
    "UP",   # pyupgrade
    "ARG",  # flake8-unused-arguments
    "SIM",  # flake8-simplify
]
ignore = [
    "E501",  # line too long (handled by formatter)
    "B008",  # do not perform function calls in argument defaults
    "B905",  # zip without explicit strict parameter
    "ARG002",  # unused method arguments (intentional in strategy callbacks)
]

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["ARG001", "ARG002"]  # Test functions often have unused fixtures

[tool.mypy]
python_version = "3.11"
strict = false
warn_return_any = false
warn_unused_ignores = false
disallow_untyped_defs = false
disallow_any_unimported = false
no_implicit_optional = false
check_untyped_defs = false
show_error_codes = true
warn_redundant_casts = true
ignore_missing_imports = true

[tool.coverage.run]
source = ["src/ml4t/backtest"]
omit = [
    "*/tests/*",
    "*/__init__.py",
]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "if self.debug:",
    "if __name__ == .__main__.:",
    "raise NotImplementedError",
    "pass",
    "except ImportError:",
    "@abstractmethod",
]
</file>

<file path="src/ml4t/backtest/engine.py">
"""Backtesting engine orchestration."""

from __future__ import annotations

from datetime import datetime
from typing import TYPE_CHECKING

import polars as pl

from .broker import Broker
from .datafeed import DataFeed
from .models import CommissionModel, PercentageCommission, PercentageSlippage, SlippageModel
from .strategy import Strategy
from .types import ExecutionMode

if TYPE_CHECKING:
    from .config import BacktestConfig


class Engine:
    """Backtesting engine."""

    def __init__(
        self,
        feed: DataFeed,
        strategy: Strategy,
        initial_cash: float = 100000.0,
        commission_model: CommissionModel | None = None,
        slippage_model: SlippageModel | None = None,
        execution_mode: ExecutionMode = ExecutionMode.SAME_BAR,
        account_type: str = "cash",
        initial_margin: float = 0.5,
        maintenance_margin: float = 0.25,
        config: BacktestConfig | None = None,
    ):
        self.feed = feed
        self.strategy = strategy
        self.execution_mode = execution_mode
        self.config = config  # Store config for strategy access
        self.broker = Broker(
            initial_cash=initial_cash,
            commission_model=commission_model,
            slippage_model=slippage_model,
            execution_mode=execution_mode,
            account_type=account_type,
            initial_margin=initial_margin,
            maintenance_margin=maintenance_margin,
        )
        self.equity_curve: list[tuple[datetime, float]] = []

    def run(self) -> dict:
        """Run backtest and return results."""
        self.strategy.on_start(self.broker)

        for timestamp, assets_data, context in self.feed:
            prices = {a: d["close"] for a, d in assets_data.items() if d.get("close")}
            opens = {a: d.get("open", d.get("close")) for a, d in assets_data.items()}
            volumes = {a: d.get("volume", 0) for a, d in assets_data.items()}
            signals = {a: d.get("signals", {}) for a, d in assets_data.items()}

            self.broker._update_time(timestamp, prices, opens, volumes, signals)

            if self.execution_mode == ExecutionMode.NEXT_BAR:
                # Next-bar mode: process pending orders at open price
                self.broker._process_orders(use_open=True)
                # Strategy generates new orders
                self.strategy.on_data(timestamp, assets_data, context, self.broker)
                # New orders will be processed next bar
            else:
                # Same-bar mode: process before and after strategy
                self.broker._process_orders()
                self.strategy.on_data(timestamp, assets_data, context, self.broker)
                self.broker._process_orders()

            self.equity_curve.append((timestamp, self.broker.get_account_value()))

        self.strategy.on_end(self.broker)
        return self._generate_results()

    def _generate_results(self) -> dict:
        """Generate backtest results."""
        if not self.equity_curve:
            return {}

        initial = self.broker.initial_cash
        final = self.equity_curve[-1][1]
        total_return = (final - initial) / initial

        peak = initial
        max_dd = 0.0
        for _, value in self.equity_curve:
            if value > peak:
                peak = value
            dd = (peak - value) / peak
            if dd > max_dd:
                max_dd = dd

        winning = [t for t in self.broker.trades if t.pnl > 0]
        losing = [t for t in self.broker.trades if t.pnl <= 0]

        return {
            "initial_cash": initial,
            "final_value": final,
            "total_return": total_return,
            "total_return_pct": total_return * 100,
            "max_drawdown": max_dd,
            "max_drawdown_pct": max_dd * 100,
            "num_trades": len(self.broker.trades),
            "winning_trades": len(winning),
            "losing_trades": len(losing),
            "win_rate": len(winning) / len(self.broker.trades) if self.broker.trades else 0,
            "total_commission": sum(f.commission for f in self.broker.fills),
            "total_slippage": sum(f.slippage for f in self.broker.fills),
            "trades": self.broker.trades,
            "equity_curve": self.equity_curve,
            "fills": self.broker.fills,
        }

    @classmethod
    def from_config(
        cls,
        feed: DataFeed,
        strategy: Strategy,
        config: BacktestConfig,
    ) -> Engine:
        """
        Create an Engine instance from a BacktestConfig.

        This is the recommended way to create an engine when you want
        to replicate specific framework behavior (Backtrader, VectorBT, etc.).

        Example:
            from ml4t.backtest import Engine, BacktestConfig, DataFeed, Strategy

            # Use Backtrader-compatible settings
            config = BacktestConfig.from_preset("backtrader")
            engine = Engine.from_config(feed, strategy, config)
            results = engine.run()

        Args:
            feed: DataFeed with price data
            strategy: Strategy to execute
            config: BacktestConfig with all behavioral settings

        Returns:
            Configured Engine instance
        """
        from .config import CommissionModel as CommModelEnum
        from .config import FillTiming
        from .config import SlippageModel as SlipModelEnum

        # Map config fill timing to ExecutionMode
        if config.fill_timing == FillTiming.SAME_BAR:
            execution_mode = ExecutionMode.SAME_BAR
        else:
            # NEXT_BAR_OPEN or NEXT_BAR_CLOSE both use NEXT_BAR mode
            execution_mode = ExecutionMode.NEXT_BAR

        # Build commission model from config
        commission_model: CommissionModel | None = None
        if config.commission_model == CommModelEnum.PERCENTAGE:
            commission_model = PercentageCommission(
                rate=config.commission_rate,
            )
        elif config.commission_model == CommModelEnum.PER_SHARE:
            from .models import PerShareCommission

            commission_model = PerShareCommission(
                per_share=config.commission_per_share,
                minimum=config.commission_minimum,
            )
        elif config.commission_model == CommModelEnum.PER_TRADE:
            from .models import NoCommission

            # For per-trade, we'd need a new model, use NoCommission for now
            commission_model = NoCommission()
        # NONE or unrecognized -> None (will use NoCommission in Broker)

        # Build slippage model from config
        slippage_model: SlippageModel | None = None
        if config.slippage_model == SlipModelEnum.PERCENTAGE:
            slippage_model = PercentageSlippage(rate=config.slippage_rate)
        elif config.slippage_model == SlipModelEnum.FIXED:
            from .models import FixedSlippage

            slippage_model = FixedSlippage(amount=config.slippage_fixed)
        # NONE, VOLUME_BASED, or unrecognized -> None (will use NoSlippage)

        return cls(
            feed=feed,
            strategy=strategy,
            initial_cash=config.initial_cash,
            commission_model=commission_model,
            slippage_model=slippage_model,
            execution_mode=execution_mode,
            account_type=config.account_type,
            initial_margin=config.margin_requirement,
            maintenance_margin=config.margin_requirement * 0.5,  # Standard ratio
            config=config,  # Store config for strategy access
        )


# === Convenience Function ===


def run_backtest(
    prices: pl.DataFrame | str,
    strategy: Strategy,
    signals: pl.DataFrame | str | None = None,
    context: pl.DataFrame | str | None = None,
    config: BacktestConfig | str | None = None,
    # Legacy parameters (used if config is None)
    initial_cash: float = 100000.0,
    commission_model: CommissionModel | None = None,
    slippage_model: SlippageModel | None = None,
    execution_mode: ExecutionMode = ExecutionMode.SAME_BAR,
) -> dict:
    """
    Run a backtest with minimal setup.

    Args:
        prices: Price DataFrame or path to parquet file
        strategy: Strategy instance to execute
        signals: Optional signals DataFrame or path
        context: Optional context DataFrame or path
        config: BacktestConfig instance, preset name (str), or None for legacy params
        initial_cash: Starting cash (legacy, ignored if config provided)
        commission_model: Commission model (legacy, ignored if config provided)
        slippage_model: Slippage model (legacy, ignored if config provided)
        execution_mode: Execution mode (legacy, ignored if config provided)

    Returns:
        Results dictionary with metrics, trades, equity curve

    Example:
        # Using config preset
        results = run_backtest(prices_df, strategy, config="backtrader")

        # Using custom config
        config = BacktestConfig.from_preset("backtrader")
        config.commission_rate = 0.002  # Higher commission
        results = run_backtest(prices_df, strategy, config=config)
    """
    feed = DataFeed(
        prices_path=prices if isinstance(prices, str) else None,
        signals_path=signals if isinstance(signals, str) else None,
        context_path=context if isinstance(context, str) else None,
        prices_df=prices if isinstance(prices, pl.DataFrame) else None,
        signals_df=signals if isinstance(signals, pl.DataFrame) else None,
        context_df=context if isinstance(context, pl.DataFrame) else None,
    )

    # Handle config parameter
    if config is not None:
        from .config import BacktestConfig as ConfigCls

        if isinstance(config, str):
            config = ConfigCls.from_preset(config)
        return Engine.from_config(feed, strategy, config).run()

    # Legacy path: use individual parameters
    engine = Engine(
        feed,
        strategy,
        initial_cash,
        commission_model=commission_model,
        slippage_model=slippage_model,
        execution_mode=execution_mode,
    )
    return engine.run()


# Backward compatibility: BacktestEngine was renamed to Engine in v0.2.0
BacktestEngine = Engine
</file>

</files>
