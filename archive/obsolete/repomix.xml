<file_summary>
    This section contains a summary of this file.

    <purpose>
        This file contains a packed representation of a subset of the repository's contents that is considered the most
        important context.
        It is designed to be easily consumable by AI systems for analysis, code review,
        or other automated processes.
    </purpose>

    <file_format>
        The content is organized as follows:
        1. This summary section
        2. Repository information
        3. Directory structure
        4. Repository files (if enabled)
        5. Multiple file entries, each consisting of:
        - File path as an attribute
        - Full contents of the file
    </file_format>

    <usage_guidelines>
        - This file should be treated as read-only. Any changes should be made to the
        original repository files, not this packed version.
        - When processing this file, use the file path to distinguish
        between different files in the repository.
        - Be aware that this file may contain sensitive information. Handle it with
        the same level of security as you would the original repository.
    </usage_guidelines>

    <notes>
        - Some files may have been excluded based on .gitignore rules and Repomix's configuration
        - Binary files are not included in this packed representation. Please refer to the Repository Structure section
        for a complete list of file paths, including binary files
        - Only files matching these patterns are included: README.md, src/qengine/__init__.py, src/qengine/engine.py,
        src/qengine/core/*.py, src/qengine/data/*.py, src/qengine/execution/*.py, src/qengine/portfolio/*.py,
        src/qengine/strategy/*.py, src/qengine/reporting/*.py, src/*, src/
        - Files matching these patterns are excluded: .venv/**, docs/**, examples/**, tests/**, resources/**,
        htmlcov/**, __pycache__/**, *.pyc, benchmarks/**, config/**
        - Files matching patterns in .gitignore are excluded
        - Files matching default ignore patterns are excluded
        - Files are sorted by Git change count (files with more changes are at the bottom)
    </notes>

</file_summary>

<directory_structure>
src/
qengine/
core/
__init__.py
assets.py
clock.py
constants.py
event.py
types.py
data/
__init__.py
asset_registry.py
feed.py
schemas.py
execution/
__init__.py
bracket_manager.py
broker.py
commission.py
corporate_actions.py
fill_simulator.py
liquidity.py
market_impact.py
order_router.py
order.py
position_sizer.py
position_tracker.py
slippage.py
trade_tracker.py
portfolio/
__init__.py
accounting.py
margin.py
portfolio.py
simple.py
reporting/
__init__.py
base.py
html.py
parquet.py
reporter.py
strategy/
__init__.py
adapters.py
base.py
crypto_basis_adapter.py
__init__.py
engine.py
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/qengine/core/__init__.py">
    """Core event system and time management for QEngine."""

    from qengine.core.assets import AssetClass, AssetRegistry, AssetSpec
    from qengine.core.clock import Clock
    from qengine.core.constants import (
    DEFAULT_COMMISSION_RATE_BPS,
    DEFAULT_CURRENCY,
    DEFAULT_INITIAL_CAPITAL,
    DEFAULT_TAKER_FEE_BPS,
    MAX_COMMISSION_CALC_ITERATIONS,
    MIN_FILL_SIZE,
    PROGRESS_LOG_INTERVAL,
    SLIPPAGE_CRYPTO_BPS,
    SLIPPAGE_EQUITY_BPS,
    SLIPPAGE_FUTURES_BPS,
    SLIPPAGE_FX_BPS,
    bps_to_decimal,
    decimal_to_bps,
    )
    from qengine.core.event import (
    Event,
    EventBus,
    FillEvent,
    MarketEvent,
    OrderEvent,
    SignalEvent,
    )
    from qengine.core.types import AssetId, Price, Quantity, Timestamp

    __all__ = [
    "AssetClass",
    "AssetId",
    "AssetRegistry",
    "AssetSpec",
    "Clock",
    # Constants
    "DEFAULT_INITIAL_CAPITAL",
    "DEFAULT_CURRENCY",
    "PROGRESS_LOG_INTERVAL",
    "MIN_FILL_SIZE",
    "MAX_COMMISSION_CALC_ITERATIONS",
    "DEFAULT_COMMISSION_RATE_BPS",
    "DEFAULT_TAKER_FEE_BPS",
    "SLIPPAGE_EQUITY_BPS",
    "SLIPPAGE_FUTURES_BPS",
    "SLIPPAGE_FX_BPS",
    "SLIPPAGE_CRYPTO_BPS",
    "bps_to_decimal",
    "decimal_to_bps",
    # Events
    "Event",
    "EventBus",
    "FillEvent",
    "MarketEvent",
    "OrderEvent",
    "Price",
    "Quantity",
    "SignalEvent",
    "Timestamp",
    ]
</file>

<file path="src/qengine/core/assets.py">
    """Asset class definitions and specifications for QEngine."""

    from dataclasses import dataclass
    from datetime import datetime
    from enum import Enum

    from qengine.core.types import AssetId, Price


    class AssetClass(Enum):
    """Supported asset classes."""

    EQUITY = "equity"
    FUTURE = "future"
    OPTION = "option"
    FX = "fx"
    CRYPTO = "crypto"
    BOND = "bond"
    COMMODITY = "commodity"


    class ContractType(Enum):
    """Contract types for derivatives."""

    SPOT = "spot"
    FUTURE = "future"
    PERPETUAL = "perpetual"
    CALL = "call"
    PUT = "put"


    @dataclass
    class AssetSpec:
    """
    Complete specification for an asset.

    This class handles the different requirements for various asset classes:
    - Equities: Simple spot trading with T+2 settlement
    - Futures: Margin requirements, expiry, rolling
    - Options: Greeks, expiry, exercise
    - FX: Currency pairs, pip values
    - Crypto: 24/7 trading, fractional shares
    """

    asset_id: AssetId
    asset_class: AssetClass
    contract_type: ContractType = ContractType.SPOT

    # Common fields
    currency: str = "USD"
    tick_size: float = 0.01
    lot_size: float = 1.0
    min_quantity: float = 1.0

    # Equity-specific
    exchange: str | None = None

    # Futures-specific
    contract_size: float = 1.0 # Multiplier for futures/options
    initial_margin: float = 0.0 # Initial margin requirement
    maintenance_margin: float = 0.0 # Maintenance margin requirement
    expiry: datetime | None = None
    underlying: AssetId | None = None # For derivatives
    roll_date: datetime | None = None # When to roll to next contract

    # Options-specific
    strike: Price | None = None
    option_type: str | None = None # "call" or "put"
    exercise_style: str | None = None # "american", "european"

    # FX-specific
    base_currency: str | None = None
    quote_currency: str | None = None
    pip_value: float = 0.0001 # Standard pip value

    # Crypto-specific
    is_24_7: bool = False # Trades 24/7
    network_fees: bool = False # Has blockchain network fees

    # Trading specifications
    maker_fee: float = 0.001 # 0.1% default
    taker_fee: float = 0.001 # 0.1% default
    short_enabled: bool = True
    leverage_available: float = 1.0 # Max leverage

    @property
    def is_derivative(self) -> bool:
    """Check if asset is a derivative."""
    return self.asset_class in [AssetClass.FUTURE, AssetClass.OPTION]

    @property
    def requires_margin(self) -> bool:
    """Check if asset requires margin."""
    return self.asset_class in [AssetClass.FUTURE, AssetClass.FX] or self.leverage_available > 1

    @property
    def has_expiry(self) -> bool:
    """Check if asset has expiry."""
    return self.expiry is not None

    def get_margin_requirement(self, quantity: float, price: Price) -> float:
    """
    Calculate margin requirement for position.

    Args:
    quantity: Position size
    price: Current price

    Returns:
    Required margin
    """
    if self.asset_class == AssetClass.FUTURE:
    # Futures use fixed margin per contract
    return abs(quantity) * self.initial_margin
    if self.asset_class == AssetClass.FX:
    # FX uses percentage of notional
    notional = abs(quantity) * price
    return notional / self.leverage_available if self.leverage_available > 0 else notional
    if self.asset_class == AssetClass.CRYPTO and self.leverage_available > 1:
    # Leveraged crypto trading
    notional = abs(quantity) * price
    return notional / self.leverage_available
    if self.asset_class == AssetClass.OPTION:
    # Options: buyers pay premium, sellers need margin
    if quantity > 0: # Buying options
    return abs(quantity) * price * self.contract_size
    # Selling options - simplified margin
    return abs(quantity) * self.strike * self.contract_size * 0.2 # 20% of notional
    # Spot trading - full cash required
    return abs(quantity) * price

    def get_notional_value(self, quantity: float, price: Price) -> float:
    """
    Calculate notional value of position.

    Args:
    quantity: Position size
    price: Current price

    Returns:
    Notional value
    """
    if self.asset_class in [AssetClass.FUTURE, AssetClass.OPTION]:
    return abs(quantity) * price * self.contract_size
    if self.asset_class == AssetClass.FX:
    # FX notional in base currency
    return abs(quantity) * price
    return abs(quantity) * price

    def calculate_pnl(
    self,
    entry_price: Price,
    exit_price: Price,
    quantity: float,
    include_costs: bool = True,
    ) -> float:
    """
    Calculate P&L for a trade.

    Args:
    entry_price: Entry price (for options: premium per contract, not underlying price)
    exit_price: Exit price (for options: premium per contract, not underlying price)
    quantity: Position size (positive for long, negative for short)
    include_costs: Whether to include trading costs

    Returns:
    Profit/loss

    Note:
    For options, entry_price and exit_price must be the option premiums,
    NOT the underlying asset prices. Use calculate_pnl_premium_based()
    for explicit premium-based calculation.
    """
    if self.asset_class == AssetClass.FUTURE:
    # Futures P&L includes contract multiplier
    pnl = quantity * (exit_price - entry_price) * self.contract_size
    elif self.asset_class == AssetClass.OPTION:
    # Options P&L based on premium change (not intrinsic value)
    # Note: entry_price and exit_price should be option premiums, not underlying prices
    # For positions closed before expiry, P&L = (exit_premium - entry_premium) * quantity * contract_size
    # This calculation assumes entry_price and exit_price are the option premiums
    pnl = quantity * (exit_price - entry_price) * self.contract_size

    # WARNING: If you need P&L at expiry based on intrinsic value, use a separate method
    # The above calculation is correct for trading options before expiry
    elif self.asset_class == AssetClass.FX:
    # FX P&L in quote currency
    pnl = quantity * (exit_price - entry_price)
    # Note: pip_value is typically the value of one pip in the quote currency
    # No division needed - the P&L is already in the correct currency units
    else:
    # Standard P&L calculation
    pnl = quantity * (exit_price - entry_price)

    # Subtract trading costs if requested
    if include_costs:
    entry_cost = abs(quantity * entry_price) * self.taker_fee
    exit_cost = abs(quantity * exit_price) * self.taker_fee
    pnl -= entry_cost + exit_cost

    return pnl

    def calculate_pnl_premium_based(
    self,
    entry_premium: Price,
    exit_premium: Price,
    quantity: float,
    include_costs: bool = True,
    ) -> float:
    """
    Calculate P&L for options using premium change methodology.

    This is the CORRECT way to calculate options P&L for positions
    closed before expiry. It uses the change in option premium,
    not intrinsic value.

    Args:
    entry_premium: Option premium at entry
    exit_premium: Option premium at exit
    quantity: Position size (positive for long, negative for short)
    include_costs: Whether to include trading costs

    Returns:
    Profit/loss based on premium change

    Raises:
    ValueError: If called on non-option assets

    Example:
    # Long 1 call option: bought at $2.00, sold at $1.50
    # P&L = (1.50 - 2.00) * 1 * 100 = -$50
    pnl = call_spec.calculate_pnl_premium_based(2.00, 1.50, 1.0)
    assert pnl == -50.0
    """
    if self.asset_class != AssetClass.OPTION:
    raise ValueError("Premium-based P&L calculation is only for options")

    # CORRECT: P&L = (exit_premium - entry_premium) * quantity * contract_size
    pnl = (exit_premium - entry_premium) * quantity * self.contract_size

    # Subtract trading costs if requested
    if include_costs:
    entry_cost = abs(quantity * entry_premium) * getattr(self, "taker_fee", 0.0)
    exit_cost = abs(quantity * exit_premium) * getattr(self, "taker_fee", 0.0)
    pnl -= entry_cost + exit_cost

    return pnl

    def calculate_option_pnl_at_expiry(
    self,
    entry_premium: Price,
    underlying_price_at_expiry: Price,
    quantity: float,
    option_type: str = "call", # "call" or "put"
    include_costs: bool = True,
    ) -> float:
    """
    Calculate P&L for options held to expiry based on intrinsic value.

    Args:
    entry_premium: Premium paid/received when opening position
    underlying_price_at_expiry: Price of underlying asset at expiry
    quantity: Position size (positive for long, negative for short)
    option_type: "call" or "put"
    include_costs: Whether to include trading costs

    Returns:
    Profit/loss at expiry

    Raises:
    ValueError: If called on non-option assets or invalid option type
    """
    if self.asset_class != AssetClass.OPTION:
    raise ValueError("Expiry P&L calculation is only for options")

    if option_type not in ["call", "put"]:
    raise ValueError("option_type must be 'call' or 'put'")

    if self.strike is None:
    raise ValueError("Option strike price is required for expiry P&L")

    # Calculate intrinsic value at expiry
    if option_type == "call":
    intrinsic_value = max(0, underlying_price_at_expiry - self.strike)
    else: # put
    intrinsic_value = max(0, self.strike - underlying_price_at_expiry)

    # For long positions: P&L = (intrinsic_value - entry_premium) * quantity * contract_size
    # For short positions: P&L = (entry_premium - intrinsic_value) * quantity * contract_size
    if quantity > 0: # Long option
    pnl = (intrinsic_value - entry_premium) * quantity * self.contract_size
    else: # Short option
    pnl = (entry_premium - intrinsic_value) * abs(quantity) * self.contract_size

    # Subtract trading costs if requested (only entry cost for expiry)
    if include_costs:
    entry_cost = abs(quantity * entry_premium) * getattr(self, "taker_fee", 0.0)
    pnl -= entry_cost

    return pnl

    def calculate_pnl_enhanced(
    self,
    entry_price: Price,
    exit_price: Price,
    quantity: float,
    entry_premium: Price = None,
    exit_premium: Price = None,
    include_costs: bool = True,
    ) -> float:
    """
    Enhanced P&L calculation with options premium support.

    For options, this method will use premium-based calculation when
    premium data is provided, otherwise it assumes entry_price and exit_price
    are premiums (NOT underlying prices).

    Args:
    entry_price: Entry price (premium for options if entry_premium not provided)
    exit_price: Exit price (premium for options if exit_premium not provided)
    quantity: Position size
    entry_premium: Option premium at entry (for options only, overrides entry_price)
    exit_premium: Option premium at exit (for options only, overrides exit_price)
    include_costs: Whether to include trading costs

    Returns:
    Profit/loss

    Note:
    For options without explicit premium parameters, entry_price and exit_price
    are treated as premiums, NOT as underlying asset prices.
    """
    if (
    self.asset_class == AssetClass.OPTION
    and entry_premium is not None
    and exit_premium is not None
    ):
    # Use premium-based calculation for options when premium data available
    return self.calculate_pnl_premium_based(
    entry_premium,
    exit_premium,
    quantity,
    include_costs,
    )
    # Use original calculation method
    return self.calculate_pnl(entry_price, exit_price, quantity, include_costs)


    class AssetRegistry:
    """Registry for managing asset specifications."""

    def __init__(self):
    """Initialize asset registry."""
    self._assets: dict[AssetId, AssetSpec] = {}

    def register(self, asset_spec: AssetSpec) -> None:
    """Register an asset specification."""
    self._assets[asset_spec.asset_id] = asset_spec

    def get(self, asset_id: AssetId) -> AssetSpec | None:
    """Get asset specification by ID."""
    return self._assets.get(asset_id)

    def get_or_create_equity(self, asset_id: AssetId) -> AssetSpec:
    """Get or create a default equity specification."""
    if asset_id not in self._assets:
    self._assets[asset_id] = AssetSpec(
    asset_id=asset_id,
    asset_class=AssetClass.EQUITY,
    contract_type=ContractType.SPOT,
    )
    return self._assets[asset_id]

    def create_future(
    self,
    asset_id: AssetId,
    underlying: AssetId,
    expiry: datetime,
    contract_size: float = 1.0,
    initial_margin: float = 0.0,
    maintenance_margin: float = 0.0,
    ) -> AssetSpec:
    """Create a futures contract specification."""
    spec = AssetSpec(
    asset_id=asset_id,
    asset_class=AssetClass.FUTURE,
    contract_type=ContractType.FUTURE,
    underlying=underlying,
    expiry=expiry,
    contract_size=contract_size,
    initial_margin=initial_margin,
    maintenance_margin=maintenance_margin,
    )
    self._assets[asset_id] = spec
    return spec

    def create_option(
    self,
    asset_id: AssetId,
    underlying: AssetId,
    strike: Price,
    expiry: datetime,
    option_type: str,
    contract_size: float = 100.0,
    exercise_style: str = "american",
    ) -> AssetSpec:
    """Create an option contract specification."""
    spec = AssetSpec(
    asset_id=asset_id,
    asset_class=AssetClass.OPTION,
    contract_type=ContractType.CALL if option_type == "call" else ContractType.PUT,
    underlying=underlying,
    strike=strike,
    expiry=expiry,
    option_type=option_type,
    contract_size=contract_size,
    exercise_style=exercise_style,
    )
    self._assets[asset_id] = spec
    return spec

    def create_fx_pair(
    self,
    asset_id: AssetId,
    base_currency: str,
    quote_currency: str,
    pip_value: float = 0.0001,
    leverage_available: float = 100.0,
    ) -> AssetSpec:
    """Create an FX pair specification."""
    spec = AssetSpec(
    asset_id=asset_id,
    asset_class=AssetClass.FX,
    contract_type=ContractType.SPOT,
    base_currency=base_currency,
    quote_currency=quote_currency,
    currency=quote_currency,
    pip_value=pip_value,
    leverage_available=leverage_available,
    tick_size=pip_value,
    lot_size=1000.0, # Mini lot
    )
    self._assets[asset_id] = spec
    return spec

    def create_crypto(
    self,
    asset_id: AssetId,
    base_currency: str,
    quote_currency: str = "USD",
    min_quantity: float = 0.00001,
    maker_fee: float = 0.001,
    taker_fee: float = 0.001,
    leverage_available: float = 1.0,
    ) -> AssetSpec:
    """Create a cryptocurrency specification."""
    spec = AssetSpec(
    asset_id=asset_id,
    asset_class=AssetClass.CRYPTO,
    contract_type=ContractType.SPOT,
    base_currency=base_currency,
    quote_currency=quote_currency,
    currency=quote_currency,
    min_quantity=min_quantity,
    tick_size=0.01,
    lot_size=1.0,
    is_24_7=True,
    network_fees=True,
    maker_fee=maker_fee,
    taker_fee=taker_fee,
    leverage_available=leverage_available,
    )
    self._assets[asset_id] = spec
    return spec
</file>

<file path="src/qengine/core/clock.py">
    """Time management and synchronization for QEngine."""

    import heapq
    import logging
    from datetime import datetime
    from enum import Enum

    import pandas_market_calendars as mcal

    from qengine.core.event import Event
    from qengine.data.feed import DataFeed, SignalSource


    class ClockMode(Enum):
    """Clock operation modes."""

    BACKTEST = "backtest" # Historical simulation
    PAPER = "paper" # Paper trading with real-time data
    LIVE = "live" # Live trading


    class Clock:
    """
    Master time keeper for the simulation.

    The Clock is responsible for:
    - Advancing simulation time
    - Coordinating multiple data sources
    - Ensuring point-in-time correctness
    - Managing trading calendar
    """

    def __init__(
    self,
    mode: ClockMode = ClockMode.BACKTEST,
    calendar: str | None = "NYSE",
    start_time: datetime | None = None,
    end_time: datetime | None = None,
    ):
    """
    Initialize the Clock.

    Args:
    mode: Operating mode (backtest, paper, live)
    calendar: Market calendar name (e.g., 'NYSE', 'NASDAQ')
    start_time: Simulation start time
    end_time: Simulation end time
    """
    self.mode = mode
    self.calendar_name = calendar
    self.start_time = start_time
    self.end_time = end_time
    self.logger = logging.getLogger(__name__)

    # Current simulation time
    self._current_time = start_time

    # Data sources
    self._data_feeds: list[DataFeed] = []
    self._signal_sources: list[SignalSource] = []

    # Event queue (min heap by timestamp)
    # Store tuples of (timestamp, sequence, event, source) for stable ordering
    self._event_queue: list[tuple[datetime, int, Event, object]] = []
    self._sequence_counter = 0 # Ensures FIFO when timestamps are identical

    # Market calendar
    if calendar:
    self.calendar = mcal.get_calendar(calendar)
    if start_time and end_time:
    self.trading_sessions = self.calendar.schedule(
    start_date=start_time.date(),
    end_date=end_time.date(),
    )
    else:
    self.trading_sessions = None
    else:
    self.calendar = None
    self.trading_sessions = None

    # Statistics
    self._events_processed = 0
    self._ticks_processed = 0

    def add_data_feed(self, feed: DataFeed) -> None:
    """
    Add a data feed to the clock.

    Args:
    feed: Data feed to add
    """
    self._data_feeds.append(feed)
    self._prime_feed(feed)

    def add_signal_source(self, source: SignalSource) -> None:
    """
    Add a signal source to the clock.

    Args:
    source: Signal source to add
    """
    self._signal_sources.append(source)
    self._prime_signal_source(source)

    def _prime_feed(self, feed: DataFeed) -> None:
    """
    Prime a data feed by adding its first event to the queue.

    Args:
    feed: Data feed to prime
    """
    next_event = feed.get_next_event()
    if next_event:
    # Store tuple of (timestamp, sequence, event, source) for stable ordering
    heapq.heappush(
    self._event_queue, (next_event.timestamp, self._sequence_counter, next_event, feed)
    )
    self._sequence_counter += 1

    def _prime_signal_source(self, source: SignalSource) -> None:
    """
    Prime a signal source.

    Args:
    source: Signal source to prime
    """
    next_signal = source.get_next_signal()
    if next_signal:
    # Store tuple of (timestamp, sequence, event, source) for stable ordering
    heapq.heappush(
    self._event_queue,
    (next_signal.timestamp, self._sequence_counter, next_signal, source),
    )
    self._sequence_counter += 1

    def get_next_event(self) -> Event | None:
    """
    Get the next event across all data sources.

    Returns:
    Next event in chronological order or None
    """
    if not self._event_queue:
    return None

    # Get event with earliest timestamp and its source
    # Now unpacking 4 elements: timestamp, sequence, event, source
    timestamp, sequence, event, source = heapq.heappop(self._event_queue)

    # Update current time (ensures PIT correctness)
    self._current_time = timestamp

    # Check if we're past end time
    if self.end_time and timestamp > self.end_time:
    return None

    # Replenish queue from the source that provided this event
    self._replenish_queue(event, source)

    self._events_processed += 1

    return event

    def _replenish_queue(self, last_event: Event, source) -> None:
    """
    Add the next event from the source that provided the last event.

    For correct multi-feed synchronization, only the feed that just provided
    an event needs to be replenished. The heap maintains chronological order
    across all feeds.

    Args:
    last_event: The event that was just processed
    source: The data feed or signal source that provided the last event
    """
    from qengine.data.feed import DataFeed, SignalSource

    # Only replenish from the source that provided the last event
    # The heap ensures proper chronological ordering across all feeds
    if isinstance(source, DataFeed):
    if not source.is_exhausted:
    next_timestamp = source.peek_next_timestamp()
    if next_timestamp and (not self.end_time or next_timestamp<= self.end_time):
    next_event = source.get_next_event()
    if next_event:
    heapq.heappush(
    self._event_queue,
    (next_event.timestamp, self._sequence_counter, next_event, source),
    )
    self._sequence_counter += 1
    elif isinstance(source, SignalSource):
    next_timestamp = source.peek_next_timestamp()
    if next_timestamp and (not self.end_time or next_timestamp<= self.end_time):
    next_signal = source.get_next_signal()
    if next_signal:
    heapq.heappush(
    self._event_queue,
    (next_signal.timestamp, self._sequence_counter, next_signal, source),
    )
    self._sequence_counter += 1

    @property
    def current_time(self) -> datetime | None:
    """Get the current simulation time."""
    return self._current_time

    @property
    def is_market_open(self) -> bool:
    """
    Check if the market is currently open.

    Returns:
    True if market is open at current time
    """
    if not self.calendar or not self._current_time:
    return True # Assume always open if no calendar

    # Check if current time is within a trading session
    current_date = self._current_time.date()
    if current_date in self.trading_sessions.index:
    session = self.trading_sessions.loc[current_date]
    market_open = session["market_open"]
    market_close = session["market_close"]

    # Convert to timezone-aware if needed
    if self._current_time.tzinfo:
    return market_open<= self._current_time<= market_close
    return (
    market_open.replace(tzinfo=None)
    <= self._current_time
    <= market_close.replace(tzinfo=None)
    )

    return False

    @property
    def next_market_open(self) -> datetime | None:
    """
    Get the next market open time.

    Returns:
    Next market open datetime or None
    """
    if not self.calendar or not self._current_time:
    return None

    current_date = self._current_time.date()
    future_sessions = self.trading_sessions[self.trading_sessions.index >= current_date]

    for _date, session in future_sessions.iterrows():
    market_open = session["market_open"]
    if market_open > self._current_time:
    return market_open

    return None

    @property
    def next_market_close(self) -> datetime | None:
    """
    Get the next market close time.

    Returns:
    Next market close datetime or None
    """
    if not self.calendar or not self._current_time:
    return None

    current_date = self._current_time.date()
    if current_date in self.trading_sessions.index:
    market_close = self.trading_sessions.loc[current_date]["market_close"]
    if market_close > self._current_time:
    return market_close

    # Look for next session
    future_sessions = self.trading_sessions[self.trading_sessions.index > current_date]
    if not future_sessions.empty:
    return future_sessions.iloc[0]["market_close"]

    return None

    def is_trading_day(self, date: datetime) -> bool:
    """
    Check if a given date is a trading day.

    Args:
    date: Date to check

    Returns:
    True if date is a trading day
    """
    if not self.trading_sessions:
    return True

    return date.date() in self.trading_sessions.index

    def advance_to(self, timestamp: datetime, skip_events: bool = False) -> int:
    """
    Advance the clock to a specific time.

    Used for jumping forward in time during backtesting.

    Args:
    timestamp: Target timestamp
    skip_events: If False (default), raise error if events would be skipped

    Returns:
    Number of events skipped

    Raises:
    ValueError: If skip_events=False and events would be skipped, or if trying to go back in time
    RuntimeError: If not in backtest mode
    """
    if self.mode != ClockMode.BACKTEST:
    raise RuntimeError("Can only advance time in backtest mode")

    if self._current_time is not None and timestamp< self._current_time:
                                                     raise ValueError("Cannot go back in time")

    # Count events that would be skipped
    skipped_count = 0
    while self._event_queue and self._event_queue[0][0]
    < timestamp:
      skipped_count
    += 1
    if not skip_events:
    raise ValueError(
    f"Would skip {skipped_count} event(s) before {timestamp}. "
    f"Set skip_events=True to allow."
    )
    heapq.heappop(self._event_queue)

    self._current_time = timestamp

    if skipped_count > 0:
    self.logger.warning(f"Clock advanced to {timestamp}, skipped {skipped_count} events")

    return skipped_count

    def reset(self) -> None:
    """Reset the clock to initial state."""
    self._current_time = self.start_time
    self._event_queue.clear()
    self._events_processed = 0
    self._ticks_processed = 0

    # Reset all data feeds
    for feed in self._data_feeds:
    feed.reset()
    self._prime_feed(feed)

    # Reset all signal sources
    for source in self._signal_sources:
    source.reset()
    self._prime_signal_source(source)

    @property
    def stats(self) -> dict:
    """Get clock statistics."""
    return {
    "current_time": self._current_time,
    "events_processed": self._events_processed,
    "queue_size": len(self._event_queue),
    "data_feeds": len(self._data_feeds),
    "signal_sources": len(self._signal_sources),
    "mode": self.mode.value,
    }

    def __repr__(self) -> str:
    return (
    f"Clock(mode={self.mode.value}, "
    f"time={self._current_time}, "
    f"events={self._events_processed})"
    )
</file>

<file path="src/qengine/core/constants.py">
    """Configuration constants for QEngine.

    This module contains all magic numbers and configuration defaults used throughout
    the backtesting engine. Centralizing these values improves maintainability and
    makes it easier to adjust behavior without modifying core logic.
    """

    # =============================================================================
    # Capital and Portfolio Defaults
    # =============================================================================

    DEFAULT_INITIAL_CAPITAL = 100_000.0
    """Default starting capital for backtests (USD)."""

    DEFAULT_CURRENCY = "USD"
    """Default currency for portfolio accounting."""

    # =============================================================================
    # Event Processing
    # =============================================================================

    PROGRESS_LOG_INTERVAL = 10_000
    """Log progress message every N events during backtesting."""

    # =============================================================================
    # Order Execution
    # =============================================================================

    MIN_FILL_SIZE = 0.01
    """Minimum meaningful fill quantity (shares/contracts)."""

    MAX_COMMISSION_CALC_ITERATIONS = 10
    """Maximum iterations for binary search in commission calculations."""

    # =============================================================================
    # Commission Defaults (basis points, where 1 bp = 0.01%)
    # =============================================================================

    DEFAULT_COMMISSION_RATE_BPS = 10
    """Default commission rate: 10 basis points = 0.1% = $0.001 per dollar."""

    DEFAULT_TAKER_FEE_BPS = 10
    """Default taker fee for maker-taker exchanges: 10 bps = 0.1%."""

    # =============================================================================
    # Slippage Defaults (basis points)
    # =============================================================================

    SLIPPAGE_EQUITY_BPS = 1
    """Default slippage for equities: 1 basis point = 0.01%."""

    SLIPPAGE_FUTURES_BPS = 2
    """Default slippage for futures: 2 basis points = 0.02%."""

    SLIPPAGE_FX_BPS = 0.5
    """Default slippage for FX: 0.5 basis points = 0.005%."""

    SLIPPAGE_CRYPTO_BPS = 10
    """Default slippage for cryptocurrencies: 10 basis points = 0.1%."""

    # =============================================================================
    # Helper Functions
    # =============================================================================


    def bps_to_decimal(bps: float) -> float:
    """Convert basis points to decimal representation.

    Args:
    bps: Value in basis points (e.g., 10 for 0.1%)

    Returns:
    Decimal representation (e.g., 0.001 for 10 bps)

    Examples:
    >>> bps_to_decimal(1)
    0.0001
    >>> bps_to_decimal(10)
    0.001
    >>> bps_to_decimal(100)
    0.01
    """
    return bps / 10_000


    def decimal_to_bps(decimal: float) -> float:
    """Convert decimal to basis points.

    Args:
    decimal: Decimal value (e.g., 0.001 for 10 bps)

    Returns:
    Basis points (e.g., 10 for 0.001)

    Examples:
    >>> decimal_to_bps(0.0001)
    1.0
    >>> decimal_to_bps(0.001)
    10.0
    >>> decimal_to_bps(0.01)
    100.0
    """
    return decimal * 10_000
</file>

<file path="src/qengine/core/event.py">
    """Event system for QEngine."""

    import heapq
    import logging
    import threading
    from abc import ABC
    from collections import deque
    from collections.abc import Callable
    from datetime import datetime
    from typing import Any

    from qengine.core.types import (
    AssetId,
    EventType,
    MarketDataType,
    OrderId,
    OrderSide,
    OrderType,
    Price,
    Quantity,
    TimeInForce,
    Volume,
    )

    logger = logging.getLogger(__name__)


    class Event(ABC):
    """Base class for all events in the system."""

    def __init__(
    self,
    timestamp: datetime,
    event_type: EventType,
    metadata: dict[str, Any] | None = None,
    ):
    self.timestamp = timestamp
    self.event_type = event_type
    self.metadata = metadata or {}

    def __lt__(self, other: "Event") -> bool:
    """Compare events by timestamp for priority queue."""
    return self.timestamp< other.timestamp

                           def __repr__(self) -> str:
    return f"{self.__class__.__name__}(timestamp={self.timestamp})"


    class MarketEvent(Event):
    """Market data event (trade, quote, or bar)."""

    def __init__(
    self,
    timestamp: datetime,
    asset_id: AssetId,
    data_type: MarketDataType,
    price: Price | None = None,
    size: Quantity | None = None,
    bid_price: Price | None = None,
    ask_price: Price | None = None,
    bid_size: Quantity | None = None,
    ask_size: Quantity | None = None,
    open: Price | None = None,
    high: Price | None = None,
    low: Price | None = None,
    close: Price | None = None,
    volume: Volume | None = None,
    metadata: dict[str, Any] | None = None,
    ):
    super().__init__(timestamp, EventType.MARKET, metadata)
    self.asset_id = asset_id
    self.data_type = data_type
    self.price = price
    self.size = size
    self.bid_price = bid_price
    self.ask_price = ask_price
    self.bid_size = bid_size
    self.ask_size = ask_size
    self.open = open
    self.high = high
    self.low = low
    self.close = close
    self.volume = volume


    class SignalEvent(Event):
    """ML model signal event."""

    def __init__(
    self,
    timestamp: datetime,
    asset_id: AssetId,
    signal_value: float,
    model_id: str,
    confidence: float | None = None,
    features: dict[str, Any] | None = None,
    ts_event: datetime | None = None,
    ts_arrival: datetime | None = None,
    metadata: dict[str, Any] | None = None,
    ):
    super().__init__(timestamp, EventType.SIGNAL, metadata)
    self.asset_id = asset_id
    self.signal_value = signal_value
    self.model_id = model_id
    self.confidence = confidence
    self.features = features or {}
    self.ts_event = ts_event
    self.ts_arrival = ts_arrival or timestamp


    class OrderEvent(Event):
    """Order submission event."""

    def __init__(
    self,
    timestamp: datetime,
    order_id: OrderId,
    asset_id: AssetId,
    order_type: OrderType,
    side: OrderSide,
    quantity: Quantity,
    limit_price: Price | None = None,
    stop_price: Price | None = None,
    time_in_force: TimeInForce = TimeInForce.DAY,
    parent_order_id: OrderId | None = None,
    metadata: dict[str, Any] | None = None,
    ):
    super().__init__(timestamp, EventType.ORDER, metadata)
    self.order_id = order_id
    self.asset_id = asset_id
    self.order_type = order_type
    self.side = side
    self.quantity = quantity
    self.limit_price = limit_price
    self.stop_price = stop_price
    self.time_in_force = time_in_force
    self.parent_order_id = parent_order_id


    class FillEvent(Event):
    """Order fill/execution event."""

    def __init__(
    self,
    timestamp: datetime,
    order_id: OrderId,
    trade_id: str,
    asset_id: AssetId,
    side: OrderSide,
    fill_quantity: Quantity,
    fill_price: Price,
    commission: float = 0.0,
    slippage: float = 0.0,
    market_impact: float = 0.0,
    metadata: dict[str, Any] | None = None,
    ):
    super().__init__(timestamp, EventType.FILL, metadata)
    self.order_id = order_id
    self.trade_id = trade_id
    self.asset_id = asset_id
    self.side = side
    self.fill_quantity = fill_quantity
    self.fill_price = fill_price
    self.commission = commission
    self.slippage = slippage
    self.market_impact = market_impact

    @property
    def total_cost(self) -> float:
    """Total transaction cost including all fees."""
    return self.commission + self.slippage + self.market_impact


    class CorporateActionEvent(Event):
    """Corporate action event (split, dividend, etc)."""

    def __init__(
    self,
    timestamp: datetime,
    asset_id: AssetId,
    action_type: str,
    ex_date: datetime,
    record_date: datetime | None = None,
    payment_date: datetime | None = None,
    adjustment_factor: float | None = None,
    dividend_amount: float | None = None,
    metadata: dict[str, Any] | None = None,
    ):
    super().__init__(timestamp, EventType.CORPORATE_ACTION, metadata)
    self.asset_id = asset_id
    self.action_type = action_type
    self.ex_date = ex_date
    self.record_date = record_date
    self.payment_date = payment_date
    self.adjustment_factor = adjustment_factor
    self.dividend_amount = dividend_amount


    class EventBus:
    """Central event distribution system."""

    def __init__(self, use_priority_queue: bool = True):
    """
    Initialize the event bus.

    Args:
    use_priority_queue: If True, events are processed by timestamp priority
    """
    self.use_priority_queue = use_priority_queue

    if use_priority_queue:
    self._queue: list[Event] = [] # Will use heapq
    else:
    self._queue: deque = deque()

    self._subscribers: dict[EventType, list[Callable]] = {}
    self._running = False
    self._lock = threading.Lock()

    def subscribe(self, event_type: EventType, handler: Callable[[Event], None]) -> None:
    """
    Subscribe to events of a specific type.

    Args:
    event_type: Type of events to subscribe to
    handler: Callback function to handle events
    """
    with self._lock:
    if event_type not in self._subscribers:
    self._subscribers[event_type] = []
    if handler not in self._subscribers[event_type]:
    self._subscribers[event_type].append(handler)

    def unsubscribe(self, event_type: EventType, handler: Callable[[Event], None]) -> None:
    """
    Unsubscribe from events.

    Args:
    event_type: Type of events to unsubscribe from
    handler: Handler to remove
    """
    with self._lock:
    if event_type in self._subscribers:
    if handler in self._subscribers[event_type]:
    self._subscribers[event_type].remove(handler)

    def publish(self, event: Event) -> None:
    """
    Publish an event to the queue.

    Args:
    event: Event to publish
    """
    with self._lock:
    if self.use_priority_queue:
    heapq.heappush(self._queue, event)
    else:
    self._queue.append(event)

    def process_next(self) -> Event | None:
    """
    Process the next event in the queue.

    Returns:
    The processed event or None if queue is empty
    """
    with self._lock:
    if not self._queue:
    return None

    event = heapq.heappop(self._queue) if self.use_priority_queue else self._queue.popleft()

    # Notify subscribers (outside of lock to prevent deadlock)
    self._notify_subscribers(event)
    return event

    def process_all(self, max_events: int | None = None) -> int:
    """
    Process all pending events.

    Args:
    max_events: Maximum number of events to process

    Returns:
    Number of events processed
    """
    count = 0
    while self._queue and (max_events is None or count< max_events):
    if self.process_next() is not None:
    count += 1
    else:
    break
    return count

    def peek(self) -> Event | None:
    """
    Peek at the next event without removing it.

    Returns:
    Next event or None if queue is empty
    """
    with self._lock:
    return self._queue[0] if self._queue else None

    def clear(self) -> None:
    """Clear all pending events."""
    with self._lock:
    self._queue.clear()

    @property
    def pending_count(self) -> int:
    """Number of pending events in the queue."""
    with self._lock:
    return len(self._queue)

    def _notify_subscribers(self, event: Event) -> None:
    """
    Notify all subscribers of an event.

    Args:
    event: Event to send to subscribers
    """
    handlers = []
    with self._lock:
    if event.event_type in self._subscribers:
    handlers = self._subscribers[event.event_type].copy()

    for handler in handlers:
    try:
    handler(event)
    except Exception as e:
    logger.error(f"Error in event handler: {e}", exc_info=True)
</file>

<file path="src/qengine/core/types.py">
    """Core type definitions for QEngine."""

    from datetime import datetime
    from decimal import Decimal
    from enum import Enum
    from typing import NewType, Union

    # Time types
    Timestamp = NewType("Timestamp", datetime)
    Nanoseconds = NewType("Nanoseconds", int)

    # Market data types
    AssetId = NewType("AssetId", str)
    Price = Union[float, Decimal]
    Quantity = Union[float, int]
    Volume = Union[float, int]

    # Order types
    OrderId = NewType("OrderId", str)
    TradeId = NewType("TradeId", str)
    PositionId = NewType("PositionId", str)

    # Portfolio types
    Cash = Union[float, Decimal]
    Currency = NewType("Currency", str)


    class EventType(Enum):
    """Types of events in the system."""

    MARKET = "market"
    SIGNAL = "signal"
    ORDER = "order"
    FILL = "fill"
    CORPORATE_ACTION = "corporate_action"
    TIMER = "timer"
    CUSTOM = "custom"


    class OrderType(Enum):
    """Types of orders."""

    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"
    TRAILING_STOP = "trailing_stop"
    BRACKET = "bracket"
    OCO = "oco"


    class OrderStatus(Enum):
    """Order status lifecycle."""

    CREATED = "created"
    SUBMITTED = "submitted"
    ACCEPTED = "accepted"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    CANCELED = "canceled"
    REJECTED = "rejected"
    EXPIRED = "expired"


    class OrderSide(Enum):
    """Order side (buy/sell)."""

    BUY = "buy"
    SELL = "sell"
    SHORT = "short"
    COVER = "cover"


    class TimeInForce(Enum):
    """Time-in-force constraints for orders."""

    DAY = "day" # Valid for the day
    GTC = "gtc" # Good till canceled
    IOC = "ioc" # Immediate or cancel
    FOK = "fok" # Fill or kill
    GTD = "gtd" # Good till date
    MOC = "moc" # Market on close
    MOO = "moo" # Market on open


    class AssetType(Enum):
    """Types of tradeable assets."""

    EQUITY = "equity"
    FUTURE = "future"
    OPTION = "option"
    FOREX = "forex"
    CRYPTO = "crypto"
    BOND = "bond"
    COMMODITY = "commodity"
    INDEX = "index"


    class BarType(Enum):
    """Types of price bars."""

    TICK = "tick"
    TIME = "time"
    VOLUME = "volume"
    DOLLAR = "dollar"
    TICK_IMBALANCE = "tick_imbalance"
    VOLUME_IMBALANCE = "volume_imbalance"


    class MarketDataType(Enum):
    """Types of market data."""

    TRADE = "trade"
    QUOTE = "quote"
    BAR = "bar"
    ORDERBOOK = "orderbook"
</file>

<file path="src/qengine/data/__init__.py">
    """Data management for QEngine."""

    from qengine.data.feed import DataFeed, SignalSource
    from qengine.data.schemas import MarketDataSchema, SignalSchema

    __all__ = [
    "DataFeed",
    "MarketDataSchema",
    "SignalSchema",
    "SignalSource",
    ]
</file>

<file path="src/qengine/data/asset_registry.py">
    """Asset registry for managing asset specifications.

    Minimal implementation to unblock qengine imports.
    """

    from dataclasses import dataclass
    from typing import Dict, Optional


    @dataclass
    class AssetSpec:
    """Specification for a tradeable asset."""

    asset_id: str
    asset_type: str # 'stock', 'future', 'crypto', etc.
    tick_size: float = 0.01
    lot_size: int = 1
    multiplier: float = 1.0
    margin_requirement: float = 1.0 # 1.0 = 100% (no leverage)

    # Trading hours (TODO: integrate with market calendars)
    tradeable_hours: Optional[tuple[int, int]] = None # (start_hour, end_hour)


    class AssetRegistry:
    """Registry of asset specifications."""

    def __init__(self):
    self._assets: Dict[str, AssetSpec] = {}

    # Default specifications for common asset types
    self._register_defaults()

    def _register_defaults(self):
    """Register default specifications for common assets."""
    # Default crypto spec
    self.register(AssetSpec(
    asset_id="BTC",
    asset_type="crypto",
    tick_size=0.01,
    lot_size=1,
    multiplier=1.0,
    margin_requirement=1.0
    ))

    # Default stock spec
    self.register(AssetSpec(
    asset_id="DEFAULT_STOCK",
    asset_type="stock",
    tick_size=0.01,
    lot_size=1,
    multiplier=1.0,
    margin_requirement=1.0
    ))

    def register(self, spec: AssetSpec) -> None:
    """Register an asset specification.

    Args:
    spec: Asset specification to register
    """
    self._assets[spec.asset_id] = spec

    def get(self, asset_id: str) -> AssetSpec:
    """Get asset specification by ID.

    Args:
    asset_id: Asset identifier

    Returns:
    Asset specification

    Raises:
    KeyError: If asset not found
    """
    if asset_id not in self._assets:
    # Return default spec for unknown assets
    return AssetSpec(
    asset_id=asset_id,
    asset_type="unknown",
    tick_size=0.01,
    lot_size=1,
    multiplier=1.0,
    margin_requirement=1.0
    )
    return self._assets[asset_id]

    def list_assets(self) -> list[str]:
    """List all registered asset IDs.

    Returns:
    List of asset IDs
    """
    return list(self._assets.keys())
</file>

<file path="src/qengine/data/feed.py">
    """Data feed interfaces and implementations for QEngine."""

    from abc import ABC, abstractmethod
    from datetime import datetime
    from pathlib import Path
    from typing import Any

    import polars as pl

    from qengine.core.event import Event, MarketEvent, SignalEvent
    from qengine.core.types import AssetId, MarketDataType


    class DataFeed(ABC):
    """Abstract base class for all data feeds."""

    @abstractmethod
    def get_next_event(self) -> Event | None:
    """
    Get the next event from this data feed.

    Returns:
    Next event or None if no more data
    """

    @abstractmethod
    def peek_next_timestamp(self) -> datetime | None:
    """
    Peek at the timestamp of the next event without consuming it.

    Returns:
    Timestamp of next event or None if no more data
    """

    @abstractmethod
    def reset(self) -> None:
    """Reset the data feed to the beginning."""

    @abstractmethod
    def seek(self, timestamp: datetime) -> None:
    """
    Seek to a specific timestamp.

    Args:
    timestamp: Target timestamp to seek to
    """

    @property
    @abstractmethod
    def is_exhausted(self) -> bool:
    """Check if the data feed has no more events."""


    class SignalSource(ABC):
    """Abstract base class for ML signal sources."""

    @abstractmethod
    def get_next_signal(self) -> SignalEvent | None:
    """
    Get the next signal from this source.

    Returns:
    Next signal event or None if no more signals
    """

    @abstractmethod
    def peek_next_timestamp(self) -> datetime | None:
    """
    Peek at the timestamp of the next signal.

    Returns:
    Timestamp of next signal or None
    """

    @abstractmethod
    def reset(self) -> None:
    """Reset the signal source."""


    class ParquetDataFeed(DataFeed):
    """Data feed that reads from Parquet files using Polars."""

    def __init__(
    self,
    path: Path,
    asset_id: AssetId,
    data_type: MarketDataType = MarketDataType.BAR,
    timestamp_column: str = "timestamp",
    filters: list[tuple] | None = None,
    ):
    """
    Initialize Parquet data feed.

    Args:
    path: Path to Parquet file
    asset_id: Asset identifier
    data_type: Type of market data
    timestamp_column: Name of timestamp column
    filters: Optional Polars filters to apply
    """
    self.path = Path(path)
    self.asset_id = asset_id
    self.data_type = data_type
    self.timestamp_column = timestamp_column

    # Load data lazily with Polars
    self.lazy_df = pl.scan_parquet(str(self.path))

    # Apply filters if provided
    if filters:
    for filter_expr in filters:
    self.lazy_df = self.lazy_df.filter(filter_expr)

    # Sort by timestamp and collect
    self.df = self.lazy_df.sort(timestamp_column).collect()

    self.current_index = 0
    self.max_index = len(self.df) - 1

    def get_next_event(self) -> MarketEvent | None:
    """Get the next market event."""
    if self.is_exhausted:
    return None

    row = self.df.row(self.current_index, named=True)
    self.current_index += 1

    # Create MarketEvent based on data type
    event = self._create_market_event(row)
    return event

    def _create_market_event(self, row: dict[str, Any]) -> MarketEvent:
    """Create a MarketEvent from a data row."""
    timestamp = row[self.timestamp_column]

    # Convert timestamp if needed
    if not isinstance(timestamp, datetime):
    timestamp = datetime.fromisoformat(str(timestamp))

    # Map column names to MarketEvent fields
    return MarketEvent(
    timestamp=timestamp,
    asset_id=self.asset_id,
    data_type=self.data_type,
    open=row.get("open"),
    high=row.get("high"),
    low=row.get("low"),
    close=row.get("close"),
    volume=row.get("volume"),
    price=row.get("price", row.get("close")),
    size=row.get("size"),
    bid_price=row.get("bid"),
    ask_price=row.get("ask"),
    bid_size=row.get("bid_size"),
    ask_size=row.get("ask_size"),
    )

    def peek_next_timestamp(self) -> datetime | None:
    """Peek at the next timestamp."""
    if self.is_exhausted:
    return None

    timestamp = self.df[self.timestamp_column][self.current_index]
    if not isinstance(timestamp, datetime):
    timestamp = datetime.fromisoformat(str(timestamp))

    return timestamp

    def reset(self) -> None:
    """Reset to the beginning."""
    self.current_index = 0

    def seek(self, timestamp: datetime) -> None:
    """Seek to a specific timestamp."""
    # Find the index of the first row >= timestamp
    mask = self.df[self.timestamp_column] >= timestamp
    indices = mask.arg_true()

    if len(indices) > 0:
    self.current_index = indices[0]
    else:
    self.current_index = self.max_index + 1

    @property
    def is_exhausted(self) -> bool:
    """Check if all data has been consumed."""
    return self.current_index > self.max_index


    class CSVDataFeed(DataFeed):
    """Data feed that reads from CSV files."""

    def __init__(
    self,
    path: Path,
    asset_id: AssetId,
    data_type: MarketDataType = MarketDataType.BAR,
    timestamp_column: str = "timestamp",
    parse_dates: bool = True,
    **csv_kwargs,
    ):
    """
    Initialize CSV data feed.

    Args:
    path: Path to CSV file
    asset_id: Asset identifier
    data_type: Type of market data
    timestamp_column: Name of timestamp column
    parse_dates: Whether to parse dates automatically
    **csv_kwargs: Additional arguments for Polars read_csv
    """
    self.path = Path(path)
    self.asset_id = asset_id
    self.data_type = data_type
    self.timestamp_column = timestamp_column

    # Read CSV with Polars
    if parse_dates:
    csv_kwargs["try_parse_dates"] = True

    self.df = pl.read_csv(str(self.path), **csv_kwargs).sort(timestamp_column)

    self.current_index = 0
    self.max_index = len(self.df) - 1

    def get_next_event(self) -> MarketEvent | None:
    """Get the next market event."""
    if self.is_exhausted:
    return None

    row = self.df.row(self.current_index, named=True)
    self.current_index += 1

    return self._create_market_event(row)

    def _create_market_event(self, row: dict[str, Any]) -> MarketEvent:
    """Create a MarketEvent from a data row."""
    timestamp = row[self.timestamp_column]

    if not isinstance(timestamp, datetime):
    timestamp = datetime.fromisoformat(str(timestamp))

    return MarketEvent(
    timestamp=timestamp,
    asset_id=self.asset_id,
    data_type=self.data_type,
    open=row.get("open"),
    high=row.get("high"),
    low=row.get("low"),
    close=row.get("close"),
    volume=row.get("volume"),
    price=row.get("price", row.get("close")),
    )

    def peek_next_timestamp(self) -> datetime | None:
    """Peek at the next timestamp."""
    if self.is_exhausted:
    return None

    timestamp = self.df[self.timestamp_column][self.current_index]
    if not isinstance(timestamp, datetime):
    timestamp = datetime.fromisoformat(str(timestamp))

    return timestamp

    def reset(self) -> None:
    """Reset to the beginning."""
    self.current_index = 0

    def seek(self, timestamp: datetime) -> None:
    """Seek to a specific timestamp."""
    mask = self.df[self.timestamp_column] >= timestamp
    indices = mask.arg_true()

    if len(indices) > 0:
    self.current_index = indices[0]
    else:
    self.current_index = self.max_index + 1

    @property
    def is_exhausted(self) -> bool:
    """Check if all data has been consumed."""
    return self.current_index > self.max_index


    class ParquetSignalSource(SignalSource):
    """Signal source that reads ML signals from Parquet files."""

    def __init__(
    self,
    path: Path,
    model_id: str,
    timestamp_column: str = "timestamp",
    asset_column: str = "asset_id",
    signal_column: str = "signal",
    confidence_column: str | None = "confidence",
    ts_event_column: str | None = "ts_event",
    ts_arrival_column: str | None = "ts_arrival",
    ):
    """
    Initialize Parquet signal source.

    Args:
    path: Path to Parquet file with signals
    model_id: Identifier for the ML model
    timestamp_column: Column with signal timestamp
    asset_column: Column with asset identifiers
    signal_column: Column with signal values
    confidence_column: Optional column with confidence scores
    ts_event_column: Optional column with event generation time
    ts_arrival_column: Optional column with signal arrival time
    """
    self.path = Path(path)
    self.model_id = model_id
    self.timestamp_column = timestamp_column
    self.asset_column = asset_column
    self.signal_column = signal_column
    self.confidence_column = confidence_column
    self.ts_event_column = ts_event_column
    self.ts_arrival_column = ts_arrival_column

    # Load signals with Polars
    self.df = pl.scan_parquet(str(self.path)).sort(timestamp_column).collect()

    self.current_index = 0
    self.max_index = len(self.df) - 1

    def get_next_signal(self) -> SignalEvent | None:
    """Get the next signal event."""
    if self.current_index > self.max_index:
    return None

    row = self.df.row(self.current_index, named=True)
    self.current_index += 1

    timestamp = row[self.timestamp_column]
    if not isinstance(timestamp, datetime):
    timestamp = datetime.fromisoformat(str(timestamp))

    return SignalEvent(
    timestamp=timestamp,
    asset_id=AssetId(row[self.asset_column]),
    signal_value=float(row[self.signal_column]),
    model_id=self.model_id,
    confidence=float(row[self.confidence_column])
    if self.confidence_column and self.confidence_column in row
    else None,
    ts_event=row.get(self.ts_event_column) if self.ts_event_column else None,
    ts_arrival=row.get(self.ts_arrival_column) if self.ts_arrival_column else timestamp,
    )

    def peek_next_timestamp(self) -> datetime | None:
    """Peek at the next signal timestamp."""
    if self.current_index > self.max_index:
    return None

    timestamp = self.df[self.timestamp_column][self.current_index]
    if not isinstance(timestamp, datetime):
    timestamp = datetime.fromisoformat(str(timestamp))

    return timestamp

    def reset(self) -> None:
    """Reset to the beginning."""
    self.current_index = 0
</file>

<file path="src/qengine/data/schemas.py">
    """Data schemas for QEngine."""

    from dataclasses import dataclass

    import polars as pl


    @dataclass
    class MarketDataSchema:
    """Schema definition for market data."""

    timestamp_col: str = "timestamp"
    open_col: str = "open"
    high_col: str = "high"
    low_col: str = "low"
    close_col: str = "close"
    volume_col: str = "volume"

    def get_dtypes(self) -> dict[str, pl.DataType]:
    """Get Polars data types for the schema."""
    return {
    self.timestamp_col: pl.Datetime("ns"),
    self.open_col: pl.Float64,
    self.high_col: pl.Float64,
    self.low_col: pl.Float64,
    self.close_col: pl.Float64,
    self.volume_col: pl.Int64,
    }

    def validate(self, df: pl.DataFrame) -> None:
    """Validate a DataFrame against this schema."""
    required_cols = [
    self.timestamp_col,
    self.open_col,
    self.high_col,
    self.low_col,
    self.close_col,
    self.volume_col,
    ]

    missing_cols = set(required_cols) - set(df.columns)
    if missing_cols:
    raise ValueError(f"Missing required columns: {missing_cols}")

    # Validate data types
    for col, expected_dtype in self.get_dtypes().items():
    if col in df.columns:
    actual_dtype = df[col].dtype
    if not self._compatible_dtypes(actual_dtype, expected_dtype):
    raise TypeError(
    f"Column {col} has type {actual_dtype}, expected {expected_dtype}",
    )

    def _compatible_dtypes(self, actual: pl.DataType, expected: pl.DataType) -> bool:
    """Check if data types are compatible."""
    # Allow int to float conversion
    if expected == pl.Float64 and actual in [pl.Int32, pl.Int64]:
    return True
    # Allow different datetime precisions
    if isinstance(expected, pl.Datetime) and isinstance(actual, pl.Datetime):
    return True
    return actual == expected


    @dataclass
    class SignalSchema:
    """Schema definition for ML signals."""

    timestamp_col: str = "timestamp"
    asset_id_col: str = "asset_id"
    signal_col: str = "signal"
    confidence_col: str | None = "confidence"
    model_id_col: str | None = "model_id"

    def get_dtypes(self) -> dict[str, pl.DataType]:
    """Get Polars data types for the schema."""
    dtypes = {
    self.timestamp_col: pl.Datetime("ns"),
    self.asset_id_col: pl.Utf8,
    self.signal_col: pl.Float64,
    }

    if self.confidence_col:
    dtypes[self.confidence_col] = pl.Float64
    if self.model_id_col:
    dtypes[self.model_id_col] = pl.Utf8

    return dtypes

    def validate(self, df: pl.DataFrame) -> None:
    """Validate a DataFrame against this schema."""
    required_cols = [
    self.timestamp_col,
    self.asset_id_col,
    self.signal_col,
    ]

    missing_cols = set(required_cols) - set(df.columns)
    if missing_cols:
    raise ValueError(f"Missing required columns: {missing_cols}")

    # Validate data types
    for col, expected_dtype in self.get_dtypes().items():
    if col in df.columns:
    actual_dtype = df[col].dtype
    if not self._compatible_dtypes(actual_dtype, expected_dtype):
    raise TypeError(
    f"Column {col} has type {actual_dtype}, expected {expected_dtype}",
    )

    def _compatible_dtypes(self, actual: pl.DataType, expected: pl.DataType) -> bool:
    """Check if data types are compatible."""
    # Allow int to float conversion
    if expected == pl.Float64 and actual in [pl.Int32, pl.Int64]:
    return True
    # Allow different datetime precisions
    if isinstance(expected, pl.Datetime) and isinstance(actual, pl.Datetime):
    return True
    return actual == expected
</file>

<file path="src/qengine/execution/__init__.py">
    """Execution module for QEngine."""

    from qengine.execution.bracket_manager import BracketOrderManager
    from qengine.execution.broker import Broker, SimulationBroker
    from qengine.execution.fill_simulator import FillResult, FillSimulator
    from qengine.execution.order import Order, OrderState
    from qengine.execution.order_router import OrderRouter
    from qengine.execution.position_tracker import PositionTracker

    __all__ = [
    "Broker",
    "BracketOrderManager",
    "FillResult",
    "FillSimulator",
    "Order",
    "OrderRouter",
    "OrderState",
    "PositionTracker",
    "SimulationBroker",
    ]
</file>

<file path="src/qengine/execution/bracket_manager.py">
    """Bracket and OCO order management for broker simulation.

    This module provides bracket order lifecycle management extracted from
    SimulationBroker to follow the Single Responsibility Principle.

    ## VectorBT Compatibility - Base Price Calculation

    **CRITICAL**: VectorBT calculates TP/SL/TSL levels from BASE PRICE (close before slippage),
    NOT from fill_price (execution price after slippage). This matches real-world behavior
    where stop levels are set relative to the market price, not the slippage-affected fill.

    **Example** (from empirical testing - TASK-005):
    ```
    Close at entry: $43,885.00  BASE PRICE
    Entry slippage: +0.02%
    Entry price: $43,893.78 (= $43,885 * 1.0002)

    TP = 2.5%:
    TP level: $44,982.12 (= $43,885 * 1.025)  Based on CLOSE, not entry_price
    Exit slippage: -0.02%
    TP exit price: $44,973.13 (= $44,982.12 * 0.9998)
    ```

    **Implementation**:
    When creating BRACKET orders, store the base price in order metadata:
    ```python
    order = Order(
    ...,
    order_type=OrderType.BRACKET,
    tp_pct=0.025, # 2.5% TP
    metadata={"base_price": market_event.close}, #  CRITICAL for accuracy
    )
    ```

    If `base_price` is not provided, BracketOrderManager will estimate it by reversing
    slippage from fill_price, but this may have rounding errors.
    """

    import logging
    from typing import Callable

    from qengine.core.event import FillEvent
    from qengine.core.types import OrderSide, OrderType
    from qengine.execution.order import Order

    logger = logging.getLogger(__name__)


    class BracketOrderManager:
    """Manages bracket orders and OCO (One-Cancels-Other) relationships.

    Responsibilities:
    - Create stop-loss and take-profit legs after parent fill
    - Link OCO orders
    - Cancel linked orders when one fills

    This class does NOT:
    - Execute orders (FillSimulator)
    - Route orders (OrderRouter)
    - Track positions (PositionTracker)
    """

    def __init__(self, submit_order_callback: Callable[[Order], None]) -> None:
    """Initialize bracket order manager.

    Args:
    submit_order_callback: Function to submit new orders (from broker)
    """
    self.submit_order = submit_order_callback
    self._bracket_relationships: dict[str, list[str]] = {} # parent -> children

    logger.debug("BracketOrderManager initialized")

    def handle_bracket_fill(self, parent_order: Order, fill_event: FillEvent) -> list[Order]:
    """Create bracket legs after parent order fills.

    Supports both absolute prices (profit_target, stop_loss) and
    percentage-based levels (tp_pct, sl_pct, tsl_pct) for VectorBT compatibility.

    CRITICAL: VectorBT calculates TP/SL/TSL from BASE PRICE (close without slippage),
    NOT from fill_price. This matches real-world behavior where stops are set relative
    to the "true" price, not the execution price with slippage.

    Args:
    parent_order: The filled bracket order
    fill_event: The fill event

    Returns:
    List of created leg orders (stop-loss and take-profit)
    """
    if parent_order.order_type != OrderType.BRACKET:
    return []

    # Get base price for TP/SL/TSL calculations
    # VectorBT uses close (pre-slippage) as reference, not fill_price (post-slippage)
    fill_price = fill_event.fill_price
    is_buy = parent_order.is_buy

    # Extract base price from order metadata if available (preferred method)
    base_price = parent_order.metadata.get("base_price")

    if base_price is None:
    # Fallback: Reverse slippage from fill_price
    # Note: This is an approximation and may have rounding errors
    slippage_amount = fill_event.slippage
    if slippage_amount != 0:
    # Reverse the slippage application to get base price
    # For BUY: fill_price = base_price * (1 + slippage_rate)
    # For SELL: fill_price = base_price * (1 - slippage_rate)
    # We stored the dollar amount, so estimate: base  fill - slippage
    base_price = fill_price - slippage_amount if is_buy else fill_price + slippage_amount
    else:
    # No slippage, fill_price is base_price
    base_price = fill_price

    logger.warning(
    f"Base price not found in order metadata for {parent_order.order_id}, "
    f"estimated from fill_price={fill_price} and slippage={slippage_amount}: "
    f"base_price={base_price}"
    )

    # Take profit level
    if parent_order.tp_pct is not None:
    # Percentage-based TP (calculated from BASE PRICE, not fill_price)
    if is_buy:
    profit_target = base_price * (1 + parent_order.tp_pct)
    else: # Short position
    profit_target = base_price * (1 - parent_order.tp_pct)
    else:
    profit_target = parent_order.profit_target

    # Stop loss level
    if parent_order.sl_pct is not None:
    # Percentage-based SL (calculated from BASE PRICE, not fill_price)
    if is_buy:
    stop_loss = base_price * (1 - parent_order.sl_pct)
    else: # Short position
    stop_loss = base_price * (1 + parent_order.sl_pct)
    elif parent_order.tsl_pct is not None:
    # Trailing stop loss (will use trail_percent parameter)
    stop_loss = None # Will be handled by trailing stop logic
    else:
    stop_loss = parent_order.stop_loss

    # Validate we have at least one exit level
    if profit_target is None and stop_loss is None and parent_order.tsl_pct is None:
    logger.warning(
    f"Bracket order {parent_order.order_id} missing exit parameters "
    f"(need profit_target/tp_pct or stop_loss/sl_pct/tsl_pct)"
    )
    return []

    # Create exit orders (opposite side of entry)
    exit_side = OrderSide.SELL if parent_order.is_buy else OrderSide.BUY
    created_orders = []

    # Create stop-loss order (if SL specified)
    if stop_loss is not None:
    stop_order = Order(
    asset_id=parent_order.asset_id,
    order_type=OrderType.STOP,
    side=exit_side,
    quantity=parent_order.filled_quantity,
    stop_price=stop_loss,
    parent_order_id=parent_order.order_id,
    metadata={
    "bracket_type": "stop_loss",
    "creation_timestamp": fill_event.timestamp, # VectorBT: Skip entry bar checking
    },
    )
    created_orders.append(stop_order)

    # Create trailing stop order (if TSL specified)
    if parent_order.tsl_pct is not None:
    tsl_order = Order(
    asset_id=parent_order.asset_id,
    order_type=OrderType.TRAILING_STOP,
    side=exit_side,
    quantity=parent_order.filled_quantity,
    trail_percent=parent_order.tsl_pct * 100.0, # Convert decimal to percentage (0.01 -> 1.0)
    parent_order_id=parent_order.order_id,
    metadata={
    "bracket_type": "trailing_stop",
    "base_price": base_price, # For VectorBT-compatible peak tracking (TASK-018)
    "creation_timestamp": fill_event.timestamp, # VectorBT: Skip entry bar checking
    },
    )
    created_orders.append(tsl_order)

    # Create take-profit order (if TP specified)
    if profit_target is not None:
    profit_order = Order(
    asset_id=parent_order.asset_id,
    order_type=OrderType.LIMIT,
    side=exit_side,
    quantity=parent_order.filled_quantity,
    limit_price=profit_target,
    parent_order_id=parent_order.order_id,
    metadata={
    "bracket_type": "take_profit",
    "creation_timestamp": fill_event.timestamp, # VectorBT: Skip entry bar checking
    },
    )
    created_orders.append(profit_order)

    # Link all orders as OCO (One-Cancels-Other)
    # Each order should cancel all others when it fills
    for order in created_orders:
    order.child_order_ids = [o.order_id for o in created_orders if o != order]

    # Track parent-child relationship
    self._bracket_relationships[parent_order.order_id] = [o.order_id for o in created_orders]

    # Submit all bracket legs
    for order in created_orders:
    self.submit_order(order)

    # Log created legs
    leg_types = ", ".join([o.metadata.get("bracket_type", "unknown") for o in created_orders])
    logger.info(
    f"Created {len(created_orders)} bracket legs for {parent_order.order_id}: {leg_types}"
    )

    return created_orders

    def handle_oco_fill(
    self, filled_order: Order, cancel_order_callback: Callable[[str], bool]
    ) -> list[str]:
    """Cancel linked OCO orders when one fills.

    Args:
    filled_order: The order that was filled
    cancel_order_callback: Function to cancel an order

    Returns:
    List of cancelled order IDs
    """
    if not filled_order.child_order_ids:
    return []

    cancelled = []
    for child_id in filled_order.child_order_ids:
    if cancel_order_callback(child_id):
    cancelled.append(child_id)
    logger.info(
    f"Cancelled OCO order {child_id} due to fill of {filled_order.order_id}"
    )

    return cancelled

    def get_bracket_children(self, parent_id: str) -> list[str]:
    """Get child order IDs for a bracket parent.

    Args:
    parent_id: Parent order ID

    Returns:
    List of child order IDs
    """
    return self._bracket_relationships.get(parent_id, [])

    def reset(self) -> None:
    """Reset to initial state."""
    self._bracket_relationships.clear()
    logger.debug("BracketOrderManager reset")
</file>

<file path="src/qengine/execution/broker.py">
    """Broker implementations for QEngine."""

    import logging
    from abc import ABC, abstractmethod
    from datetime import datetime
    from typing import TYPE_CHECKING, Any

    from qengine.core.assets import AssetRegistry
    from qengine.core.event import FillEvent, MarketEvent
    from qengine.core.types import (
    AssetId,
    OrderId,
    OrderStatus,
    OrderType,
    Price,
    Quantity,
    )
    from qengine.execution.bracket_manager import BracketOrderManager
    from qengine.execution.fill_simulator import FillSimulator
    from qengine.execution.order import Order, OrderState
    from qengine.execution.order_router import OrderRouter
    from qengine.execution.position_tracker import PositionTracker
    from qengine.execution.trade_tracker import TradeTracker
    from qengine.portfolio.margin import MarginAccount

    if TYPE_CHECKING:
    from qengine.execution.commission import CommissionModel
    from qengine.execution.liquidity import LiquidityModel
    from qengine.execution.market_impact import MarketImpactModel
    from qengine.execution.slippage import SlippageModel

    logger = logging.getLogger(__name__)


    class Broker(ABC):
    """Abstract base class for broker implementations."""

    @abstractmethod
    def submit_order(self, order: Order) -> OrderId:
    """Submit an order for execution."""

    @abstractmethod
    def cancel_order(self, order_id: OrderId) -> bool:
    """Cancel an existing order."""

    @abstractmethod
    def get_order(self, order_id: OrderId) -> Order | None:
    """Get order by ID."""

    @abstractmethod
    def get_open_orders(self, asset_id: AssetId | None = None) -> list[Order]:
    """Get all open orders, optionally filtered by asset."""

    @abstractmethod
    def on_market_event(self, event: MarketEvent) -> list[FillEvent]:
    """Process market event and generate fills."""


    class SimulationBroker(Broker):
    """
    Simulated broker for backtesting.

    Handles order execution with configurable realism models.
    Supports multiple asset classes including equities, futures, options, FX, and crypto.

    Features:
    - Execution delay: Prevents lookahead bias by delaying order fills by one market event
    - Multiple order types: Market, Limit, Stop, Trailing Stop, Bracket
    - Realistic fills: Slippage, commission, and market impact models
    - Position tracking: Multi-asset position management
    - Margin support: For derivatives trading
    """

    def __init__(
    self,
    initial_cash: float = 100000.0,
    asset_registry: AssetRegistry | None = None,
    commission_model: "CommissionModel | None" = None,
    slippage_model: "SlippageModel | None" = None,
    market_impact_model: "MarketImpactModel | None" = None,
    liquidity_model: "LiquidityModel | None" = None,
    fill_model: Any | None = None,
    enable_margin: bool = True,
    execution_delay: bool = True, # Add execution delay to prevent lookahead (default True to prevent bias)
    max_leverage: float = 1.0, # Maximum leverage allowed (1.0 = no leverage)
    allow_immediate_reentry: bool = True, # Allow re-entry on same bar as exit (default True for realism)
    ):
    """
    Initialize simulation broker with specialized components.

    Args:
    initial_cash: Starting cash balance
    asset_registry: Registry of asset specifications
    commission_model: Model for calculating commissions
    slippage_model: Model for calculating slippage
    market_impact_model: Model for calculating market impact
    liquidity_model: Model for liquidity constraints and volume limits
    fill_model: Model for determining fills
    enable_margin: Whether to enable margin trading for derivatives
    execution_delay: Whether to delay order execution by one market event (default True to prevent lookahead bias)
    max_leverage: Maximum leverage allowed (default 1.0 = no leverage).
    Prevents unlimited leverage as capital depletes. Example: max_leverage=2.0 allows
    positions up to 2x cash balance.
    allow_immediate_reentry: Whether to allow re-entering a position on the same bar where it was exited.
    True (default) = realistic behavior, allows intrabar exit+entry if liquidity exists.
    False = VectorBT-compatible mode, prevents same-bar re-entry for validation purposes.
    """
    # Store configuration
    self.initial_cash = initial_cash
    self.asset_registry = asset_registry or AssetRegistry()
    self.commission_model = commission_model
    self.slippage_model = slippage_model
    self.market_impact_model = market_impact_model
    self.liquidity_model = liquidity_model
    self.fill_model = fill_model
    self.enable_margin = enable_margin
    self.execution_delay = execution_delay
    self.max_leverage = max_leverage
    self.allow_immediate_reentry = allow_immediate_reentry

    # Initialize specialized components
    self.position_tracker = PositionTracker(initial_cash)
    self.order_router = OrderRouter(execution_delay)
    self.bracket_manager = BracketOrderManager(self.submit_order)

    # Margin account for derivatives
    if enable_margin:
    self.margin_account = MarginAccount(initial_cash, self.asset_registry)
    else:
    self.margin_account = None

    # Fill simulator
    self.fill_simulator = FillSimulator(
    asset_registry=self.asset_registry,
    commission_model=self.commission_model,
    slippage_model=self.slippage_model,
    market_impact_model=self.market_impact_model,
    liquidity_model=self.liquidity_model,
    margin_account=self.margin_account,
    max_leverage=self.max_leverage,
    )

    # Latest market prices
    self._last_prices: dict[AssetId, Price] = {}

    # Track last exit timestamp per asset (for allow_immediate_reentry=False)
    self._last_exit_time: dict[AssetId, datetime] = {}

    # VectorBT compatibility: Track newly-created brackets to skip checking on creation bar
    self._newly_created_brackets: set[str] = set()

    # Trade tracking (highly efficient)
    self.trade_tracker = TradeTracker()

    # Statistics
    self._total_commission = 0.0
    self._total_slippage = 0.0
    self._fill_count = 0

    logger.debug(
    f"SimulationBroker initialized with ${initial_cash:,.2f}, "
    f"execution_delay={execution_delay}, enable_margin={enable_margin}, "
    f"max_leverage={max_leverage}, allow_immediate_reentry={allow_immediate_reentry}"
    )

    # Properties for backward compatibility
    @property
    def cash(self) -> float:
    """Get current cash balance from PositionTracker."""
    return self.position_tracker.get_cash()

    @cash.setter
    def cash(self, value: float) -> None:
    """Set cash balance in PositionTracker."""
    self.position_tracker.cash = value

    @property
    def _positions(self) -> dict[AssetId, Quantity]:
    """Get positions from PositionTracker for backward compatibility."""
    return self.position_tracker._positions

    @property
    def _orders(self) -> dict[OrderId, Order]:
    """Get orders from OrderRouter for backward compatibility."""
    return self.order_router._orders

    @property
    def _open_orders(self) -> dict[AssetId, list[Order]]:
    """Get open orders from OrderRouter for backward compatibility."""
    return self.order_router._open_orders

    @property
    def _stop_orders(self) -> dict[AssetId, list[Order]]:
    """Get stop orders from OrderRouter for backward compatibility."""
    return self.order_router._stop_orders

    @property
    def _trailing_stops(self) -> dict[AssetId, list[Order]]:
    """Get trailing stops from OrderRouter for backward compatibility."""
    return self.order_router._trailing_stops

    @property
    def _pending_orders(self) -> dict[AssetId, list[tuple[Order, datetime]]]:
    """Get pending orders from OrderRouter for backward compatibility."""
    return self.order_router._pending_orders

    @property
    def trades(self) -> "pl.DataFrame":
    """
    Get completed trades as a Polars DataFrame.

    Returns DataFrame with columns:
    - trade_id: Unique trade identifier
    - asset_id: Asset symbol
    - entry_dt: Entry timestamp
    - entry_price: Entry execution price
    - entry_quantity: Position size
    - entry_commission: Entry fees
    - entry_slippage: Entry slippage cost
    - entry_order_id: Entry order ID
    - exit_dt: Exit timestamp
    - exit_price: Exit execution price
    - exit_quantity: Exit position size
    - exit_commission: Exit fees
    - exit_slippage: Exit slippage cost
    - exit_order_id: Exit order ID
    - pnl: Net profit/loss
    - return_pct: Return percentage
    - duration_bars: Trade duration in bars
    - direction: "long" or "short"

    Example:
    >>> broker = SimulationBroker(initial_cash=100000)
    >>> # ... run backtest ...
    >>> trades_df = broker.trades
    >>> print(f"Total trades: {len(trades_df)}")
    >>> print(f"Total PnL: ${trades_df['pnl'].sum():.2f}")
    """
    import polars as pl

    return self.trade_tracker.get_trades_df()

    def can_enter_position(self, asset_id: AssetId, current_time: datetime) -> bool:
    """
    Check if a new position can be entered for the given asset.

    When allow_immediate_reentry=False, prevents entering a position on the same
    bar where the previous position was exited (VectorBT-compatible behavior).

    Args:
    asset_id: Asset to check
    current_time: Current bar timestamp

    Returns:
    True if entry is allowed, False otherwise
    """
    if self.allow_immediate_reentry:
    return True

    # Check if we exited on this same bar
    if asset_id in self._last_exit_time:
    return self._last_exit_time[asset_id] != current_time

    return True

    def submit_order(self, order: Order, timestamp: datetime | None = None) -> OrderId:
    """
    Submit an order for execution.

    Args:
    order: Order to submit
    timestamp: Current simulation time (if None, uses datetime.now() for compatibility)

    Returns:
    Order ID

    Raises:
    ValueError: If order is invalid
    """
    # Validate order
    if order.quantity<= 0:
    raise ValueError(f"Order quantity must be positive, got {order.quantity}")

    if order.order_type == OrderType.LIMIT and order.limit_price is None:
    raise ValueError("LIMIT order requires limit_price")

    if order.order_type == OrderType.STOP and order.stop_price is None:
    raise ValueError("STOP order requires stop_price")

    if order.order_type == OrderType.STOP_LIMIT:
    if order.limit_price is None:
    raise ValueError("STOP_LIMIT order requires limit_price")
    if order.stop_price is None:
    raise ValueError("STOP_LIMIT order requires stop_price")

    if order.limit_price is not None and order.limit_price<= 0:
    raise ValueError(f"Limit price must be positive, got {order.limit_price}")

    if order.stop_price is not None and order.stop_price<= 0:
    raise ValueError(f"Stop price must be positive, got {order.stop_price}")

    # Update order state
    order.state = OrderState.SUBMITTED
    order.status = OrderStatus.SUBMITTED
    order.submitted_time = timestamp if timestamp else datetime.now()

    # Initialize trailing stop price if applicable
    if order.order_type == OrderType.TRAILING_STOP and order.asset_id in self._last_prices:
    order.update_trailing_stop(self._last_prices[order.asset_id])

    # Route order (delegates to OrderRouter)
    self.order_router.route_order(order, order.submitted_time)

    # Legacy immediate execution for market orders (no delay mode)
    if not self.execution_delay and order.order_type == OrderType.MARKET:
    if order.asset_id in self._last_prices:
    fill_result = self.fill_simulator.try_fill_order(
    order,
    market_price=self._last_prices[order.asset_id],
    current_cash=self.position_tracker.get_cash(),
    current_position=self.position_tracker.get_position(order.asset_id),
    timestamp=timestamp,
    )
    if fill_result:
    # Update position tracker
    self.position_tracker.update_position(
    order.asset_id,
    fill_result.fill_quantity,
    order.side,
    fill_result.fill_price,
    fill_result.commission,
    fill_result.slippage,
    )
    # Update statistics
    self._total_commission += fill_result.commission
    self._total_slippage += fill_result.slippage
    self._fill_count += 1

    # Track trade (same as delayed execution path)
    self.trade_tracker.on_fill(fill_result.fill_event)

    # Publish fill event immediately if order was filled
    if hasattr(self, "event_bus") and self.event_bus:
    self.event_bus.publish(fill_result.fill_event)

    logger.debug(f"Submitted order: {order}")
    return order.order_id

    def cancel_order(self, order_id: OrderId) -> bool:
    """
    Cancel an existing order (delegates to OrderRouter).

    Args:
    order_id: ID of order to cancel

    Returns:
    True if cancelled successfully
    """
    order = self.order_router.get_order(order_id)
    if not order or not order.is_active:
    return False

    # Remove from queues (delegates to OrderRouter)
    removed = self.order_router.remove_order(order)

    if removed:
    # Update order state
    order.cancel()
    logger.debug(f"Cancelled order: {order}")
    return True

    return False

    def get_order(self, order_id: OrderId) -> Order | None:
    """Get order by ID (delegates to OrderRouter)."""
    return self.order_router.get_order(order_id)

    def get_open_orders(self, asset_id: AssetId | None = None) -> list[Order]:
    """Get all open orders, optionally filtered by asset (delegates to OrderRouter)."""
    return [o for o in self.order_router.get_open_orders(asset_id) if o.is_active]

    def _get_exit_priority(self, bracket_type: str) -> int:
    """
    Get VectorBT exit priority for bracket leg type.

    Priority Order (lower number = higher priority):
    1. Stop Loss (SL)
    2. Trailing Stop Loss (TSL)
    3. Take Profit (TP)

    Args:
    bracket_type: Type from order.metadata["bracket_type"]

    Returns:
    Priority value (1 = highest, 3 = lowest)
    """
    priority_map = {
    "stop_loss": 1, # Highest priority
    "trailing_stop": 2, # Medium priority
    "take_profit": 3, # Lowest priority
    }
    return priority_map.get(bracket_type, 999) # Unknown types get lowest priority

    def _collect_triggered_bracket_exits(
    self,
    asset_id: AssetId,
    event: MarketEvent,
    price: Price,
    ) -> list[tuple[int, str, Order]]:
    """
    Collect all triggered bracket exit orders without filling them.

    Returns list of (priority, bracket_type, order) tuples sorted by priority.
    Only includes bracket leg orders (stop_loss, trailing_stop, take_profit).

    Args:
    asset_id: Asset identifier
    event: Market event with OHLC data
    price: Current market price

    Returns:
    List of (priority, bracket_type, order) tuples, sorted by priority (lowest first)
    """
    triggered = []

    # Check TP orders (LIMIT orders in open_orders with bracket_type="take_profit")
    for order in list(self._open_orders[asset_id]):
    bracket_type = order.metadata.get("bracket_type")
    if bracket_type == "take_profit":
    # VectorBT: Skip newly-created brackets (created in current event)
    if order.order_id in self._newly_created_brackets:
    continue

    # TP triggers when high >= limit_price
    if order.can_fill(price=price, high=event.high, low=event.low):
    priority = self._get_exit_priority(bracket_type)
    triggered.append((priority, bracket_type, order))

    # Check SL orders (STOP orders in stop_orders with bracket_type="stop_loss")
    for order in list(self._stop_orders[asset_id]):
    bracket_type = order.metadata.get("bracket_type")
    if bracket_type == "stop_loss":
    # VectorBT: Skip newly-created brackets (created in current event)
    if order.order_id in self._newly_created_brackets:
    continue

    # SL triggers when low<= stop_price
    if self._should_trigger_stop(order, price):
    priority = self._get_exit_priority(bracket_type)
    triggered.append((priority, bracket_type, order))

    # Check TSL orders (TRAILING_STOP orders with bracket_type="trailing_stop")
    for order in list(self._trailing_stops[asset_id]):
    bracket_type = order.metadata.get("bracket_type")
    if bracket_type == "trailing_stop":
    # VectorBT: Skip newly-created brackets (created in current event)
    if order.order_id in self._newly_created_brackets:
    continue

    # Initialize peak tracking if not present
    if "peak_price" not in order.metadata:
    order.metadata["peak_price"] = order.metadata.get("base_price", price)

    # VectorBT 4-stage per-bar process (from TASK-018)
    # Stage 1: Update peak with open
    peak_price = order.metadata["peak_price"]
    if event.open > peak_price:
    peak_price = event.open
    order.metadata["peak_price"] = peak_price

    # Stage 2: Check TSL trigger with current peak
    if order.trail_percent is not None:
    trail_amount = peak_price * (order.trail_percent / 100.0)
    # BUG FIX: Logic was inverted!
    # For SELL orders (exiting long): TSL = peak - trail_amount (stop BELOW)
    # For BUY orders (exiting short): TSL = peak + trail_amount (stop ABOVE)
    if order.is_buy:
    # BUY order (exiting short): TSL above peak
    tsl_level = peak_price + trail_amount
    else:
    # SELL order (exiting long): TSL below peak
    tsl_level = peak_price - trail_amount
    order.trailing_stop_price = tsl_level

    can_fill_result = order.can_fill(price=price, high=event.high, low=event.low)

    if can_fill_result:
    priority = self._get_exit_priority(bracket_type)
    triggered.append((priority, bracket_type, order))
    continue # Don't do stages 3/4 if already triggered

    # Stage 3: Update peak with high
    if event.high > peak_price:
    peak_price = event.high
    order.metadata["peak_price"] = peak_price

    # Stage 4: Re-check TSL with updated peak
    if order.trail_percent is not None and not order.is_filled:
    trail_amount = peak_price * (order.trail_percent / 100.0)
    # BUG FIX: Same fix as Stage 2
    if order.is_buy:
    # BUY order (exiting short): TSL above peak
    tsl_level = peak_price + trail_amount
    else:
    # SELL order (exiting long): TSL below peak
    tsl_level = peak_price - trail_amount
    order.trailing_stop_price = tsl_level

    # Sort by priority (lowest number = highest priority)
    triggered.sort(key=lambda x: x[0])
    return triggered

    def on_market_event(self, event: MarketEvent) -> list[FillEvent]:
    """
    Process market event and generate fills.

    Args:
    event: Market data event

    Returns:
    List of fill events generated
    """
    # Increment bar counter for trade duration tracking
    self.trade_tracker.on_bar()

    fills = []
    asset_id = event.asset_id

    # Determine execution price
    if event.close is not None:
    price = event.close
    elif event.price is not None:
    price = event.price
    else:
    return fills # No price available

    # Update last known price
    self._last_prices[asset_id] = price

    # Process existing open orders FIRST (before moving pending orders)
    # This ensures pending orders wait for the next event
    # IMPORTANT: Skip bracket exit orders here - they're handled with priority logic below
    for order in list(self._open_orders[asset_id]):
    if not order.is_active:
    continue

    # Skip bracket exits (TP, SL, TSL) - they use priority-based processing
    if order.metadata.get("bracket_type") in ["take_profit", "stop_loss", "trailing_stop"]:
    continue

    fill_result = self.fill_simulator.try_fill_order(
    order,
    market_price=price,
    current_cash=self.position_tracker.get_cash(),
    current_position=self.position_tracker.get_position(asset_id),
    timestamp=event.timestamp,
    high=event.high,
    low=event.low,
    close=event.close,
    )
    if fill_result:
    # Check position before fill (for exit tracking)
    position_before = self.position_tracker.get_position(asset_id)

    # Update position tracker
    self.position_tracker.update_position(
    asset_id,
    fill_result.fill_quantity,
    order.side,
    fill_result.fill_price,
    fill_result.commission,
    fill_result.slippage,
    )

    # Track exit timestamp if position went to zero (for allow_immediate_reentry=False)
    position_after = self.position_tracker.get_position(asset_id)
    if position_before != 0 and position_after == 0:
    self._last_exit_time[asset_id] = event.timestamp

    # Update statistics
    self._total_commission += fill_result.commission
    self._total_slippage += fill_result.slippage
    self._fill_count += 1

    # Track trade (efficient - minimal overhead)
    self.trade_tracker.on_fill(fill_result.fill_event)

    fills.append(fill_result.fill_event)

    # Remove filled orders
    if order.is_filled:
    self.order_router.remove_order(order)

    # Handle bracket order completion
    if order.order_type == OrderType.BRACKET:
    self._handle_bracket_fill(order, fill_result.fill_event)
    # Handle OCO (One-Cancels-Other) logic for bracket legs (delegates to BracketOrderManager)
    # Only cancel sibling orders if this is a bracket leg (not the parent)
    elif order.child_order_ids and order.metadata.get("bracket_type"):
    self.bracket_manager.handle_oco_fill(order, self.cancel_order)

    # Check stop orders for triggering
    # IMPORTANT: Skip bracket SL orders - they're handled with priority logic below
    triggered_stops = []
    for order in list(self._stop_orders[asset_id]):
    # Skip bracket exits - they use priority-based processing
    if order.metadata.get("bracket_type") == "stop_loss":
    continue

    if self._should_trigger_stop(order, price):
    triggered_stops.append(order)
    self._stop_orders[asset_id].remove(order)

    # Process triggered stops immediately
    for order in triggered_stops:
    if order.order_type == OrderType.STOP:
    # Convert to market order and try to fill immediately
    original_type = order.order_type
    order.metadata["original_type"] = "STOP"
    order.order_type = OrderType.MARKET
    fill_result = self.fill_simulator.try_fill_order(
    order,
    market_price=price,
    current_cash=self.position_tracker.get_cash(),
    current_position=self.position_tracker.get_position(asset_id),
    timestamp=event.timestamp,
    high=event.high,
    low=event.low,
    close=event.close,
    )
    if fill_result:
    # Update position tracker
    self.position_tracker.update_position(
    asset_id,
    fill_result.fill_quantity,
    order.side,
    fill_result.fill_price,
    fill_result.commission,
    fill_result.slippage,
    )
    # Update statistics
    self._total_commission += fill_result.commission
    self._total_slippage += fill_result.slippage
    self._fill_count += 1

    fills.append(fill_result.fill_event)

    # FIX: Handle OCO logic for bracket legs that are filled as stop orders (delegates to BracketOrderManager)
    if (
    order.is_filled
    and order.child_order_ids
    and order.metadata.get("bracket_type")
    ):
    self.bracket_manager.handle_oco_fill(order, self.cancel_order)

    else:
    # If couldn't fill as market order, restore type and add to open orders
    order.order_type = original_type
    del order.metadata["original_type"]
    self._open_orders[asset_id].append(order)
    elif order.order_type == OrderType.STOP_LIMIT:
    # Keep as limit order after triggering
    order.order_type = OrderType.LIMIT
    self._open_orders[asset_id].append(order)

    # Update and check trailing stops
    # VectorBT TSL behavior (TASK-007): Trail from PEAK price, not current price
    # Peak tracking uses metadata-based approach for now (short-term workaround)
    # IMPORTANT: Skip bracket TSL orders - they're handled with priority logic below
    triggered_trailing = []
    for order in list(self._trailing_stops[asset_id]):
    # Skip bracket exits - they use priority-based processing
    if order.metadata.get("bracket_type") == "trailing_stop":
    continue

    # Initialize peak tracking if not present
    if "peak_price" not in order.metadata:
    # Initialize peak to entry price (base price)
    order.metadata["peak_price"] = order.metadata.get("base_price", price)

    # VectorBT 4-stage per-bar process:
    # Stage 1: Update peak with open (before checking stop)
    peak_price = order.metadata["peak_price"]
    if event.open > peak_price:
    peak_price = event.open
    order.metadata["peak_price"] = peak_price

    # Stage 2: Check TSL trigger with current peak (against low)
    # Calculate TSL level from peak, not current price
    if order.trail_percent is not None:
    trail_amount = peak_price * (order.trail_percent / 100.0)
    # BUG FIX: Logic was inverted (same as bracket code fix)
    if order.is_buy:
    # BUY order (exiting short): TSL above peak
    tsl_level = peak_price + trail_amount
    else:
    # SELL order (exiting long): TSL below peak
    tsl_level = peak_price - trail_amount

    order.trailing_stop_price = tsl_level

    # Check if triggered (for long exit: low<= tsl_level)
    if order.can_fill(price=price, high=event.high, low=event.low):
    triggered_trailing.append(order)
    self._trailing_stops[asset_id].remove(order)
    continue # Skip stage 3/4 if triggered

    # Stage 3: Update peak with high (after checking stop)
    if event.high > peak_price:
    peak_price = event.high
    order.metadata["peak_price"] = peak_price

    # Stage 4: Re-check TSL with updated peak (against close)
    # Recalculate TSL level with potentially updated peak
    if order.trail_percent is not None and not order.is_filled:
    trail_amount = peak_price * (order.trail_percent / 100.0)
    # BUG FIX: Same as Stage 2
    if order.is_buy:
    # BUY order (exiting short): TSL above peak
    tsl_level = peak_price + trail_amount
    else:
    # SELL order (exiting long): TSL below peak
    tsl_level = peak_price - trail_amount

    order.trailing_stop_price = tsl_level

    # Process triggered trailing stops immediately (as market orders)
    for order in triggered_trailing:
    original_type = order.order_type
    order.metadata["original_type"] = "TRAILING_STOP"
    order.order_type = OrderType.MARKET
    fill_result = self.fill_simulator.try_fill_order(
    order,
    market_price=price,
    current_cash=self.position_tracker.get_cash(),
    current_position=self.position_tracker.get_position(asset_id),
    timestamp=event.timestamp,
    high=event.high,
    low=event.low,
    close=event.close,
    )
    if fill_result:
    # Check position before fill (for exit tracking)
    position_before = self.position_tracker.get_position(asset_id)

    # Update position tracker
    self.position_tracker.update_position(
    asset_id,
    fill_result.fill_quantity,
    order.side,
    fill_result.fill_price,
    fill_result.commission,
    fill_result.slippage,
    )

    # Track exit timestamp if position went to zero (for allow_immediate_reentry=False)
    position_after = self.position_tracker.get_position(asset_id)
    if position_before != 0 and position_after == 0:
    self._last_exit_time[asset_id] = event.timestamp

    # Update statistics
    self._total_commission += fill_result.commission
    self._total_slippage += fill_result.slippage
    self._fill_count += 1

    # Track trade (efficient - minimal overhead)
    self.trade_tracker.on_fill(fill_result.fill_event)

    fills.append(fill_result.fill_event)

    # FIX: Handle OCO logic for bracket legs that are filled as trailing stops (delegates to BracketOrderManager)
    if order.is_filled and order.child_order_ids and order.metadata.get("bracket_type"):
    self.bracket_manager.handle_oco_fill(order, self.cancel_order)

    else:
    # If couldn't fill as market order, restore type and add to open orders
    order.order_type = original_type
    del order.metadata["original_type"]
    self._open_orders[asset_id].append(order)

    # TASK-019: Process bracket exits with VectorBT priority (SL > TSL > TP)
    # Collect all triggered bracket exits without filling them
    triggered_bracket_exits = self._collect_triggered_bracket_exits(asset_id, event, price)

    # Fill ONLY the highest priority exit (if any triggered)
    if triggered_bracket_exits:
    priority, bracket_type, winning_order = triggered_bracket_exits[0]

    # Remove winning order from its queue
    if bracket_type == "take_profit":
    if winning_order in self._open_orders[asset_id]:
    self._open_orders[asset_id].remove(winning_order)
    elif bracket_type == "stop_loss":
    if winning_order in self._stop_orders[asset_id]:
    self._stop_orders[asset_id].remove(winning_order)
    elif bracket_type == "trailing_stop":
    if winning_order in self._trailing_stops[asset_id]:
    self._trailing_stops[asset_id].remove(winning_order)

    # Convert stop/trailing orders to MARKET for filling
    original_type = winning_order.order_type
    if bracket_type in ["stop_loss", "trailing_stop"]:
    winning_order.metadata["original_type"] = original_type.value
    winning_order.order_type = OrderType.MARKET

    # Fill the winning exit
    fill_result = self.fill_simulator.try_fill_order(
    winning_order,
    market_price=price,
    current_cash=self.position_tracker.get_cash(),
    current_position=self.position_tracker.get_position(asset_id),
    timestamp=event.timestamp,
    high=event.high,
    low=event.low,
    close=event.close,
    open=event.open,
    )

    if fill_result:
    # Check position before fill (for exit tracking)
    position_before = self.position_tracker.get_position(asset_id)

    # Update position tracker
    self.position_tracker.update_position(
    asset_id,
    fill_result.fill_quantity,
    winning_order.side,
    fill_result.fill_price,
    fill_result.commission,
    fill_result.slippage,
    )

    # Track exit timestamp if position went to zero
    position_after = self.position_tracker.get_position(asset_id)
    if position_before != 0 and position_after == 0:
    self._last_exit_time[asset_id] = event.timestamp

    # Update statistics
    self._total_commission += fill_result.commission
    self._total_slippage += fill_result.slippage
    self._fill_count += 1

    # Track trade
    self.trade_tracker.on_fill(fill_result.fill_event)

    fills.append(fill_result.fill_event)

    # Handle OCO logic to cancel sibling bracket orders
    if winning_order.is_filled and winning_order.child_order_ids and winning_order.metadata.get("bracket_type"):
    self.bracket_manager.handle_oco_fill(winning_order, self.cancel_order)

    else:
    # If couldn't fill, restore order type and add back to queue
    if bracket_type in ["stop_loss", "trailing_stop"]:
    winning_order.order_type = original_type
    if "original_type" in winning_order.metadata:
    del winning_order.metadata["original_type"]

    if bracket_type == "take_profit":
    self._open_orders[asset_id].append(winning_order)
    elif bracket_type == "stop_loss":
    self._stop_orders[asset_id].append(winning_order)
    elif bracket_type == "trailing_stop":
    self._trailing_stops[asset_id].append(winning_order)

    # CRITICAL FIX: Move pending orders to open AFTER processing current orders
    # This ensures orders cannot be filled on the same event that triggered them
    if self.execution_delay and asset_id in self._pending_orders:
    # Move pending orders to open orders for NEXT event's processing
    for order, _ in self._pending_orders[asset_id]:
    if order.order_type == OrderType.BRACKET:
    # Bracket orders start as regular orders and create legs after fill
    self._open_orders[asset_id].append(order)
    else:
    self._open_orders[asset_id].append(order)
    # Clear pending orders after moving them
    self._pending_orders[asset_id].clear()

    # Publish fill events to the event bus (if available)
    if hasattr(self, "event_bus") and self.event_bus:
    for fill_event in fills:
    self.event_bus.publish(fill_event)

    # Clear newly-created brackets set for next event (VectorBT: brackets now active)
    self._newly_created_brackets.clear()

    return fills

    def _should_trigger_stop(self, order: Order, price: Price) -> bool:
    """Check if stop order should be triggered."""
    if order.stop_price is None:
    return False

    if order.is_buy:
    return price >= order.stop_price
    return price<= order.stop_price

    def _handle_bracket_fill(self, parent_order: Order, fill_event: FillEvent) -> None:
    """
    Handle completion of bracket order by creating stop-loss and take-profit orders.
    (Delegates to BracketOrderManager)

    Args:
    parent_order: The filled bracket order
    fill_event: The fill event that completed the order
    """
    leg_orders = self.bracket_manager.handle_bracket_fill(parent_order, fill_event)

    # Track parent-child relationship and mark as newly created (VectorBT: skip same-bar checking)
    if leg_orders:
    parent_order.child_order_ids.extend([o.order_id for o in leg_orders])
    # Add to newly-created set so they won't be checked until next bar
    for leg_order in leg_orders:
    self._newly_created_brackets.add(leg_order.order_id)


    def get_position(self, asset_id: AssetId) -> Quantity:
    """Get current position for an asset (delegates to PositionTracker)."""
    return self.position_tracker.get_position(asset_id)

    def get_positions(self) -> dict[AssetId, Quantity]:
    """Get all current positions (delegates to PositionTracker)."""
    return self.position_tracker.get_all_positions()

    def get_cash(self) -> float:
    """Get current cash balance (delegates to PositionTracker)."""
    return self.position_tracker.get_cash()

    def get_statistics(self) -> dict[str, Any]:
    """Get broker statistics."""
    return {
    "total_commission": self._total_commission,
    "total_slippage": self._total_slippage,
    "fill_count": self._fill_count,
    "open_orders": sum(len(orders) for orders in self._open_orders.values()),
    "stop_orders": sum(len(orders) for orders in self._stop_orders.values()),
    }

    def initialize(self, portfolio, event_bus) -> None:
    """Initialize broker with portfolio and event bus.

    Args:
    portfolio: Portfolio instance for position tracking
    event_bus: Event bus for publishing fill events
    """
    self.portfolio = portfolio
    self.event_bus = event_bus
    logger.debug("SimulationBroker initialized")

    def on_order_event(self, event) -> None:
    """Handle order event from strategy.

    Args:
    event: OrderEvent to process
    """
    from qengine.execution.order import Order

    # Create Order object from OrderEvent
    order = Order(
    order_id=event.order_id,
    asset_id=event.asset_id,
    order_type=event.order_type,
    side=event.side,
    quantity=event.quantity,
    limit_price=getattr(event, "limit_price", None),
    stop_price=getattr(event, "stop_price", None),
    time_in_force=getattr(event, "time_in_force", None),
    )

    # Submit the order
    self.submit_order(order)

    def finalize(self) -> None:
    """Finalize broker at end of backtest."""
    # Cancel all remaining open orders
    for asset_orders in self._open_orders.values():
    for order in list(asset_orders):
    if order.is_active:
    order.cancel()

    for asset_orders in self._stop_orders.values():
    for order in list(asset_orders):
    if order.is_active:
    order.cancel()

    logger.info(f"SimulationBroker finalized. Total fills: {self._fill_count}")

    def get_trades(self) -> Any:
    """Get all executed trades.

    Returns:
    DataFrame or list of trades
    """
    import polars as pl

    trades = []
    for order_id, order in self._orders.items():
    if order.filled_quantity > 0:
    trades.append(
    {
    "order_id": order_id,
    "asset_id": order.asset_id,
    "side": order.side.value,
    "quantity": order.filled_quantity,
    "price": order.average_fill_price,
    "commission": order.commission,
    "status": order.status.value,
    "submitted_time": order.submitted_time,
    "filled_time": order.filled_time,
    },
    )

    if trades:
    return pl.DataFrame(trades)
    return pl.DataFrame()

    def reset(self) -> None:
    """Reset broker to initial state (delegates to components).

    Raises:
    RuntimeError: If reset() called before initialization
    """
    if not hasattr(self, "initial_cash"):
    raise RuntimeError(
    "SimulationBroker.reset() called before initialization. "
    "Call __init__() with initial_cash parameter first."
    )

    # Reset components
    self.position_tracker.reset()
    self.order_router.reset()
    self.bracket_manager.reset()
    self.fill_simulator.reset()

    # Reset local state
    self._last_prices.clear()
    self._total_commission = 0.0
    self._total_slippage = 0.0
    self._fill_count = 0

    logger.debug("SimulationBroker reset (all components)")
</file>

<file path="src/qengine/execution/commission.py">
    """Commission models for realistic cost simulation."""

    from abc import ABC, abstractmethod
    from typing import TYPE_CHECKING

    if TYPE_CHECKING:
    from qengine.core.types import Price, Quantity
    from qengine.execution.order import Order


    class CommissionModel(ABC):
    """Abstract base class for commission models."""

    @abstractmethod
    def calculate(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    fill_price: "Price",
    ) -> float:
    """Calculate commission for a filled order.

    Args:
    order: The order being filled
    fill_quantity: Quantity of the fill
    fill_price: Price at which the order was filled

    Returns:
    Commission amount in currency terms
    """

    def __repr__(self) -> str:
    """String representation."""
    return f"{self.__class__.__name__}()"


    class NoCommission(CommissionModel):
    """No commission model for testing."""

    def calculate(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    fill_price: "Price",
    ) -> float:
    """Calculate zero commission."""
    return 0.0


    class FlatCommission(CommissionModel):
    """Flat commission per trade."""

    def __init__(self, commission: float = 1.0):
    """Initialize flat commission model.

    Args:
    commission: Flat fee per trade (default $1)
    """
    if commission
    <
    0:
    raise ValueError("Commission cannot be negative")
    self.commission = commission

    def calculate(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    fill_price: "Price",
    ) -> float:
    """Calculate flat commission."""
    return self.commission

    def __repr__(self) -> str:
    """String representation."""
    return f"FlatCommission(commission={self.commission})"


    class PercentageCommission(CommissionModel):
    """Percentage-based commission on trade value."""

    def __init__(self, rate: float = 0.001):
    """Initialize percentage commission model.

    Args:
    rate: Commission rate as decimal (0.001 = 0.1% = 10bps)
    """
    if rate
    <
    0:
    raise ValueError("Commission rate cannot be negative")
    if rate > 0.1: # 10% cap as sanity check
    raise ValueError("Commission rate too high (>10%)")
    self.rate = rate

    def calculate(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    fill_price: "Price",
    ) -> float:
    """Calculate percentage-based commission."""
    notional = fill_quantity * fill_price
    return notional * self.rate

    def __repr__(self) -> str:
    """String representation."""
    return f"PercentageCommission(rate={self.rate})"


    class PerShareCommission(CommissionModel):
    """Per-share commission model."""

    def __init__(self, commission_per_share: float = 0.005):
    """Initialize per-share commission model.

    Args:
    commission_per_share: Commission per share (default $0.005)
    """
    if commission_per_share
    <
    0:
    raise ValueError("Per-share commission cannot be negative")
    self.commission_per_share = commission_per_share

    def calculate(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    fill_price: "Price",
    ) -> float:
    """Calculate per-share commission."""
    return fill_quantity * self.commission_per_share

    def __repr__(self) -> str:
    """String representation."""
    return f"PerShareCommission(commission_per_share={self.commission_per_share})"


    class TieredCommission(CommissionModel):
    """Tiered commission based on trade size."""

    def __init__(
    self,
    tiers: list[tuple[float, float]] | None = None,
    minimum: float = 1.0,
    ):
    """Initialize tiered commission model.

    Args:
    tiers: List of (threshold, rate) tuples in ascending order
    Default: [(10000, 0.0010), (50000, 0.0008), (100000, 0.0005)]
    minimum: Minimum commission per trade
    """
    if tiers is None:
    # Default tiers: better rates for larger trades
    tiers = [
    (10_000, 0.0010), # 10 bps for trades
    <
    $10k
    (50_000, 0.0008), # 8 bps for trades $10k-$50k
    (100_000, 0.0005), # 5 bps for trades $50k-$100k
    (float("inf"), 0.0003), # 3 bps for trades > $100k
    ]

    # Validate tiers
    prev_threshold = 0
    for threshold, rate in tiers:
    if threshold<= prev_threshold:
    raise ValueError("Tiers must be in ascending order")
    if rate
    <
    0:
    raise ValueError("Commission rates cannot be negative")
    prev_threshold = threshold

    if minimum
    <
    0:
    raise ValueError("Minimum commission cannot be negative")

    self.tiers = tiers
    self.minimum = minimum

    def calculate(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    fill_price: "Price",
    ) -> float:
    """Calculate tiered commission based on notional value."""
    notional = fill_quantity * fill_price

    # Find applicable tier
    rate = self.tiers[-1][1] # Default to highest tier
    for threshold, tier_rate in self.tiers:
    if notional
    < threshold:
      rate= tier_rate
      break

      commission= notional
    * rate
    return max(commission, self.minimum)

    def __repr__(self) -> str:
    """String representation."""
    return f"TieredCommission(tiers={self.tiers}, minimum={self.minimum})"


    class MakerTakerCommission(CommissionModel):
    """Maker-taker commission model (exchanges)."""

    def __init__(
    self,
    maker_rate: float = -0.0002, # Maker rebate
    taker_rate: float = 0.0003, # Taker fee
    ):
    """Initialize maker-taker commission model.

    Args:
    maker_rate: Maker fee rate (negative for rebate)
    taker_rate: Taker fee rate
    """
    if taker_rate
    <
    0:
    raise ValueError("Taker rate should be positive")
    if maker_rate > taker_rate:
    raise ValueError("Maker rate should not exceed taker rate")

    self.maker_rate = maker_rate
    self.taker_rate = taker_rate

    def calculate(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    fill_price: "Price",
    ) -> float:
    """Calculate maker-taker commission based on order type."""
    from qengine.execution.order import OrderType

    notional = fill_quantity * fill_price

    # Market orders always take liquidity
    # Limit orders that execute immediately also take liquidity
    # For simplicity, we assume limit orders make liquidity
    rate = self.taker_rate if order.order_type == OrderType.MARKET else self.maker_rate

    commission = notional * rate
    # Negative commission means rebate, but ensure we don't pay too much rebate
    return max(commission, -notional * 0.001) # Cap rebate at 10bps

    def __repr__(self) -> str:
    """String representation."""
    return f"MakerTakerCommission(maker_rate={self.maker_rate}, taker_rate={self.taker_rate})"


    class AssetClassCommission(CommissionModel):
    """Asset class specific commission model."""

    def __init__(
    self,
    equity_rate: float = 0.001, # 10 bps
    futures_per_contract: float = 2.50, # $2.50 per contract
    options_per_contract: float = 0.65, # $0.65 per contract
    forex_rate: float = 0.0002, # 2 bps
    crypto_rate: float = 0.002, # 20 bps
    default_rate: float = 0.001, # 10 bps fallback
    ):
    """Initialize asset class commission model.

    Args:
    equity_rate: Commission rate for equities
    futures_per_contract: Commission per futures contract
    options_per_contract: Commission per options contract
    forex_rate: Commission rate for forex
    crypto_rate: Commission rate for crypto
    default_rate: Default commission rate
    """
    self.equity_rate = equity_rate
    self.futures_per_contract = futures_per_contract
    self.options_per_contract = options_per_contract
    self.forex_rate = forex_rate
    self.crypto_rate = crypto_rate
    self.default_rate = default_rate

    def calculate(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    fill_price: "Price",
    ) -> float:
    """Calculate commission based on asset class."""
    # Determine asset class from symbol or metadata
    asset_class = order.metadata.get("asset_class", "equity")

    if asset_class == "futures":
    # Futures charge per contract
    return fill_quantity * self.futures_per_contract
    if asset_class == "options":
    # Options charge per contract (1 contract = 100 shares usually)
    contracts = fill_quantity / 100
    return contracts * self.options_per_contract
    if asset_class == "forex":
    notional = fill_quantity * fill_price
    return notional * self.forex_rate
    if asset_class == "crypto":
    notional = fill_quantity * fill_price
    return notional * self.crypto_rate
    if asset_class == "equity":
    notional = fill_quantity * fill_price
    return notional * self.equity_rate
    # Default rate for unknown asset classes
    notional = fill_quantity * fill_price
    return notional * self.default_rate

    def __repr__(self) -> str:
    """String representation."""
    return (
    f"AssetClassCommission("
    f"equity_rate={self.equity_rate}, "
    f"futures_per_contract={self.futures_per_contract}, "
    f"options_per_contract={self.options_per_contract}, "
    f"forex_rate={self.forex_rate}, "
    f"crypto_rate={self.crypto_rate})"
    )


    class InteractiveBrokersCommission(CommissionModel):
    """Interactive Brokers tiered commission structure."""

    def __init__(self, tier: str = "fixed"):
    """Initialize IB commission model.

    Args:
    tier: Commission tier ('fixed' or 'tiered')
    """
    if tier not in ["fixed", "tiered"]:
    raise ValueError("Tier must be 'fixed' or 'tiered'")
    self.tier = tier

    def calculate(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    fill_price: "Price",
    ) -> float:
    """Calculate IB commission."""
    if self.tier == "fixed":
    # Fixed pricing: $0.005 per share, $1 minimum, $1% max
    per_share = fill_quantity * 0.005
    min_commission = 1.0
    max_commission = fill_quantity * fill_price * 0.01
    return min(max(per_share, min_commission), max_commission)
    # Tiered pricing (simplified)
    fill_quantity * fill_price
    if fill_quantity<= 300:
    rate = 0.0035 # $0.0035 per share for first 300
    elif fill_quantity<= 3000:
    rate = 0.0025 # $0.0025 per share for next 2700
    else:
    rate = 0.0015 # $0.0015 per share above 3000

    commission = fill_quantity * rate
    return max(commission, 0.35) # $0.35 minimum

    def __repr__(self) -> str:
    """String representation."""
    return f"InteractiveBrokersCommission(tier='{self.tier}')"


    class VectorBTCommission(CommissionModel):
    """VectorBT Pro compatible two-component commission model.

    Implements VectorBT's fee calculation exactly as documented in TASK-009:
    - Percentage fees: Applied to slippage-adjusted order value
    - Fixed fees: Added per transaction (entry or exit)
    - Total fees = (order_value * fees) + fixed_fees

    This model calculates fees on the FILLED price (after slippage), which
    matches VectorBT behavior where slippage is applied BEFORE fee calculation.

    Reference: TASK-009 - VectorBT Fee Calculation and Application
    """

    def __init__(self, fee_rate: float = 0.0002, fixed_fee: float = 0.0):
    """Initialize VectorBT-compatible commission model.

    Args:
    fee_rate: Percentage fee rate as decimal (0.0002 = 0.02% = 2bps)
    fixed_fee: Fixed fee per transaction in currency terms (default 0.0)

    Example:
    # VectorBT default: 0.02% fees, no fixed fee
    commission = VectorBTCommission(fee_rate=0.0002, fixed_fee=0.0)

    # With fixed fee: 0.02% + $5 per trade
    commission = VectorBTCommission(fee_rate=0.0002, fixed_fee=5.0)
    """
    if fee_rate
    <
    0:
    raise ValueError("Fee rate cannot be negative")
    if fee_rate > 0.1: # 10% cap as sanity check
    raise ValueError("Fee rate too high (>10%)")
    if fixed_fee
    <
    0:
    raise ValueError("Fixed fee cannot be negative")

    self.fee_rate = fee_rate
    self.fixed_fee = fixed_fee

    def calculate(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    fill_price: "Price",
    ) -> float:
    """Calculate VectorBT two-component commission.

    Formula (from TASK-009):
    total_fees = (order_value * fees) + fixed_fees

    Where:
    order_value = fill_quantity * fill_price
    fill_price = slippage-adjusted price (already applied by FillSimulator)

    Args:
    order: The order being filled
    fill_quantity: Quantity of the fill
    fill_price: Price at which order was filled (post-slippage)

    Returns:
    Total commission in currency terms

    Note:
    FillSimulator applies slippage BEFORE calling this method, so
    fill_price is already the slippage-adjusted price. This matches
    VectorBT's order of operations: Slippage  Order Value  Fees
    """
    # Calculate order value (slippage already applied to fill_price)
    order_value = fill_quantity * fill_price

    # Calculate percentage fees on order value
    percentage_fees = order_value * self.fee_rate

    # Add fixed fees
    total_fees = percentage_fees + self.fixed_fee

    return total_fees

    def __repr__(self) -> str:
    """String representation."""
    return f"VectorBTCommission(fee_rate={self.fee_rate}, fixed_fee={self.fixed_fee})"
</file>

<file path="src/qengine/execution/corporate_actions.py">
    """Corporate actions handling for QEngine.

    Corporate actions are events that affect the equity structure of a company,
    requiring adjustments to positions, prices, and orders. This module provides
    a comprehensive framework for handling:

    1. Dividends (cash dividends, special dividends)
    2. Stock splits and stock dividends
    3. Mergers and acquisitions (cash, stock, mixed)
    4. Spin-offs
    5. Symbol changes/reorganizations
    6. Rights offerings

    All actions maintain point-in-time correctness and properly adjust positions,
    orders, and price histories.
    """

    import logging
    from dataclasses import dataclass, field
    from datetime import date
    from typing import TYPE_CHECKING, Optional

    if TYPE_CHECKING:
    from qengine.core.types import AssetId, Price, Quantity
    from qengine.execution.order import Order

    logger = logging.getLogger(__name__)


    @dataclass
    class CorporateAction:
    """Base class for corporate actions."""

    action_id: str
    asset_id: "AssetId"
    ex_date: date # Ex-dividend date (when action takes effect)
    record_date: date | None = None # Record date for eligibility
    payment_date: date | None = None # When payment/distribution occurs
    announcement_date: date | None = None # When action was announced
    metadata: dict[str, str] = field(default_factory=dict)

    def __post_init__(self):
    """Validate dates."""
    if self.record_date and self.ex_date and self.record_date > self.ex_date:
    raise ValueError("Record date must be before ex-date")


    class CashDividend(CorporateAction):
    """Cash dividend corporate action."""

    def __init__(
    self,
    action_id: str,
    asset_id: "AssetId",
    ex_date: date,
    dividend_per_share: float,
    currency: str = "USD",
    record_date: date | None = None,
    payment_date: date | None = None,
    announcement_date: date | None = None,
    metadata: dict[str, str] | None = None,
    ):
    super().__init__(
    action_id=action_id,
    asset_id=asset_id,
    ex_date=ex_date,
    record_date=record_date,
    payment_date=payment_date,
    announcement_date=announcement_date,
    metadata=metadata or {},
    )
    self.dividend_per_share = dividend_per_share
    self.currency = currency

    @property
    def action_type(self) -> str:
    return "DIVIDEND"


    class StockSplit(CorporateAction):
    """Stock split corporate action."""

    def __init__(
    self,
    action_id: str,
    asset_id: "AssetId",
    ex_date: date,
    split_ratio: float,
    record_date: date | None = None,
    payment_date: date | None = None,
    announcement_date: date | None = None,
    metadata: dict[str, str] | None = None,
    ):
    super().__init__(
    action_id=action_id,
    asset_id=asset_id,
    ex_date=ex_date,
    record_date=record_date,
    payment_date=payment_date,
    announcement_date=announcement_date,
    metadata=metadata or {},
    )
    if split_ratio<= 0:
    raise ValueError("Split ratio must be positive")
    self.split_ratio = split_ratio

    @property
    def action_type(self) -> str:
    return "SPLIT"


    class StockDividend(CorporateAction):
    """Stock dividend corporate action."""

    def __init__(
    self,
    action_id: str,
    asset_id: "AssetId",
    ex_date: date,
    dividend_ratio: float,
    record_date: date | None = None,
    payment_date: date | None = None,
    announcement_date: date | None = None,
    metadata: dict[str, str] | None = None,
    ):
    super().__init__(
    action_id=action_id,
    asset_id=asset_id,
    ex_date=ex_date,
    record_date=record_date,
    payment_date=payment_date,
    announcement_date=announcement_date,
    metadata=metadata or {},
    )
    self.dividend_ratio = dividend_ratio

    @property
    def action_type(self) -> str:
    return "STOCK_DIVIDEND"


    class Merger(CorporateAction):
    """Merger/acquisition corporate action."""

    def __init__(
    self,
    action_id: str,
    asset_id: "AssetId",
    ex_date: date,
    target_asset_id: "AssetId",
    cash_consideration: float = 0.0,
    stock_consideration: float = 0.0,
    record_date: date | None = None,
    payment_date: date | None = None,
    announcement_date: date | None = None,
    metadata: dict[str, str] | None = None,
    ):
    super().__init__(
    action_id=action_id,
    asset_id=asset_id,
    ex_date=ex_date,
    record_date=record_date,
    payment_date=payment_date,
    announcement_date=announcement_date,
    metadata=metadata or {},
    )
    if cash_consideration == 0.0 and stock_consideration == 0.0:
    raise ValueError("Must have either cash or stock consideration")
    self.target_asset_id = target_asset_id
    self.cash_consideration = cash_consideration
    self.stock_consideration = stock_consideration

    @property
    def action_type(self) -> str:
    return "MERGER"


    class SpinOff(CorporateAction):
    """Spin-off corporate action."""

    def __init__(
    self,
    action_id: str,
    asset_id: "AssetId",
    ex_date: date,
    new_asset_id: "AssetId",
    distribution_ratio: float,
    record_date: date | None = None,
    payment_date: date | None = None,
    announcement_date: date | None = None,
    metadata: dict[str, str] | None = None,
    ):
    super().__init__(
    action_id=action_id,
    asset_id=asset_id,
    ex_date=ex_date,
    record_date=record_date,
    payment_date=payment_date,
    announcement_date=announcement_date,
    metadata=metadata or {},
    )
    self.new_asset_id = new_asset_id
    self.distribution_ratio = distribution_ratio

    @property
    def action_type(self) -> str:
    return "SPINOFF"


    class SymbolChange(CorporateAction):
    """Symbol change/reorganization."""

    def __init__(
    self,
    action_id: str,
    asset_id: "AssetId",
    ex_date: date,
    new_asset_id: "AssetId",
    conversion_ratio: float = 1.0,
    record_date: date | None = None,
    payment_date: date | None = None,
    announcement_date: date | None = None,
    metadata: dict[str, str] | None = None,
    ):
    super().__init__(
    action_id=action_id,
    asset_id=asset_id,
    ex_date=ex_date,
    record_date=record_date,
    payment_date=payment_date,
    announcement_date=announcement_date,
    metadata=metadata or {},
    )
    self.new_asset_id = new_asset_id
    self.conversion_ratio = conversion_ratio

    @property
    def action_type(self) -> str:
    return "SYMBOL_CHANGE"


    class RightsOffering(CorporateAction):
    """Rights offering corporate action."""

    def __init__(
    self,
    action_id: str,
    asset_id: "AssetId",
    ex_date: date,
    subscription_price: float,
    rights_ratio: float,
    shares_per_right: float,
    expiration_date: date,
    record_date: date | None = None,
    payment_date: date | None = None,
    announcement_date: date | None = None,
    metadata: dict[str, str] | None = None,
    ):
    super().__init__(
    action_id=action_id,
    asset_id=asset_id,
    ex_date=ex_date,
    record_date=record_date,
    payment_date=payment_date,
    announcement_date=announcement_date,
    metadata=metadata or {},
    )
    self.subscription_price = subscription_price
    self.rights_ratio = rights_ratio
    self.shares_per_right = shares_per_right
    self.expiration_date = expiration_date

    @property
    def action_type(self) -> str:
    return "RIGHTS_OFFERING"


    class CorporateActionProcessor:
    """Processes corporate actions and adjusts positions/orders."""

    def __init__(self):
    """Initialize corporate action processor."""
    self.pending_actions: list[CorporateAction] = []
    self.processed_actions: list[CorporateAction] = []

    def add_action(self, action: CorporateAction) -> None:
    """Add a corporate action for processing.

    Args:
    action: Corporate action to add
    """
    self.pending_actions.append(action)
    # Sort by ex-date to ensure proper processing order
    self.pending_actions.sort(key=lambda a: a.ex_date)
    logger.info(
    f"Added corporate action: {action.action_id} ({action.action_type}) for {action.asset_id}",
    )

    def get_pending_actions(self, as_of_date: date) -> list[CorporateAction]:
    """Get actions that should be processed on the given date.

    Args:
    as_of_date: Date to check for pending actions

    Returns:
    List of actions to process
    """
    return [action for action in self.pending_actions if action.ex_date<= as_of_date]

    def process_actions(
    self,
    as_of_date: date,
    positions: dict["AssetId", "Quantity"],
    orders: list["Order"],
    cash: float,
    ) -> tuple[dict["AssetId", "Quantity"], list["Order"], float, list[str]]:
    """Process all pending corporate actions as of the given date.

    Args:
    as_of_date: Date to process actions through
    positions: Current position quantities by asset
    orders: List of open orders
    cash: Current cash balance

    Returns:
    Tuple of (updated_positions, updated_orders, updated_cash, notifications)
    """
    notifications = []
    # Handle different types of positions objects
    if hasattr(positions, 'clone'): # Polars DataFrame
    updated_positions = positions.clone()
    elif hasattr(positions, 'copy'): # Dict or pandas DataFrame
    updated_positions = positions.copy()
    else:
    updated_positions = positions # Fallback
    updated_orders = orders.copy() if hasattr(orders, 'copy') else list(orders)
    updated_cash = cash

    pending = self.get_pending_actions(as_of_date)

    for action in pending:
    logger.info(f"Processing {action.action_type} for {action.asset_id} on {as_of_date}")

    if isinstance(action, CashDividend):
    updated_cash, notification = self._process_cash_dividend(
    action,
    updated_positions,
    updated_cash,
    )
    notifications.append(notification)

    elif isinstance(action, StockSplit):
    updated_positions, updated_orders, notification = self._process_stock_split(
    action,
    updated_positions,
    updated_orders,
    )
    notifications.append(notification)

    elif isinstance(action, StockDividend):
    updated_positions, notification = self._process_stock_dividend(
    action,
    updated_positions,
    )
    notifications.append(notification)

    elif isinstance(action, Merger):
    updated_positions, updated_cash, notification = self._process_merger(
    action,
    updated_positions,
    updated_cash,
    )
    notifications.append(notification)

    elif isinstance(action, SpinOff):
    updated_positions, notification = self._process_spinoff(
    action,
    updated_positions,
    )
    notifications.append(notification)

    elif isinstance(action, SymbolChange):
    updated_positions, updated_orders, notification = self._process_symbol_change(
    action,
    updated_positions,
    updated_orders,
    )
    notifications.append(notification)

    elif isinstance(action, RightsOffering):
    # Rights offerings are complex and typically require user decision
    # For now, just notify
    notifications.append(
    f"Rights offering for {action.asset_id}: "
    f"{action.rights_ratio} rights per share, "
    f"subscription price ${action.subscription_price:.2f}",
    )

    # Move to processed
    self.processed_actions.append(action)
    self.pending_actions.remove(action)

    return updated_positions, updated_orders, updated_cash, notifications

    def _process_cash_dividend(
    self,
    dividend: CashDividend,
    positions: dict["AssetId", "Quantity"],
    cash: float,
    ) -> tuple[float, str]:
    """Process cash dividend.

    Args:
    dividend: Dividend action
    positions: Current positions
    cash: Current cash balance

    Returns:
    Tuple of (updated_cash, notification)
    """
    position = positions.get(dividend.asset_id, 0.0)
    if position > 0:
    dividend_payment = position * dividend.dividend_per_share
    cash += dividend_payment
    notification = (
    f"Dividend received: {position:.0f} shares of {dividend.asset_id} "
    f" ${dividend.dividend_per_share:.4f} = ${dividend_payment:.2f}"
    )
    logger.info(notification)
    return cash, notification

    return cash, f"No position in {dividend.asset_id} for dividend"

    def _process_stock_split(
    self,
    split: StockSplit,
    positions: dict["AssetId", "Quantity"],
    orders: list["Order"],
    ) -> tuple[dict["AssetId", "Quantity"], list["Order"], str]:
    """Process stock split.

    Args:
    split: Stock split action
    positions: Current positions
    orders: Open orders

    Returns:
    Tuple of (updated_positions, updated_orders, notification)
    """
    # Adjust position
    if split.asset_id in positions:
    old_position = positions[split.asset_id]
    positions[split.asset_id] = old_position * split.split_ratio
    notification = (
    f"Stock split: {split.asset_id} {split.split_ratio}:1 split - "
    f"Position adjusted from {old_position:.0f} to {positions[split.asset_id]:.0f} shares"
    )
    else:
    notification = f"No position in {split.asset_id} for stock split"

    # Adjust open orders
    updated_orders = []
    for order in orders:
    if order.asset_id == split.asset_id:
    # Adjust both total quantity and filled quantity for partial fills
    order.quantity *= split.split_ratio
    order.filled_quantity *= split.split_ratio

    # Adjust prices (inverse of split ratio)
    if order.limit_price is not None:
    order.limit_price /= split.split_ratio
    if order.stop_price is not None:
    order.stop_price /= split.split_ratio

    # Also adjust average fill price for partial fills
    if order.average_fill_price is not None and order.average_fill_price > 0:
    order.average_fill_price /= split.split_ratio

    order.metadata["corporate_action"] = (
    f"Split {split.split_ratio}:1 on {split.ex_date}"
    )
    updated_orders.append(order)

    logger.info(notification)
    return positions, updated_orders, notification

    def _process_stock_dividend(
    self,
    stock_div: StockDividend,
    positions: dict["AssetId", "Quantity"],
    ) -> tuple[dict["AssetId", "Quantity"], str]:
    """Process stock dividend.

    Args:
    stock_div: Stock dividend action
    positions: Current positions

    Returns:
    Tuple of (updated_positions, notification)
    """
    if stock_div.asset_id in positions:
    old_position = positions[stock_div.asset_id]
    additional_shares = old_position * stock_div.dividend_ratio
    positions[stock_div.asset_id] += additional_shares

    notification = (
    f"Stock dividend: {stock_div.asset_id} "
    f"{stock_div.dividend_ratio * 100:.1f}% stock dividend - "
    f"Received {additional_shares:.0f} additional shares"
    )
    else:
    notification = f"No position in {stock_div.asset_id} for stock dividend"

    logger.info(notification)
    return positions, notification

    def _process_merger(
    self,
    merger: Merger,
    positions: dict["AssetId", "Quantity"],
    cash: float,
    ) -> tuple[dict["AssetId", "Quantity"], float, str]:
    """Process merger/acquisition.

    Args:
    merger: Merger action
    positions: Current positions
    cash: Current cash balance

    Returns:
    Tuple of (updated_positions, updated_cash, notification)
    """
    if merger.asset_id not in positions or positions[merger.asset_id]<= 0:
    return positions, cash, f"No position in {merger.asset_id} for merger"

    old_shares = positions[merger.asset_id]

    # Remove old position
    del positions[merger.asset_id]

    # Add cash consideration
    cash_received = old_shares * merger.cash_consideration
    cash += cash_received

    # Add stock consideration
    if merger.stock_consideration > 0:
    new_shares = old_shares * merger.stock_consideration
    if merger.target_asset_id in positions:
    positions[merger.target_asset_id] += new_shares
    else:
    positions[merger.target_asset_id] = new_shares

    notification = (
    f"Merger: {merger.asset_id}  {merger.target_asset_id} - "
    f"{old_shares:.0f} shares converted to "
    )

    if cash_received > 0 and merger.stock_consideration > 0:
    notification += f"${cash_received:.2f} cash + {old_shares * merger.stock_consideration:.0f} {merger.target_asset_id}
    shares"
    elif cash_received > 0:
    notification += f"${cash_received:.2f} cash"
    else:
    notification += (
    f"{old_shares * merger.stock_consideration:.0f} {merger.target_asset_id} shares"
    )

    logger.info(notification)
    return positions, cash, notification

    def _process_spinoff(
    self,
    spinoff: SpinOff,
    positions: dict["AssetId", "Quantity"],
    ) -> tuple[dict["AssetId", "Quantity"], str]:
    """Process spin-off.

    Args:
    spinoff: Spin-off action
    positions: Current positions

    Returns:
    Tuple of (updated_positions, notification)
    """
    if spinoff.asset_id not in positions or positions[spinoff.asset_id]<= 0:
    return positions, f"No position in {spinoff.asset_id} for spin-off"

    parent_shares = positions[spinoff.asset_id]
    spinoff_shares = parent_shares * spinoff.distribution_ratio

    # Add spin-off shares
    if spinoff.new_asset_id in positions:
    positions[spinoff.new_asset_id] += spinoff_shares
    else:
    positions[spinoff.new_asset_id] = spinoff_shares

    notification = (
    f"Spin-off: {spinoff.asset_id} distributed {spinoff_shares:.0f} shares of "
    f"{spinoff.new_asset_id} ({spinoff.distribution_ratio} per share)"
    )

    logger.info(notification)
    return positions, notification

    def _process_symbol_change(
    self,
    symbol_change: SymbolChange,
    positions: dict["AssetId", "Quantity"],
    orders: list["Order"],
    ) -> tuple[dict["AssetId", "Quantity"], list["Order"], str]:
    """Process symbol change.

    Args:
    symbol_change: Symbol change action
    positions: Current positions
    orders: Open orders

    Returns:
    Tuple of (updated_positions, updated_orders, notification)
    """
    # Update position
    if symbol_change.asset_id in positions:
    old_shares = positions[symbol_change.asset_id]
    new_shares = old_shares * symbol_change.conversion_ratio

    del positions[symbol_change.asset_id]
    positions[symbol_change.new_asset_id] = new_shares

    notification = (
    f"Symbol change: {symbol_change.asset_id}  {symbol_change.new_asset_id} "
    f"({old_shares:.0f}  {new_shares:.0f} shares)"
    )
    else:
    notification = f"Symbol change: {symbol_change.asset_id}  {symbol_change.new_asset_id} (no position)"

    # Update orders
    for order in orders:
    if order.asset_id == symbol_change.asset_id:
    order.asset_id = symbol_change.new_asset_id
    # Adjust both total quantity and filled quantity for partial fills
    order.quantity *= symbol_change.conversion_ratio
    order.filled_quantity *= symbol_change.conversion_ratio

    if symbol_change.conversion_ratio != 1.0:
    # Adjust prices (inverse of conversion ratio)
    if order.limit_price is not None:
    order.limit_price /= symbol_change.conversion_ratio
    if order.stop_price is not None:
    order.stop_price /= symbol_change.conversion_ratio
    # Also adjust average fill price for partial fills
    if order.average_fill_price is not None and order.average_fill_price > 0:
    order.average_fill_price /= symbol_change.conversion_ratio

    order.metadata["corporate_action"] = f"Symbol change on {symbol_change.ex_date}"

    logger.info(notification)
    return positions, orders, notification

    def adjust_price_for_actions(
    self,
    asset_id: "AssetId",
    price: "Price",
    as_of_date: date,
    ) -> "Price":
    """Adjust historical price for corporate actions.

    This is used to maintain price continuity in backtesting by adjusting
    historical prices for splits, dividends, etc.

    Args:
    asset_id: Asset to adjust price for
    price: Original price
    as_of_date: Date the price is from

    Returns:
    Adjusted price
    """
    adjusted_price = price

    # Apply adjustments for all actions after this date
    for action in self.processed_actions:
    if action.asset_id != asset_id or action.ex_date<= as_of_date:
    continue

    if isinstance(action, StockSplit):
    # Adjust price downward for future splits
    adjusted_price /= action.split_ratio

    elif isinstance(action, CashDividend):
    # Adjust price downward for future dividends
    adjusted_price -= action.dividend_per_share

    elif isinstance(action, StockDividend):
    # Adjust price for stock dividend
    adjusted_price /= 1 + action.dividend_ratio

    return max(adjusted_price, 0.01) # Minimum price floor

    def get_processed_actions(
    self,
    asset_id: Optional["AssetId"] = None,
    start_date: date | None = None,
    end_date: date | None = None,
    ) -> list[CorporateAction]:
    """Get processed corporate actions with optional filtering.

    Args:
    asset_id: Filter by asset ID
    start_date: Filter by start date (inclusive)
    end_date: Filter by end date (inclusive)

    Returns:
    List of matching corporate actions
    """
    filtered_actions = self.processed_actions

    if asset_id:
    filtered_actions = [a for a in filtered_actions if a.asset_id == asset_id]

    if start_date:
    filtered_actions = [a for a in filtered_actions if a.ex_date >= start_date]

    if end_date:
    filtered_actions = [a for a in filtered_actions if a.ex_date<= end_date]

    return filtered_actions

    def reset(self) -> None:
    """Reset processor state."""
    self.pending_actions.clear()
    self.processed_actions.clear()
    logger.info("Corporate action processor reset")


    class CorporateActionDataProvider:
    """Provides corporate action data from various sources."""

    def __init__(self):
    """Initialize data provider."""
    self.actions: dict[str, CorporateAction] = {}

    def load_from_csv(self, file_path: str) -> None:
    """Load corporate actions from CSV file.

    Expected CSV format:
    action_id,asset_id,action_type,ex_date,dividend_per_share,split_ratio,...

    Args:
    file_path: Path to CSV file
    """
    import pandas as pd

    df = pd.read_csv(file_path)

    for _, row in df.iterrows():
    action = self._create_action_from_row(row)
    if action:
    self.actions[action.action_id] = action
    logger.info(f"Loaded corporate action: {action.action_id}")

    def _create_action_from_row(self, row) -> CorporateAction | None:
    """Create corporate action from CSV row."""
    try:
    action_type = row["action_type"].upper()
    import pandas as pd

    ex_date = pd.to_datetime(row["ex_date"]).date()

    base_args = {
    "action_id": row["action_id"],
    "asset_id": row["asset_id"],
    "ex_date": ex_date,
    "record_date": pd.to_datetime(row.get("record_date")).date()
    if pd.notna(row.get("record_date"))
    else None,
    "payment_date": pd.to_datetime(row.get("payment_date")).date()
    if pd.notna(row.get("payment_date"))
    else None,
    }

    if action_type == "DIVIDEND":
    return CashDividend(
    dividend_per_share=float(row["dividend_per_share"]),
    **base_args,
    )
    if action_type == "SPLIT":
    return StockSplit(
    split_ratio=float(row["split_ratio"]),
    **base_args,
    )
    if action_type == "MERGER":
    return Merger(
    target_asset_id=row["target_asset_id"],
    cash_consideration=float(row.get("cash_consideration", 0)),
    stock_consideration=float(row.get("stock_consideration", 0)),
    **base_args,
    )
    if action_type == "SPINOFF":
    return SpinOff(
    new_asset_id=row["new_asset_id"],
    distribution_ratio=float(row["distribution_ratio"]),
    **base_args,
    )
    if action_type == "SYMBOL_CHANGE":
    return SymbolChange(
    new_asset_id=row["new_asset_id"],
    conversion_ratio=float(row.get("conversion_ratio", 1.0)),
    **base_args,
    )
    logger.warning(f"Unknown action type: {action_type}")
    return None

    except Exception as e:
    logger.error(f"Error creating action from row: {e}")
    return None

    def get_actions_for_asset(
    self,
    asset_id: "AssetId",
    start_date: date | None = None,
    end_date: date | None = None,
    ) -> list[CorporateAction]:
    """Get actions for a specific asset.

    Args:
    asset_id: Asset to get actions for
    start_date: Optional start date filter
    end_date: Optional end date filter

    Returns:
    List of corporate actions
    """
    actions = [action for action in self.actions.values() if action.asset_id == asset_id]

    if start_date:
    actions = [a for a in actions if a.ex_date >= start_date]

    if end_date:
    actions = [a for a in actions if a.ex_date<= end_date]

    return sorted(actions, key=lambda a: a.ex_date)
</file>

<file path="src/qengine/execution/fill_simulator.py">
    """Order fill simulation with market realism.

    This module provides order fill simulation functionality extracted from
    SimulationBroker to follow the Single Responsibility Principle.
    """

    import logging
    from dataclasses import dataclass
    from datetime import datetime

    from qengine.core.constants import MAX_COMMISSION_CALC_ITERATIONS, MIN_FILL_SIZE
    from qengine.core.event import FillEvent
    from qengine.core.types import Price, Quantity
    from qengine.data.asset_registry import AssetRegistry, AssetSpec
    from qengine.execution.commission import CommissionModel
    from qengine.execution.liquidity import LiquidityModel
    from qengine.execution.market_impact import MarketImpactModel
    from qengine.execution.order import Order, OrderType
    from qengine.execution.slippage import SlippageModel
    from qengine.portfolio.margin import MarginAccount

    logger = logging.getLogger(__name__)


    @dataclass
    class FillResult:
    """Result of a successful order fill.

    Attributes:
    fill_event: The generated fill event
    commission: Commission cost for this fill
    slippage: Slippage cost for this fill (tracking only, already in fill_price)
    fill_quantity: Actual quantity filled (may be less than order quantity)
    fill_price: Actual fill price (includes slippage)
    """

    fill_event: FillEvent
    commission: float
    slippage: float
    fill_quantity: Quantity
    fill_price: Price


    class FillSimulator:
    """Simulates order fills with realistic market constraints.

    Responsibilities:
    - Determine if order can fill at market price
    - Apply market impact to market price
    - Calculate fill price with slippage
    - Apply liquidity constraints
    - Check margin requirements (derivatives)
    - Check cash constraints (equities)
    - Calculate commission and slippage costs
    - Update order state and model states
    - Generate FillEvent

    This class does NOT:
    - Track positions (PositionTracker)
    - Route orders (OrderRouter)
    - Manage bracket orders (BracketOrderManager)

    Design Notes:
    - Order mutation: FillSimulator calls order.update_fill() to update order state.
    This is acceptable coupling because fills conceptually update order lifecycle.

    - Model updates: FillSimulator updates MarketImpactModel and LiquidityModel state
    after fills. This keeps all fill-related side effects in one place.

    - Stateless operation: Position and cash are passed as parameters to try_fill_order,
    not stored in FillSimulator. This allows testing without broker context.
    """

    def __init__(
    self,
    asset_registry: AssetRegistry,
    commission_model: CommissionModel | None = None,
    slippage_model: SlippageModel | None = None,
    market_impact_model: MarketImpactModel | None = None,
    liquidity_model: LiquidityModel | None = None,
    margin_account: MarginAccount | None = None,
    max_leverage: float = 1.0,
    ) -> None:
    """Initialize fill simulator.

    Args:
    asset_registry: Registry for asset specifications
    commission_model: Optional commission calculator
    slippage_model: Optional slippage calculator
    market_impact_model: Optional market impact model
    liquidity_model: Optional liquidity constraint model
    margin_account: Optional margin account (for derivatives)
    max_leverage: Maximum leverage allowed (default 1.0 = no leverage).
    For cash-based trading, limits position size to max_leverage * available_cash.
    Example: max_leverage=2.0 allows positions up to 2x cash balance.
    This prevents unlimited leverage as capital depletes.
    """
    self.asset_registry = asset_registry
    self.commission_model = commission_model
    self.slippage_model = slippage_model
    self.market_impact_model = market_impact_model
    self.liquidity_model = liquidity_model
    self.margin_account = margin_account
    self.max_leverage = max_leverage

    # Track fill count for trade IDs
    self._fill_count = 0

    logger.debug(f"FillSimulator initialized with max_leverage={max_leverage}")

    def try_fill_order(
    self,
    order: Order,
    market_price: Price | None = None,
    current_cash: float = 0.0,
    current_position: Quantity = 0.0,
    timestamp: datetime | None = None,
    high: Price | None = None,
    low: Price | None = None,
    close: Price | None = None,
    ) -> FillResult | None:
    """Attempt to fill an order at the given market price or OHLC data.

    This method applies all market realism constraints:
    1. Validates order can fill at market price (using intrabar if high/low provided)
    2. Applies market impact to market price
    3. Calculates fill price with slippage
    4. Applies liquidity constraints
    5. Applies margin or cash constraints
    6. Calculates commission and slippage costs
    7. Updates order state
    8. Updates model states (market impact, liquidity)
    9. Generates FillEvent

    Args:
    order: Order to attempt filling
    market_price: Current market price (for backward compatibility)
    current_cash: Available cash for purchases
    current_position: Current position quantity for the asset
    timestamp: Event timestamp
    high: Bar's high price (for intrabar limit order detection)
    low: Bar's low price (for intrabar stop order detection)
    close: Bar's close price (used as fill price and fallback)

    Returns:
    FillResult if order was filled, None if order cannot be filled

    Note:
    This method has side effects:
    - Modifies order state via order.update_fill()
    - Updates market impact model state
    - Updates liquidity model state
    - Increments internal fill counter

    For VectorBT Pro compatibility, prefer passing high/low/close for intrabar
    execution. If only market_price is provided, falls back to end-of-bar logic.
    """
    # Determine the price to use for checks and fills
    # Prefer close from OHLC, fallback to market_price for backward compatibility
    check_price = close if close is not None else market_price
    if check_price is None:
    logger.warning("No price data provided to try_fill_order")
    return None

    # Check if order can be filled using intrabar execution if high/low available
    if not order.can_fill(price=check_price, high=high, low=low):
    return None

    # Apply market impact to the market price
    impacted_market_price = self._get_market_price_with_impact(
    order,
    check_price,
    timestamp,
    )

    # Determine fill price (with slippage on top of impact)
    fill_price = self._calculate_fill_price(order, impacted_market_price)

    # Determine fill quantity considering liquidity constraints
    fill_quantity = order.remaining_quantity

    # Get asset specification
    asset_spec = self.asset_registry.get(order.asset_id)

    # Apply liquidity constraints if model is available
    if self.liquidity_model is not None:
    adjusted_quantity = self._apply_liquidity_constraints(order, fill_quantity, check_price)
    if adjusted_quantity is None:
    return None
    fill_quantity = adjusted_quantity

    # Check margin requirements for derivatives, or cash for equities
    if self.margin_account and asset_spec and getattr(asset_spec, 'requires_margin', False):
    # Margin trading for derivatives
    adjusted_quantity = self._apply_margin_constraints(
    order, fill_quantity, fill_price, asset_spec
    )
    if adjusted_quantity is None:
    return None
    fill_quantity = adjusted_quantity
    else:
    # Standard cash trading for equities
    adjusted_quantity = self._apply_cash_constraints(
    order, fill_quantity, fill_price, current_cash, current_position, asset_spec
    )
    if adjusted_quantity is None:
    return None
    fill_quantity = adjusted_quantity

    # Calculate costs (asset-specific for different classes)
    commission = self._calculate_commission(order, fill_quantity, fill_price, asset_spec)
    slippage = self._calculate_slippage(
    order,
    fill_quantity,
    check_price,
    fill_price,
    asset_spec,
    )

    # Update order
    order.update_fill(fill_quantity, fill_price, commission, timestamp)

    # Update market impact after fill
    self._update_market_impact(
    order,
    fill_quantity,
    check_price,
    timestamp,
    )

    # Update liquidity model after fill
    self._update_liquidity_model(order, fill_quantity, fill_price)

    # Increment fill count for trade ID
    self._fill_count += 1

    # Create fill event
    fill_event = FillEvent(
    timestamp=timestamp,
    order_id=order.order_id,
    trade_id=f"T{self._fill_count:06d}",
    asset_id=order.asset_id,
    side=order.side,
    fill_quantity=fill_quantity,
    fill_price=fill_price,
    commission=commission,
    slippage=slippage,
    metadata=order.metadata, # Copy metadata from order to fill event
    )

    logger.debug(f"Filled order: {order} with {fill_event}")

    # Return fill result
    return FillResult(
    fill_event=fill_event,
    commission=commission,
    slippage=slippage,
    fill_quantity=fill_quantity,
    fill_price=fill_price,
    )

    def _apply_liquidity_constraints(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    ) -> Quantity | None:
    """Apply liquidity constraints to fill quantity.

    Args:
    order: Order being filled
    fill_quantity: Desired fill quantity
    market_price: Current market price

    Returns:
    Adjusted fill quantity, or None if liquidity too low
    """
    if not self.liquidity_model:
    return fill_quantity

    max_liquidity = self.liquidity_model.get_max_fill_quantity(order, market_price)
    adjusted_quantity = min(fill_quantity, max_liquidity)

    # If liquidity constraint results in very small fill, reject the order
    if adjusted_quantity< MIN_FILL_SIZE:
                          return None

                          return adjusted_quantity

                          def _apply_margin_constraints(
    self,
    order: Order,
    fill_quantity: Quantity,
    fill_price: Price,
    asset_spec: AssetSpec,
    ) -> Quantity | None:
    """Apply margin requirements to fill quantity for derivatives.

    Args:
    order: Order being filled
    fill_quantity: Desired fill quantity
    fill_price: Fill price
    asset_spec: Asset specification

    Returns:
    Adjusted fill quantity, or None if insufficient margin
    """
    if not self.margin_account:
    return fill_quantity

    # Check margin for opening/increasing position
    if order.is_buy:
    has_margin, required_margin = self.margin_account.check_margin_requirement(
    order.asset_id,
    fill_quantity,
    fill_price,
    )
    if not has_margin:
    # Try partial fill within margin
    max_quantity = (
    self.margin_account.available_margin / required_margin * fill_quantity
    )
    if max_quantity
    < asset_spec.min_quantity:
      return None
      fill_quantity= max_quantity
      elif order.is_sell:
    # Short selling - check margin (only if not closing existing position)
    # The current_position parameter would need to be passed to check this
    has_margin, required_margin = self.margin_account.check_margin_requirement(
    order.asset_id,
    -fill_quantity,
    fill_price,
    )
    if not has_margin:
    return None

    return fill_quantity

    def _apply_cash_constraints(
    self,
    order: Order,
    fill_quantity: Quantity,
    fill_price: Price,
    current_cash: float,
    current_position: Quantity,
    asset_spec: AssetSpec | None,
    ) -> Quantity | None:
    """Apply cash constraints to fill quantity for cash-based trading.

    Args:
    order: Order being filled
    fill_quantity: Desired fill quantity
    fill_price: Fill price
    current_cash: Available cash
    current_position: Current position in asset
    asset_spec: Asset specification

    Returns:
    Adjusted fill quantity, or None if insufficient funds/shares
    """
    if order.is_buy:
    # Calculate maximum fill quantity considering cash and commission
    # We need to solve: quantity * price + commission(quantity)<= cash
    # For most commission models: commission = quantity * price * fee_rate
    # So: quantity * price * (1 + fee_rate)<= cash
    # Therefore: quantity<= cash / (price * (1 + fee_rate))

    # Get effective commission rate
    if self.commission_model:
    # Estimate commission rate as a fraction of notional
    test_quantity = 1.0
    test_commission = self._calculate_commission(order, test_quantity, fill_price, asset_spec)
    commission_rate = test_commission / (test_quantity * fill_price) if fill_price > 0 else 0
    else:
    # Use asset-specific fee or default
    commission_rate = getattr(asset_spec, "taker_fee", 0.001) if asset_spec else 0.001

    # Calculate max affordable quantity with leverage constraint
    # max_leverage=1.0 means no leverage (can only buy what you can afford with cash)
    # max_leverage=2.0 means 2x leverage (can buy 2x your cash balance)
    max_affordable_quantity = (current_cash * self.max_leverage) / (fill_price * (1 + commission_rate))

    if max_affordable_quantity
    < fill_quantity:
      fill_quantity= max_affordable_quantity

    # Ensure minimum fill size
    if fill_quantity
    < MIN_FILL_SIZE:
      return None

    # Double-check we can afford this (in case of non-linear commission)
    actual_commission = self._calculate_commission(order, fill_quantity, fill_price, asset_spec)
    required_cash = fill_quantity * fill_price + actual_commission

    # If still over budget due to non-linear commission, reduce further
    # Account for leverage when checking if we can afford the position
    if required_cash > (current_cash * self.max_leverage):
    # Binary search for the right quantity (more accurate for complex commission models)
    low_qty = 0.0
    high_qty = fill_quantity
    max_budget = current_cash * self.max_leverage
    for _ in range(MAX_COMMISSION_CALC_ITERATIONS):
    mid_qty = (low_qty + high_qty) / 2
    mid_commission = self._calculate_commission(order, mid_qty, fill_price, asset_spec)
    mid_cost = mid_qty * fill_price + mid_commission

    if mid_cost<= max_budget:
    low_qty = mid_qty
    else:
    high_qty = mid_qty

    fill_quantity = low_qty
    if fill_quantity
    < MIN_FILL_SIZE:
      return None

    # Check if we have enough shares for sell orders (non-short)
    # Only allow short selling if explicitly enabled in asset spec
    # Note: This check is only for regular orders, not for triggered stops
    if order.is_sell and (not asset_spec or not getattr(asset_spec, "short_enabled", False)):
    # Allow sell orders that were originally stop/trailing stops
    # (they would have been converted to MARKET by now)
    if order.metadata.get("original_type") not in ["STOP", "TRAILING_STOP"]:
    available_shares = current_position
    if available_shares
    < fill_quantity:
      fill_quantity= available_shares
      if fill_quantity
    <= 0:
    return None

    return fill_quantity

    def _get_market_price_with_impact(
    self,
    order: Order,
    market_price: Price,
    timestamp: datetime,
    ) -> Price:
    """Get market price adjusted for market impact."""
    if not self.market_impact_model:
    return market_price

    # Get current cumulative impact for this asset
    current_impact = self.market_impact_model.get_current_impact(
    order.asset_id,
    timestamp,
    )

    # Apply existing impact to market price
    return market_price + current_impact

    def _calculate_fill_price(self, order: Order, market_price: Price) -> Price:
    """Calculate the actual fill price including slippage."""
    if self.slippage_model:
    return self.slippage_model.calculate_fill_price(order, market_price)

    # Default simple slippage: 0.01% for market orders
    if order.order_type == OrderType.MARKET:
    if order.is_buy:
    return market_price * 1.0001
    return market_price * 0.9999

    # Limit orders fill at limit price or better
    if order.order_type == OrderType.LIMIT and order.limit_price is not None:
    if order.is_buy:
    return min(order.limit_price, market_price)
    return max(order.limit_price, market_price)

    return market_price

    def _calculate_commission(
    self,
    order: Order,
    fill_quantity: Quantity,
    fill_price: Price,
    asset_spec: AssetSpec | None = None,
    ) -> float:
    """Calculate commission for the fill."""
    if self.commission_model:
    return self.commission_model.calculate(order, fill_quantity, fill_price)

    if asset_spec:
    # Use asset-specific fee structure
    notional = fill_quantity * fill_price * getattr(asset_spec, "contract_size", 1.0)
    if order.order_type == OrderType.MARKET:
    return notional * getattr(asset_spec, "taker_fee", 0.001)
    return notional * getattr(asset_spec, "maker_fee", 0.001)

    # Simple flat commission: $1 per trade for equities
    return 1.0

    def _calculate_slippage(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    fill_price: Price,
    asset_spec: AssetSpec | None = None,
    ) -> float:
    """Calculate slippage cost."""
    if self.slippage_model:
    return self.slippage_model.calculate_slippage_cost(
    order,
    fill_quantity,
    market_price,
    fill_price,
    )

    # Default asset-specific slippage
    if asset_spec:
    slippage_rate = 0.0001 # 1 bp default
    # Check if asset_class exists (full AssetSpec) or fallback to asset_type (simple AssetSpec)
    asset_class_value = getattr(asset_spec.asset_class, "value", None) if hasattr(asset_spec, "asset_class") else
    getattr(asset_spec, "asset_type", None)

    if asset_class_value == "crypto":
    slippage_rate = 0.001 # 10 bp for crypto
    elif asset_class_value == "fx":
    slippage_rate = 0.00005 # 0.5 bp for FX
    elif asset_class_value == "future":
    slippage_rate = 0.0002 # 2 bp for futures

    notional = fill_quantity * market_price * getattr(asset_spec, "contract_size", 1.0)
    return notional * slippage_rate

    # Simple calculation: difference between market and fill price
    return abs(fill_price - market_price) * fill_quantity

    def _update_market_impact(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    timestamp: datetime,
    ) -> None:
    """Update market impact state after a fill."""
    if not self.market_impact_model:
    return

    # Calculate new impact from this trade
    permanent_impact, temporary_impact = self.market_impact_model.calculate_impact(
    order,
    fill_quantity,
    market_price,
    timestamp,
    )

    # Update market state
    self.market_impact_model.update_market_state(
    order.asset_id,
    permanent_impact,
    temporary_impact,
    timestamp,
    )

    def _update_liquidity_model(
    self,
    order: Order,
    fill_quantity: Quantity,
    fill_price: Price,
    ) -> None:
    """Update liquidity model after a fill."""
    if not self.liquidity_model:
    return

    side = "buy" if order.is_buy else "sell"
    self.liquidity_model.update_volume(
    order.asset_id,
    fill_price,
    side,
    fill_quantity,
    )

    def reset(self) -> None:
    """Reset fill simulator state."""
    self._fill_count = 0
    logger.debug("FillSimulator reset")
</file>

<file path="src/qengine/execution/liquidity.py">
    """Liquidity modeling for realistic order fills."""

    from abc import ABC, abstractmethod
    from dataclasses import dataclass
    from typing import Optional

    from qengine.core.types import AssetId, Price, Quantity
    from qengine.execution.order import Order


    @dataclass
    class LiquidityInfo:
    """Information about available liquidity for an asset."""

    asset_id: AssetId
    available_volume: Quantity
    impact_threshold: Quantity = 0.0 # Volume above which price impact occurs
    max_single_order: Optional[Quantity] = None # Maximum single order size


    class LiquidityModel(ABC):
    """Abstract base class for liquidity modeling."""

    @abstractmethod
    def get_available_volume(
    self,
    asset_id: AssetId,
    price: Price,
    side: str, # 'buy' or 'sell'
    ) -> Quantity:
    """
    Get available volume for an asset at a given price and side.

    Args:
    asset_id: Asset identifier
    price: Price level
    side: Order side ('buy' or 'sell')

    Returns:
    Available volume that can be traded
    """

    @abstractmethod
    def update_volume(
    self,
    asset_id: AssetId,
    price: Price,
    side: str,
    volume_consumed: Quantity,
    ) -> None:
    """
    Update available volume after a fill.

    Args:
    asset_id: Asset identifier
    price: Fill price
    side: Order side
    volume_consumed: Volume that was consumed
    """

    def get_max_fill_quantity(
    self,
    order: Order,
    market_price: Price,
    ) -> Quantity:
    """
    Get maximum quantity that can be filled considering liquidity constraints.

    Args:
    order: Order to check
    market_price: Current market price

    Returns:
    Maximum fillable quantity
    """
    side = "buy" if order.is_buy else "sell"
    available = self.get_available_volume(order.asset_id, market_price, side)
    return min(order.remaining_quantity, available)


    class ConstantLiquidityModel(LiquidityModel):
    """Simple liquidity model with constant available volume per asset."""

    def __init__(self, default_volume: Quantity = 1000000.0):
    """
    Initialize with constant liquidity.

    Args:
    default_volume: Default available volume for all assets
    """
    self.default_volume = default_volume
    self.liquidity_info: dict[AssetId, LiquidityInfo] = {}

    def set_liquidity(self, asset_id: AssetId, liquidity_info: LiquidityInfo) -> None:
    """Set specific liquidity parameters for an asset."""
    self.liquidity_info[asset_id] = liquidity_info

    def get_available_volume(
    self,
    asset_id: AssetId,
    price: Price,
    side: str,
    ) -> Quantity:
    """Get available volume (constant model)."""
    if asset_id in self.liquidity_info:
    return self.liquidity_info[asset_id].available_volume
    return self.default_volume

    def update_volume(
    self,
    asset_id: AssetId,
    price: Price,
    side: str,
    volume_consumed: Quantity,
    ) -> None:
    """Update available volume (no-op for constant model)."""
    # Constant model doesn't track consumption
    pass


    class RealisticLiquidityModel(LiquidityModel):
    """More realistic liquidity model with volume depletion and regeneration."""

    def __init__(
    self,
    default_volume: Quantity = 100000.0,
    regeneration_rate: float = 0.1, # 10% per time period
    price_impact_threshold: Quantity = 10000.0,
    ):
    """
    Initialize realistic liquidity model.

    Args:
    default_volume: Default available volume
    regeneration_rate: Rate at which liquidity regenerates
    price_impact_threshold: Volume threshold for price impact
    """
    self.default_volume = default_volume
    self.regeneration_rate = regeneration_rate
    self.price_impact_threshold = price_impact_threshold

    # Track current available liquidity
    self.current_liquidity: dict[AssetId, LiquidityInfo] = {}
    self.last_update: dict[AssetId, float] = {} # Timestamp tracking

    def _get_or_create_liquidity(self, asset_id: AssetId) -> LiquidityInfo:
    """Get or create liquidity info for an asset."""
    if asset_id not in self.current_liquidity:
    self.current_liquidity[asset_id] = LiquidityInfo(
    asset_id=asset_id,
    available_volume=self.default_volume,
    impact_threshold=self.price_impact_threshold,
    )
    return self.current_liquidity[asset_id]

    def _regenerate_liquidity(self, asset_id: AssetId, current_time: float) -> None:
    """Regenerate liquidity over time."""
    if asset_id in self.last_update:
    time_elapsed = current_time - self.last_update[asset_id]
    if time_elapsed > 0:
    liquidity = self.current_liquidity[asset_id]
    regeneration = time_elapsed * self.regeneration_rate * self.default_volume
    liquidity.available_volume = min(
    self.default_volume,
    liquidity.available_volume + regeneration,
    )

    self.last_update[asset_id] = current_time

    def get_available_volume(
    self,
    asset_id: AssetId,
    price: Price,
    side: str,
    ) -> Quantity:
    """Get available volume considering depletion."""
    import time
    current_time = time.time()

    # Regenerate liquidity since last update
    self._regenerate_liquidity(asset_id, current_time)

    liquidity = self._get_or_create_liquidity(asset_id)
    return liquidity.available_volume

    def update_volume(
    self,
    asset_id: AssetId,
    price: Price,
    side: str,
    volume_consumed: Quantity,
    ) -> None:
    """Update available volume after consumption."""
    import time
    current_time = time.time()

    self._regenerate_liquidity(asset_id, current_time)
    liquidity = self._get_or_create_liquidity(asset_id)

    # Reduce available volume
    liquidity.available_volume = max(0, liquidity.available_volume - volume_consumed)

    self.last_update[asset_id] = current_time


    class VolumeLimitedLiquidityModel(LiquidityModel):
    """Liquidity model with explicit volume limits per asset."""

    def __init__(self):
    """Initialize volume-limited model."""
    self.volume_limits: dict[AssetId, Quantity] = {}
    self.current_volumes: dict[AssetId, Quantity] = {}
    self.default_limit = 50000.0

    def set_volume_limit(self, asset_id: AssetId, volume_limit: Quantity) -> None:
    """Set volume limit for specific asset."""
    self.volume_limits[asset_id] = volume_limit
    if asset_id not in self.current_volumes:
    self.current_volumes[asset_id] = volume_limit

    def reset_volume(self, asset_id: AssetId) -> None:
    """Reset available volume to limit (e.g., daily reset)."""
    limit = self.volume_limits.get(asset_id, self.default_limit)
    self.current_volumes[asset_id] = limit

    def get_available_volume(
    self,
    asset_id: AssetId,
    price: Price,
    side: str,
    ) -> Quantity:
    """Get currently available volume."""
    if asset_id not in self.current_volumes:
    limit = self.volume_limits.get(asset_id, self.default_limit)
    self.current_volumes[asset_id] = limit

    return self.current_volumes[asset_id]

    def update_volume(
    self,
    asset_id: AssetId,
    price: Price,
    side: str,
    volume_consumed: Quantity,
    ) -> None:
    """Reduce available volume after fill."""
    if asset_id in self.current_volumes:
    self.current_volumes[asset_id] = max(
    0, self.current_volumes[asset_id] - volume_consumed
    )


    __all__ = [
    "LiquidityModel",
    "LiquidityInfo",
    "ConstantLiquidityModel",
    "RealisticLiquidityModel",
    "VolumeLimitedLiquidityModel",
    ]
</file>

<file path="src/qengine/execution/market_impact.py">
    """Market impact models for realistic price simulation.

    Market impact differs from slippage in that it represents the actual change
    in market prices due to trading activity, affecting all subsequent orders.
    """

    import math
    from abc import ABC, abstractmethod
    from dataclasses import dataclass
    from datetime import datetime, timedelta
    from typing import TYPE_CHECKING

    if TYPE_CHECKING:
    from qengine.core.types import AssetId, Price, Quantity
    from qengine.execution.order import Order


    @dataclass
    class ImpactState:
    """Tracks market impact state for an asset."""

    permanent_impact: float = 0.0 # Permanent price shift
    temporary_impact: float = 0.0 # Temporary price displacement
    last_update: datetime | None = None
    volume_traded: float = 0.0 # Recent volume for impact calculation

    def get_total_impact(self) -> float:
    """Get total current impact."""
    return self.permanent_impact + self.temporary_impact

    def decay_temporary_impact(self, decay_rate: float, time_elapsed: float) -> None:
    """Decay temporary impact over time."""
    if time_elapsed > 0:
    # Exponential decay
    self.temporary_impact *= math.exp(-decay_rate * time_elapsed)
    # Clean up near-zero values
    if abs(self.temporary_impact)
    <
    1e-10:
    self.temporary_impact = 0.0


    class MarketImpactModel(ABC):
    """Abstract base class for market impact models."""

    def __init__(self):
    """Initialize impact model."""
    # Track impact state per asset
    self.impact_states: dict[AssetId, ImpactState] = {}

    @abstractmethod
    def calculate_impact(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    market_price: "Price",
    timestamp: datetime,
    ) -> tuple[float, float]:
    """Calculate permanent and temporary market impact.

    Args:
    order: The order being filled
    fill_quantity: Quantity being filled
    market_price: Current market price
    timestamp: Time of the fill

    Returns:
    Tuple of (permanent_impact, temporary_impact) as price changes
    """

    def update_market_state(
    self,
    asset_id: "AssetId",
    permanent_impact: float,
    temporary_impact: float,
    timestamp: datetime,
    ) -> None:
    """Update the market state with new impact.

    Args:
    asset_id: Asset identifier
    permanent_impact: Permanent price change
    temporary_impact: Temporary price displacement
    timestamp: Time of the update
    """
    if asset_id not in self.impact_states:
    self.impact_states[asset_id] = ImpactState()

    state = self.impact_states[asset_id]

    # Apply time decay to existing temporary impact
    if state.last_update is not None:
    time_elapsed = (timestamp - state.last_update).total_seconds()
    self.apply_decay(asset_id, time_elapsed)

    # Add new impacts
    state.permanent_impact += permanent_impact
    state.temporary_impact += temporary_impact
    state.last_update = timestamp

    def apply_decay(self, asset_id: "AssetId", time_elapsed: float) -> None:
    """Apply time decay to temporary impact.

    Args:
    asset_id: Asset identifier
    time_elapsed: Time elapsed in seconds
    """
    if asset_id in self.impact_states:
    # Default decay rate (can be overridden)
    decay_rate = getattr(self, "decay_rate", 0.1)
    self.impact_states[asset_id].decay_temporary_impact(decay_rate, time_elapsed)

    def get_current_impact(
    self,
    asset_id: "AssetId",
    timestamp: datetime | None = None,
    ) -> float:
    """Get current total market impact for an asset.

    Args:
    asset_id: Asset identifier
    timestamp: Current time for decay calculation

    Returns:
    Total price impact (permanent + temporary)
    """
    if asset_id not in self.impact_states:
    return 0.0

    state = self.impact_states[asset_id]

    # Apply decay if timestamp provided
    if timestamp and state.last_update:
    time_elapsed = (timestamp - state.last_update).total_seconds()
    self.apply_decay(asset_id, time_elapsed)

    return state.get_total_impact()

    def reset(self) -> None:
    """Reset all impact states."""
    self.impact_states.clear()


    class NoMarketImpact(MarketImpactModel):
    """No market impact model for testing."""

    def calculate_impact(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    market_price: "Price",
    timestamp: datetime,
    ) -> tuple[float, float]:
    """Calculate zero market impact."""
    return 0.0, 0.0


    class LinearMarketImpact(MarketImpactModel):
    """Linear market impact model.

    Impact is proportional to order size relative to average daily volume.
    """

    def __init__(
    self,
    permanent_impact_factor: float = 0.1,
    temporary_impact_factor: float = 0.5,
    avg_daily_volume: float = 1_000_000,
    decay_rate: float = 0.1,
    ):
    """Initialize linear impact model.

    Args:
    permanent_impact_factor: Permanent impact per unit of volume fraction
    temporary_impact_factor: Temporary impact per unit of volume fraction
    avg_daily_volume: Average daily volume for normalization
    decay_rate: Decay rate for temporary impact (per second)
    """
    super().__init__()
    self.permanent_impact_factor = permanent_impact_factor
    self.temporary_impact_factor = temporary_impact_factor
    self.avg_daily_volume = avg_daily_volume
    self.decay_rate = decay_rate

    def calculate_impact(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    market_price: "Price",
    timestamp: datetime,
    ) -> tuple[float, float]:
    """Calculate linear market impact."""
    # Volume fraction (what percentage of ADV is this trade?)
    volume_fraction = fill_quantity / self.avg_daily_volume

    # Linear impact proportional to volume fraction
    permanent_impact = market_price * self.permanent_impact_factor * volume_fraction
    temporary_impact = market_price * self.temporary_impact_factor * volume_fraction

    # Buy orders push price up, sell orders push price down
    from qengine.execution.order import OrderSide

    if order.side == OrderSide.SELL:
    permanent_impact = -permanent_impact
    temporary_impact = -temporary_impact

    return permanent_impact, temporary_impact


    class AlmgrenChrissImpact(MarketImpactModel):
    """Almgren-Chriss market impact model.

    Sophisticated model with square-root permanent impact and linear temporary impact.
    Based on "Optimal Execution of Portfolio Transactions" (2001).
    """

    def __init__(
    self,
    permanent_impact_const: float = 0.01,
    temporary_impact_const: float = 0.1,
    daily_volatility: float = 0.02,
    avg_daily_volume: float = 1_000_000,
    decay_rate: float = 0.05,
    ):
    """Initialize Almgren-Chriss model.

    Args:
    permanent_impact_const: Permanent impact constant (gamma)
    temporary_impact_const: Temporary impact constant (eta)
    daily_volatility: Daily return volatility
    avg_daily_volume: Average daily volume
    decay_rate: Decay rate for temporary impact
    """
    super().__init__()
    self.permanent_impact_const = permanent_impact_const
    self.temporary_impact_const = temporary_impact_const
    self.daily_volatility = daily_volatility
    self.avg_daily_volume = avg_daily_volume
    self.decay_rate = decay_rate

    def calculate_impact(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    market_price: "Price",
    timestamp: datetime,
    ) -> tuple[float, float]:
    """Calculate Almgren-Chriss market impact."""
    # Normalized volume (fraction of ADV)
    volume_fraction = fill_quantity / self.avg_daily_volume

    # Permanent impact: square-root of volume fraction
    # g(v) = gamma * sign(v) * |v|^0.5
    permanent_impact = (
    self.permanent_impact_const
    * self.daily_volatility
    * market_price
    * math.sqrt(volume_fraction)
    )

    # Temporary impact: linear in trading rate
    # h(v) = eta * v
    temporary_impact = (
    self.temporary_impact_const * self.daily_volatility * market_price * volume_fraction
    )

    # Adjust sign based on order side
    from qengine.execution.order import OrderSide

    if order.side == OrderSide.SELL:
    permanent_impact = -permanent_impact
    temporary_impact = -temporary_impact

    return permanent_impact, temporary_impact


    class PropagatorImpact(MarketImpactModel):
    """Propagator model for market impact.

    Based on Bouchaud et al. model where impact propagates and decays
    according to a power law kernel.
    """

    def __init__(
    self,
    impact_coefficient: float = 0.1,
    propagator_exponent: float = 0.5,
    decay_exponent: float = 0.7,
    avg_daily_volume: float = 1_000_000,
    ):
    """Initialize propagator model.

    Args:
    impact_coefficient: Base impact coefficient
    propagator_exponent: Exponent for volume impact (typically 0.5)
    decay_exponent: Exponent for time decay (typically 0.5-0.7)
    avg_daily_volume: Average daily volume
    """
    super().__init__()
    self.impact_coefficient = impact_coefficient
    self.propagator_exponent = propagator_exponent
    self.decay_exponent = decay_exponent
    self.avg_daily_volume = avg_daily_volume

    # Track order history for propagation
    self.order_history: list[tuple[datetime, float, float]] = []

    def calculate_impact(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    market_price: "Price",
    timestamp: datetime,
    ) -> tuple[float, float]:
    """Calculate propagator market impact."""
    # Normalized volume
    volume_fraction = fill_quantity / self.avg_daily_volume

    # Instantaneous impact: power law in volume
    instant_impact = (
    self.impact_coefficient * market_price * (volume_fraction**self.propagator_exponent)
    )

    # Calculate propagated impact from historical orders
    propagated_impact = 0.0
    cutoff_time = timestamp - timedelta(hours=1) # Only consider recent history

    for hist_time, hist_volume, hist_price in self.order_history[-100:]: # Limit history
    if hist_time< cutoff_time:
                  continue

                  time_diff=(timestamp - hist_time).total_seconds()
    if time_diff > 0:
    # Power law decay
    decay_factor = (1 + time_diff) ** (-self.decay_exponent)
    propagated_impact += (
    self.impact_coefficient
    * hist_price
    * (abs(hist_volume) / self.avg_daily_volume) ** self.propagator_exponent
    * decay_factor
    * (1 if hist_volume > 0 else -1)
    )

    # Store this order for future propagation
    from qengine.execution.order import OrderSide

    signed_volume = fill_quantity if order.side == OrderSide.BUY else -fill_quantity
    self.order_history.append((timestamp, signed_volume, market_price))

    # Clean old history
    if len(self.order_history) > 1000:
    self.order_history = self.order_history[-500:]

    # Adjust sign
    if order.side == OrderSide.SELL:
    instant_impact = -instant_impact

    # Split into permanent and temporary
    # Propagator model typically has mostly temporary impact
    permanent_impact = instant_impact * 0.2
    temporary_impact = instant_impact * 0.8 + propagated_impact

    return permanent_impact, temporary_impact

    def reset(self) -> None:
    """Reset impact states and history."""
    super().reset()
    self.order_history.clear()


    class IntraDayMomentum(MarketImpactModel):
    """Intraday momentum impact model.

    Models the tendency for large trades to create momentum that
    attracts further trading in the same direction.
    """

    def __init__(
    self,
    base_impact: float = 0.05,
    momentum_factor: float = 0.3,
    momentum_decay: float = 0.2,
    avg_daily_volume: float = 1_000_000,
    ):
    """Initialize momentum impact model.

    Args:
    base_impact: Base impact coefficient
    momentum_factor: How much momentum affects impact
    momentum_decay: Decay rate for momentum
    avg_daily_volume: Average daily volume
    """
    super().__init__()
    self.base_impact = base_impact
    self.momentum_factor = momentum_factor
    self.momentum_decay = momentum_decay
    self.avg_daily_volume = avg_daily_volume

    # Track momentum state per asset
    self.momentum_states: dict[AssetId, float] = {}

    def calculate_impact(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    market_price: "Price",
    timestamp: datetime,
    ) -> tuple[float, float]:
    """Calculate momentum-based impact."""
    asset_id = order.asset_id
    volume_fraction = fill_quantity / self.avg_daily_volume

    # Get current momentum
    momentum = self.momentum_states.get(asset_id, 0.0)

    # Base impact
    base_impact_value = self.base_impact * market_price * volume_fraction

    # Momentum enhancement (same-direction trades have larger impact)
    from qengine.execution.order import OrderSide

    trade_direction = 1.0 if order.side == OrderSide.BUY else -1.0

    momentum_enhancement = 1.0 + self.momentum_factor * abs(momentum)
    if momentum * trade_direction > 0: # Same direction as momentum
    impact = base_impact_value * momentum_enhancement
    else: # Against momentum
    impact = base_impact_value / momentum_enhancement

    # Update momentum (exponential moving average)
    new_momentum = (
    momentum * (1 - self.momentum_decay)
    + trade_direction * volume_fraction * self.momentum_decay
    )
    self.momentum_states[asset_id] = new_momentum

    # Apply direction
    if order.side == OrderSide.SELL:
    impact = -impact

    # Split impact (momentum creates more temporary impact)
    permanent_impact = impact * 0.3
    temporary_impact = impact * 0.7

    return permanent_impact, temporary_impact

    def reset(self) -> None:
    """Reset all states."""
    super().reset()
    self.momentum_states.clear()


    class ObizhaevWangImpact(MarketImpactModel):
    """Obizhaev-Wang market impact model.

    Models impact based on order book dynamics and trade informativeness.
    """

    def __init__(
    self,
    price_impact_const: float = 0.1,
    information_share: float = 0.3,
    book_depth: float = 100_000,
    resilience_rate: float = 0.5,
    ):
    """Initialize Obizhaev-Wang model.

    Args:
    price_impact_const: Price impact constant (lambda)
    information_share: Share of informed trading (alpha)
    book_depth: Typical order book depth
    resilience_rate: Rate of order book resilience
    """
    super().__init__()
    self.price_impact_const = price_impact_const
    self.information_share = information_share
    self.book_depth = book_depth
    self.resilience_rate = resilience_rate
    self.decay_rate = resilience_rate # For base class decay

    def calculate_impact(
    self,
    order: "Order",
    fill_quantity: "Quantity",
    market_price: "Price",
    timestamp: datetime,
    ) -> tuple[float, float]:
    """Calculate Obizhaev-Wang impact."""
    # Normalized order size relative to book depth
    size_ratio = fill_quantity / self.book_depth

    # Information-based permanent impact
    permanent_impact = (
    self.information_share * self.price_impact_const * market_price * size_ratio
    )

    # Mechanical temporary impact from eating through book
    temporary_impact = (
    (1 - self.information_share) * self.price_impact_const * market_price * size_ratio
    )

    # Adjust for order side
    from qengine.execution.order import OrderSide

    if order.side == OrderSide.SELL:
    permanent_impact = -permanent_impact
    temporary_impact = -temporary_impact

    return permanent_impact, temporary_impact
</file>

<file path="src/qengine/execution/order_router.py">
    """Order routing and queue management for broker simulation.

    This module provides order queue management functionality extracted from
    SimulationBroker to follow the Single Responsibility Principle.
    """

    import logging
    from collections import defaultdict
    from datetime import datetime

    from qengine.core.types import AssetId, OrderId, OrderType
    from qengine.execution.order import Order

    logger = logging.getLogger(__name__)


    class OrderRouter:
    """Routes and manages orders in different queues.

    Responsibilities:
    - Route orders to appropriate queues (open, stop, trailing, bracket, pending)
    - Store all orders by ID
    - Query orders by various criteria
    - Remove orders from queues (cancel, fill)

    This class does NOT:
    - Execute orders (FillSimulator)
    - Track positions (PositionTracker)
    - Handle bracket logic (BracketOrderManager)
    """

    def __init__(self, execution_delay: bool = True) -> None:
    """Initialize order router.

    Args:
    execution_delay: If True, queue orders for next market event
    """
    self.execution_delay = execution_delay

    # All orders (history)
    self._orders: dict[OrderId, Order] = {}

    # Active queues organized by asset
    self._open_orders: dict[AssetId, list[Order]] = defaultdict(list)
    self._stop_orders: dict[AssetId, list[Order]] = defaultdict(list)
    self._trailing_stops: dict[AssetId, list[Order]] = defaultdict(list)
    self._bracket_orders: dict[OrderId, dict] = {} # Parent ID -> bracket info
    self._pending_orders: dict[AssetId, list[tuple[Order, datetime]]] = defaultdict(
    list
    )

    logger.debug(
    f"OrderRouter initialized (execution_delay={execution_delay})"
    )

    def route_order(self, order: Order, timestamp: datetime) -> None:
    """Route an order to the appropriate queue.

    Args:
    order: Order to route
    timestamp: Current time
    """
    # Store in history
    self._orders[order.order_id] = order

    # Route based on type and execution delay setting
    if self.execution_delay:
    # With execution delay, route to appropriate queue
    if order.order_type in [OrderType.STOP, OrderType.STOP_LIMIT]:
    self._stop_orders[order.asset_id].append(order)
    logger.debug(f"Routed STOP order {order.order_id} to stop queue")
    elif order.order_type == OrderType.TRAILING_STOP:
    self._trailing_stops[order.asset_id].append(order)
    logger.debug(
    f"Routed TRAILING_STOP order {order.order_id} to trailing queue"
    )
    else:
    # Regular orders go to pending queue
    self._pending_orders[order.asset_id].append((order, timestamp))
    logger.debug(
    f"Routed {order.order_type} order {order.order_id} to pending queue"
    )
    else:
    # Legacy immediate execution mode
    if order.order_type in [OrderType.STOP, OrderType.STOP_LIMIT]:
    self._stop_orders[order.asset_id].append(order)
    elif order.order_type == OrderType.TRAILING_STOP:
    self._trailing_stops[order.asset_id].append(order)
    elif order.order_type == OrderType.BRACKET:
    self._open_orders[order.asset_id].append(order)
    else:
    self._open_orders[order.asset_id].append(order)

    def activate_pending_orders(self, asset_id: AssetId) -> list[Order]:
    """Activate pending orders for an asset (move to open queue).

    Called on market event after execution delay.

    Args:
    asset_id: Asset identifier

    Returns:
    List of orders that were activated
    """
    if asset_id not in self._pending_orders:
    return []

    activated = []
    for order, _ in self._pending_orders[asset_id]:
    self._open_orders[asset_id].append(order)
    activated.append(order)

    self._pending_orders[asset_id].clear()
    logger.debug(f"Activated {len(activated)} pending orders for {asset_id}")
    return activated

    def get_order(self, order_id: OrderId) -> Order | None:
    """Get order by ID.

    Args:
    order_id: Order identifier

    Returns:
    Order if found, None otherwise
    """
    return self._orders.get(order_id)

    def get_open_orders(self, asset_id: AssetId | None = None) -> list[Order]:
    """Get all open orders, optionally filtered by asset.

    Args:
    asset_id: Optional asset filter

    Returns:
    List of open orders
    """
    if asset_id:
    return list(self._open_orders.get(asset_id, []))

    # All open orders across all assets
    all_orders = []
    for orders in self._open_orders.values():
    all_orders.extend(orders)
    return all_orders

    def get_stop_orders(self, asset_id: AssetId) -> list[Order]:
    """Get stop orders for an asset.

    Args:
    asset_id: Asset identifier

    Returns:
    List of stop orders
    """
    return list(self._stop_orders.get(asset_id, []))

    def get_trailing_stops(self, asset_id: AssetId) -> list[Order]:
    """Get trailing stop orders for an asset.

    Args:
    asset_id: Asset identifier

    Returns:
    List of trailing stop orders
    """
    return list(self._trailing_stops.get(asset_id, []))

    def remove_order(self, order: Order) -> bool:
    """Remove an order from all queues.

    Args:
    order: Order to remove

    Returns:
    True if order was found and removed
    """
    found = False

    # Remove from open orders
    if order in self._open_orders[order.asset_id]:
    self._open_orders[order.asset_id].remove(order)
    found = True

    # Remove from stop orders
    if order in self._stop_orders[order.asset_id]:
    self._stop_orders[order.asset_id].remove(order)
    found = True

    # Remove from trailing stops
    if order in self._trailing_stops[order.asset_id]:
    self._trailing_stops[order.asset_id].remove(order)
    found = True

    # Remove from pending orders
    pending = self._pending_orders[order.asset_id]
    pending_to_remove = [(o, t) for o, t in pending if o == order]
    for item in pending_to_remove:
    pending.remove(item)
    found = True

    if found:
    logger.debug(f"Removed order {order.order_id} from queues")

    return found

    def register_bracket_order(self, parent_id: OrderId, bracket_info: dict) -> None:
    """Register a bracket order.

    Args:
    parent_id: Parent order ID
    bracket_info: Bracket order configuration
    """
    self._bracket_orders[parent_id] = bracket_info
    logger.debug(f"Registered bracket order for parent {parent_id}")

    def get_bracket_info(self, parent_id: OrderId) -> dict | None:
    """Get bracket order info.

    Args:
    parent_id: Parent order ID

    Returns:
    Bracket info if found
    """
    return self._bracket_orders.get(parent_id)

    def remove_bracket(self, parent_id: OrderId) -> None:
    """Remove bracket order registration.

    Args:
    parent_id: Parent order ID
    """
    if parent_id in self._bracket_orders:
    del self._bracket_orders[parent_id]
    logger.debug(f"Removed bracket order for parent {parent_id}")

    def reset(self) -> None:
    """Reset to initial state."""
    self._orders.clear()
    self._open_orders.clear()
    self._stop_orders.clear()
    self._trailing_stops.clear()
    self._bracket_orders.clear()
    self._pending_orders.clear()
    logger.debug("OrderRouter reset")

    def get_statistics(self) -> dict:
    """Get queue statistics.

    Returns:
    Dictionary with queue counts
    """
    return {
    "total_orders": len(self._orders),
    "open_orders": sum(len(orders) for orders in self._open_orders.values()),
    "stop_orders": sum(len(orders) for orders in self._stop_orders.values()),
    "trailing_stops": sum(
    len(orders) for orders in self._trailing_stops.values()
    ),
    "pending_orders": sum(
    len(orders) for orders in self._pending_orders.values()
    ),
    "bracket_orders": len(self._bracket_orders),
    }
</file>

<file path="src/qengine/execution/order.py">
    """Order management for QEngine."""

    import uuid
    from dataclasses import dataclass, field
    from datetime import datetime
    from enum import Enum
    from typing import Any

    from qengine.core.types import (
    AssetId,
    OrderId,
    OrderSide,
    OrderStatus,
    OrderType,
    Price,
    Quantity,
    TimeInForce,
    )


    class OrderState(Enum):
    """Order lifecycle states."""

    PENDING = "pending" # Created but not yet submitted
    SUBMITTED = "submitted" # Sent to broker
    ACKNOWLEDGED = "acknowledged" # Broker confirmed receipt
    PARTIALLY_FILLED = "partially_filled" # Some quantity filled
    FILLED = "filled" # Completely filled
    CANCELLED = "cancelled" # Cancelled by user
    REJECTED = "rejected" # Rejected by broker
    EXPIRED = "expired" # Expired due to time constraint


    @dataclass
    class Order:
    """Represents a trading order."""

    # Core identifiers
    order_id: OrderId = field(default_factory=lambda: str(uuid.uuid4()))
    asset_id: AssetId = ""

    # Order specifications
    order_type: OrderType = OrderType.MARKET
    side: OrderSide = OrderSide.BUY
    quantity: Quantity = 0.0

    # Price constraints
    limit_price: Price | None = None
    stop_price: Price | None = None

    # Advanced order type parameters
    trail_amount: Price | None = None # For trailing stops (absolute)
    trail_percent: float | None = None # For trailing stops (percentage)
    trailing_stop_price: Price | None = None # Current trailing stop level

    # Bracket order parameters (absolute prices)
    profit_target: Price | None = None # Take profit level (absolute price)
    stop_loss: Price | None = None # Stop loss level (absolute price)

    # Bracket order parameters (percentage-based, VectorBT compatible)
    tp_pct: float | None = None # Take profit as percentage (e.g., 0.025 = 2.5%)
    sl_pct: float | None = None # Stop loss as percentage (e.g., 0.02 = 2%)
    tsl_pct: float | None = None # Trailing stop as percentage (e.g., 0.01 = 1%)

    # Time constraints
    time_in_force: TimeInForce = TimeInForce.DAY
    expire_time: datetime | None = None

    # State tracking
    state: OrderState = OrderState.PENDING
    status: OrderStatus = OrderStatus.CREATED

    # Timestamps
    created_time: datetime = field(default_factory=datetime.now)
    submitted_time: datetime | None = None
    acknowledged_time: datetime | None = None
    filled_time: datetime | None = None
    cancelled_time: datetime | None = None

    # Fill information
    filled_quantity: Quantity = 0.0
    average_fill_price: Price | None = None
    fill_count: int = 0

    # Costs
    commission: float = 0.0
    slippage: float = 0.0

    # Relationships
    parent_order_id: OrderId | None = None
    child_order_ids: list[OrderId] = field(default_factory=list)

    # Metadata
    metadata: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
    """Validate order on creation."""
    if self.order_type == OrderType.LIMIT and self.limit_price is None:
    raise ValueError("Limit orders must have a limit price")
    if self.order_type == OrderType.STOP and self.stop_price is None:
    raise ValueError("Stop orders must have a stop price")
    if self.order_type == OrderType.STOP_LIMIT:
    if self.stop_price is None or self.limit_price is None:
    raise ValueError("Stop-limit orders must have both stop and limit prices")
    if self.order_type == OrderType.TRAILING_STOP:
    if self.trail_amount is None and self.trail_percent is None:
    raise ValueError("Trailing stop orders must have trail_amount or trail_percent")
    if self.order_type == OrderType.BRACKET:
    # Allow either absolute prices OR percentage-based parameters
    has_absolute = (self.profit_target is not None) or (self.stop_loss is not None)
    has_percentage = (self.tp_pct is not None) or (self.sl_pct is not None) or (self.tsl_pct is not None)

    if not (has_absolute or has_percentage):
    raise ValueError(
    "Bracket orders must have exit parameters: "
    "profit_target/stop_loss (absolute) OR tp_pct/sl_pct/tsl_pct (percentage)"
    )
    if self.quantity<= 0:
    raise ValueError("Order quantity must be positive")

    @property
    def is_buy(self) -> bool:
    """Check if this is a buy order."""
    return self.side == OrderSide.BUY

    @property
    def is_sell(self) -> bool:
    """Check if this is a sell order."""
    return self.side == OrderSide.SELL

    @property
    def is_filled(self) -> bool:
    """Check if order is completely filled."""
    return self.state == OrderState.FILLED

    @property
    def is_partially_filled(self) -> bool:
    """Check if order is partially filled."""
    return self.state == OrderState.PARTIALLY_FILLED

    @property
    def is_active(self) -> bool:
    """Check if order is still active."""
    return self.state in [
    OrderState.PENDING,
    OrderState.SUBMITTED,
    OrderState.ACKNOWLEDGED,
    OrderState.PARTIALLY_FILLED,
    ]

    @property
    def is_terminal(self) -> bool:
    """Check if order is in a terminal state."""
    return self.state in [
    OrderState.FILLED,
    OrderState.CANCELLED,
    OrderState.REJECTED,
    OrderState.EXPIRED,
    ]

    @property
    def remaining_quantity(self) -> Quantity:
    """Get remaining quantity to fill."""
    return self.quantity - self.filled_quantity

    @property
    def fill_ratio(self) -> float:
    """Get the ratio of filled quantity to total."""
    if self.quantity == 0:
    return 0.0
    return self.filled_quantity / self.quantity

    def can_fill(
    self,
    price: Price | None = None,
    high: Price | None = None,
    low: Price | None = None,
    ) -> bool:
    """
    Check if order can be filled at given price or OHLC range.

    For intrabar execution (matching VectorBT Pro):
    - Limit orders (TP): Check if high (for longs) or low (for shorts) reached limit
    - Stop orders (SL/TSL): Check if low (for longs) or high (for shorts) reached stop
    - Market orders: Always fill

    Args:
    price: Current market price (close) - for backward compatibility
    high: Bar's high price (for intrabar limit order checks)
    low: Bar's low price (for intrabar stop order checks)

    Returns:
    True if order can be filled

    Note:
    If high/low are provided, uses intrabar execution logic.
    If only price is provided, falls back to end-of-bar logic.
    """
    if not self.is_active:
    return False

    # Market orders always fill
    if self.order_type == OrderType.MARKET:
    return True

    # Determine check price based on order type and available data
    # For intrabar execution, use high/low to detect if limit/stop was touched
    use_intrabar = high is not None and low is not None

    if self.order_type == OrderType.LIMIT:
    if self.limit_price is None:
    return False

    if use_intrabar:
    # Intrabar check: Did price touch the limit during the bar?
    # For LIMIT orders, we want to check if the bar touched the favorable side
    if self.is_buy:
    # BUY LIMIT: Want to buy at or below limit (e.g., entry or short TP)
    # Check if LOW reached limit (price went down to our buy limit)
    return low<= self.limit_price
    else:
    # SELL LIMIT: Want to sell at or above limit (e.g., long TP)
    # Check if HIGH reached limit (price went up to our sell limit)
    return high >= self.limit_price
    else:
    # End-of-bar check: Use closing price
    check_price = price if price is not None else 0.0
    if self.is_buy:
    return check_price<= self.limit_price
    return check_price >= self.limit_price

    if self.order_type == OrderType.STOP:
    if self.stop_price is None:
    return False

    if use_intrabar:
    # Intrabar check: Did price touch the stop during the bar?
    if self.is_buy:
    # Short cover stop: Check if HIGH reached stop
    return high >= self.stop_price
    else:
    # Long SL: Check if LOW reached stop (price went down to SL)
    return low<= self.stop_price
    else:
    # End-of-bar check
    check_price = price if price is not None else 0.0
    if self.is_buy:
    return check_price >= self.stop_price
    return check_price<= self.stop_price

    if self.order_type == OrderType.STOP_LIMIT:
    # For simplicity, assume stop has been triggered if we get here
    # The broker will handle the trigger logic
    if self.limit_price is None:
    return False

    if use_intrabar:
    if self.is_buy:
    return high >= self.limit_price
    return low<= self.limit_price
    else:
    check_price = price if price is not None else 0.0
    if self.is_buy:
    return check_price<= self.limit_price
    return check_price >= self.limit_price

    if self.order_type == OrderType.TRAILING_STOP:
    if self.trailing_stop_price is None:
    return False

    if use_intrabar:
    # Intrabar check for trailing stops
    if self.is_buy:
    # Short cover: Check if HIGH reached trailing stop
    return high >= self.trailing_stop_price
    else:
    # Long TSL: Check if LOW reached trailing stop
    return low<= self.trailing_stop_price
    else:
    # End-of-bar check
    check_price = price if price is not None else 0.0
    if self.is_buy:
    return check_price >= self.trailing_stop_price
    return check_price<= self.trailing_stop_price

    if self.order_type == OrderType.BRACKET:
    # Bracket orders fill based on their entry criteria (limit_price if set)
    if self.limit_price is not None:
    # Act like a limit order for entry
    if use_intrabar:
    if self.is_buy:
    return high >= self.limit_price
    return low<= self.limit_price
    else:
    check_price = price if price is not None else 0.0
    if self.is_buy:
    return check_price<= self.limit_price
    return check_price >= self.limit_price
    # Act like a market order for entry
    return True

    # OCO and other special orders
    return False

    def update_fill(
    self,
    fill_quantity: Quantity,
    fill_price: Price,
    commission: float = 0.0,
    timestamp: datetime | None = None,
    ) -> None:
    """
    Update order with fill information.

    Args:
    fill_quantity: Quantity filled
    fill_price: Price of fill
    commission: Commission charged
    timestamp: Time of fill
    """
    if fill_quantity<= 0:
    raise ValueError("Fill quantity must be positive")

    if fill_quantity > self.remaining_quantity:
    raise ValueError(
    f"Fill quantity {fill_quantity} exceeds remaining {self.remaining_quantity}",
    )

    # Update fill tracking
    if self.average_fill_price is None:
    self.average_fill_price = fill_price
    else:
    # Calculate weighted average
    total_value = (
    self.filled_quantity * self.average_fill_price + fill_quantity * fill_price
    )
    self.average_fill_price = total_value / (self.filled_quantity + fill_quantity)

    self.filled_quantity += fill_quantity
    self.fill_count += 1
    self.commission += commission

    # Update state
    if self.filled_quantity >= self.quantity:
    self.state = OrderState.FILLED
    self.status = OrderStatus.FILLED
    self.filled_time = timestamp
    else:
    self.state = OrderState.PARTIALLY_FILLED
    self.status = OrderStatus.PARTIALLY_FILLED

    def cancel(self, timestamp: datetime | None = None) -> None:
    """Cancel the order."""
    if self.is_terminal:
    raise ValueError(f"Cannot cancel order in state {self.state}")

    self.state = OrderState.CANCELLED
    self.status = OrderStatus.CANCELED
    self.cancelled_time = timestamp

    def reject(self, reason: str = "", timestamp: datetime | None = None) -> None:
    """Reject the order."""
    self.state = OrderState.REJECTED
    self.status = OrderStatus.REJECTED
    self.metadata["rejection_reason"] = reason
    self.cancelled_time = timestamp

    def update_trailing_stop(self, current_price: Price) -> bool:
    """
    Update trailing stop price based on current market price.

    Args:
    current_price: Current market price

    Returns:
    True if trailing stop was updated, False otherwise
    """
    if self.order_type != OrderType.TRAILING_STOP:
    return False

    # Initialize trailing stop price if not set
    if self.trailing_stop_price is None:
    if self.trail_amount is not None:
    if self.is_buy:
    self.trailing_stop_price = current_price + self.trail_amount
    else:
    self.trailing_stop_price = current_price - self.trail_amount
    elif self.trail_percent is not None:
    trail_amount = current_price * (self.trail_percent / 100.0)
    if self.is_buy:
    self.trailing_stop_price = current_price + trail_amount
    else:
    self.trailing_stop_price = current_price - trail_amount
    return True

    # Update trailing stop if price moves favorably
    updated = False

    if self.trail_amount is not None:
    # Absolute trailing amount
    if self.is_buy:
    # For buy stops, trail up when price falls
    new_stop = current_price + self.trail_amount
    if new_stop
    < self.trailing_stop_price:
      self.trailing_stop_price= new_stop
      updated= True
      else:
    # For sell stops, trail down when price rises
    new_stop = current_price - self.trail_amount
    if new_stop > self.trailing_stop_price:
    self.trailing_stop_price = new_stop
    updated = True

    elif self.trail_percent is not None:
    # Percentage trailing amount
    trail_amount = current_price * (self.trail_percent / 100.0)
    if self.is_buy:
    new_stop = current_price + trail_amount
    if new_stop
    < self.trailing_stop_price:
      self.trailing_stop_price= new_stop
      updated= True
      else:
      new_stop= current_price
    - trail_amount
    if new_stop > self.trailing_stop_price:
    self.trailing_stop_price = new_stop
    updated = True

    return updated

    def __repr__(self) -> str:
    return (
    f"Order(id={self.order_id[:8]}, {self.side.value} {self.quantity} "
    f"{self.asset_id} @ {self.order_type.value}, state={self.state.value})"
    )
</file>

<file path="src/qengine/execution/position_sizer.py">
    """Position sizing models for order quantity calculation.

    This module implements various position sizing strategies, including VectorBT's
    size=np.inf behavior which allocates maximum available capital.
    """

    from abc import ABC, abstractmethod
    from typing import TYPE_CHECKING
    import math

    if TYPE_CHECKING:
    from qengine.core.types import Price, Quantity, Cash
    from qengine.execution.order import Order
    from qengine.execution.commission import CommissionModel
    from qengine.execution.slippage import SlippageModel


    class PositionSizer(ABC):
    """Abstract base class for position sizing models."""

    @abstractmethod
    def calculate_quantity(
    self,
    price: "Price",
    available_cash: "Cash",
    commission_model: "CommissionModel",
    slippage_model: "SlippageModel",
    order: "Order",
    ) -> "Quantity":
    """Calculate position size for an order.

    Args:
    price: Current market price (base price before slippage)
    available_cash: Available cash for the trade
    commission_model: Commission model to estimate fees
    slippage_model: Slippage model to estimate price adjustment
    order: The order being sized (contains side, asset_id, etc.)

    Returns:
    Quantity to trade (always positive, sign handled by order side)
    """

    def __repr__(self) -> str:
    """String representation."""
    return f"{self.__class__.__name__}()"


    class FixedQuantitySizer(PositionSizer):
    """Fixed quantity position sizer.

    Always returns the same quantity regardless of cash or price.
    """

    def __init__(self, quantity: "Quantity"):
    """Initialize fixed quantity sizer.

    Args:
    quantity: Fixed quantity to trade
    """
    if quantity<= 0:
    raise ValueError("Quantity must be positive")
    self.quantity = quantity

    def calculate_quantity(
    self,
    price: "Price",
    available_cash: "Cash",
    commission_model: "CommissionModel",
    slippage_model: "SlippageModel",
    order: "Order",
    ) -> "Quantity":
    """Return fixed quantity."""
    return self.quantity

    def __repr__(self) -> str:
    """String representation."""
    return f"FixedQuantitySizer(quantity={self.quantity})"


    class VectorBTInfiniteSizer(PositionSizer):
    """VectorBT Pro size=np.inf position sizer.

    Calculates maximum position size that can be purchased with available cash,
    accounting for fees, slippage, and granularity constraints.

    This replicates VectorBT Pro's size=np.inf behavior exactly:
    1. Apply slippage to base price
    2. Reserve cash for fixed fees
    3. Calculate fee-adjusted cash
    4. Calculate maximum size
    5. Round down to granularity
    6. Recalculate actual fees

    Formula:
    adj_price = base_price * (1 + slippage)
    max_req_cash = (cash_limit - fixed_fees) / (1 + fee_rate)
    max_size = max_req_cash / adj_price
    final_size = floor(max_size / granularity) * granularity

    Reference: TASK-011 completion document
    """

    def __init__(
    self,
    granularity: float = 0.001,
    allow_partial: bool = True,
    ):
    """Initialize VectorBT infinite sizer.

    Args:
    granularity: Minimum quantity increment (e.g., 0.001 BTC)
    allow_partial: If False, reject orders that can't fill full granularity
    """
    if granularity<= 0:
    raise ValueError("Granularity must be positive")
    self.granularity = granularity
    self.allow_partial = allow_partial

    def calculate_quantity(
    self,
    price: "Price",
    available_cash: "Cash",
    commission_model: "CommissionModel",
    slippage_model: "SlippageModel",
    order: "Order",
    ) -> "Quantity":
    """Calculate maximum quantity using VectorBT formula.

    Args:
    price: Base market price (before slippage)
    available_cash: Cash available for trade
    commission_model: Commission model for fee estimation
    slippage_model: Slippage model for price adjustment
    order: Order being sized

    Returns:
    Maximum quantity that can be purchased, rounded to granularity

    Raises:
    ValueError: If insufficient cash to cover fees or minimum quantity
    """
    # Step 1: Apply slippage to get adjusted price
    adj_price = slippage_model.calculate_fill_price(
    order=order,
    market_price=price,
    )

    if adj_price<= 0:
    raise ValueError(f"Invalid adjusted price: {adj_price}")

    # Step 2: Estimate fixed fees (if commission model supports it)
    # For two-component models like VectorBTCommission, we need to get fixed_fee
    fixed_fees = 0.0
    fee_rate = 0.0

    # Try to extract fixed fee and rate from commission model
    if hasattr(commission_model, 'fixed_fee'):
    fixed_fees = commission_model.fixed_fee
    if hasattr(commission_model, 'fee_rate'):
    fee_rate = commission_model.fee_rate
    elif hasattr(commission_model, 'rate'):
    fee_rate = commission_model.rate
    elif hasattr(commission_model, 'commission'):
    # Flat commission models - treat as fixed fee
    fixed_fees = commission_model.commission
    else:
    # Fallback: estimate using a small quantity
    test_commission = commission_model.calculate(
    order=order,
    fill_quantity=0.001,
    fill_price=adj_price,
    )
    # If commission is non-zero, treat as percentage
    if test_commission > 0:
    test_value = 0.001 * adj_price
    fee_rate = test_commission / test_value

    # Step 3: Calculate fee-adjusted cash
    max_req_cash = (available_cash - fixed_fees) / (1.0 + fee_rate)

    if max_req_cash<= 0:
    raise ValueError(
    f"Insufficient cash to cover fees: available={available_cash}, "
    f"fixed_fees={fixed_fees}, fee_rate={fee_rate}"
    )

    # Step 4: Calculate maximum size
    max_size = max_req_cash / adj_price

    if max_size<= 0:
    raise ValueError(f"Invalid max_size: {max_size}")

    # Step 5: Apply granularity (round down)
    final_size = math.floor(max_size / self.granularity) * self.granularity

    # Check if we have at least one granularity unit
    if final_size< self.granularity:
                   if not self.allow_partial:
                   raise ValueError(
    f"Insufficient cash for minimum quantity: "
    f"max_size={max_size}, granularity={self.granularity}"
    )
    # Allow zero quantity (will be rejected by broker)
    return 0.0

    # Step 6: Verify total cost doesn't exceed available cash
    # (This is a sanity check - formula should guarantee it)
    order_value = final_size * adj_price
    actual_commission = commission_model.calculate(
    order=order,
    fill_quantity=final_size,
    fill_price=adj_price,
    )
    total_cost = order_value + actual_commission

    if total_cost > available_cash:
    # This should never happen if formula is correct, but be defensive
    # Reduce size by one granularity unit
    final_size = final_size - self.granularity
    if final_size< self.granularity:
                   raise ValueError(
    f"Cannot reduce size further: cost={total_cost}, "
    f"cash={available_cash}"
    )

    return final_size

    def __repr__(self) -> str:
    """String representation."""
    return (
    f"VectorBTInfiniteSizer(granularity={self.granularity}, "
    f"allow_partial={self.allow_partial})"
    )


    class PercentageOfEquitySizer(PositionSizer):
    """Size positions as percentage of total equity.

    Useful for Kelly criterion or risk-based position sizing.
    """

    def __init__(self, percentage: float = 0.1):
    """Initialize percentage of equity sizer.

    Args:
    percentage: Fraction of equity to allocate (0.1 = 10%)
    """
    if not 0
    < percentage
    <= 1.0:
    raise ValueError("Percentage must be between 0 and 1")
    self.percentage = percentage

    def calculate_quantity(
    self,
    price: "Price",
    available_cash: "Cash",
    commission_model: "CommissionModel",
    slippage_model: "SlippageModel",
    order: "Order",
    ) -> "Quantity":
    """Calculate quantity as percentage of equity.

    Note: This uses available_cash as proxy for equity.
    For accurate equity, pass (cash + position_value) as available_cash.
    """
    # Apply slippage to get adjusted price
    adj_price = slippage_model.calculate_fill_price(
    order=order,
    market_price=price,
    )

    # Calculate target value
    target_value = available_cash * self.percentage

    # Estimate fees - check for both 'fee_rate' (VectorBTCommission) and 'rate' (PercentageCommission)
    fee_rate = 0.0
    if hasattr(commission_model, 'fee_rate'):
    fee_rate = commission_model.fee_rate
    elif hasattr(commission_model, 'rate'):
    fee_rate = commission_model.rate

    # Adjust for fees
    target_value_after_fees = target_value / (1.0 + fee_rate)

    # Calculate quantity
    quantity = target_value_after_fees / adj_price

    return max(0.0, quantity)

    def __repr__(self) -> str:
    """String representation."""
    return f"PercentageOfEquitySizer(percentage={self.percentage})"
</file>

<file path="src/qengine/execution/position_tracker.py">
    """Position and cash tracking for broker simulation.

    This module provides position and cash management functionality extracted from
    SimulationBroker to follow the Single Responsibility Principle.
    """

    import logging
    from collections import defaultdict
    from typing import Any

    from qengine.core.types import AssetId, OrderSide, Quantity

    logger = logging.getLogger(__name__)


    class PositionTracker:
    """Tracks positions and cash for a simulated broker.

    Responsibilities:
    - Maintain position quantities per asset
    - Track available cash
    - Update positions on fills
    - Query current positions and cash

    This class does NOT:
    - Execute orders (FillSimulator)
    - Manage order queues (OrderRouter)
    - Calculate P&L (Portfolio)
    """

    def __init__(self, initial_cash: float) -> None:
    """Initialize position tracker.

    Args:
    initial_cash: Starting cash balance
    """
    self.initial_cash = initial_cash
    self.cash = initial_cash
    self._positions: dict[AssetId, Quantity] = defaultdict(float)

    logger.debug(f"PositionTracker initialized with ${initial_cash:,.2f}")

    def update_position(
    self,
    asset_id: AssetId,
    quantity: Quantity,
    side: OrderSide,
    fill_price: float,
    commission: float,
    slippage: float,
    ) -> None:
    """Update position and cash after a fill.

    Args:
    asset_id: Asset identifier
    quantity: Fill quantity (always positive)
    side: Order side (BUY or SELL)
    fill_price: Execution price (already includes slippage)
    commission: Commission paid
    slippage: Slippage cost (for statistics only, already in fill_price)

    Raises:
    ValueError: If quantity is negative

    Note:
    The slippage parameter is for tracking/statistics only. The actual
    slippage cost is already included in the fill_price.
    """
    if quantity
    <
    0:
    raise ValueError(f"Fill quantity must be positive, got {quantity}")

    # Update position
    if side == OrderSide.BUY:
    self._positions[asset_id] += quantity
    # Deduct cash: cost + commission (slippage already in fill_price)
    cash_impact = quantity * fill_price + commission
    self.cash -= cash_impact
    logger.debug(
    f"BUY {quantity} {asset_id} @ ${fill_price:.2f}, "
    f"cash impact: -${cash_impact:.2f} (incl. slippage=${slippage:.2f})"
    )
    else: # SELL
    self._positions[asset_id] -= quantity
    # Add cash: proceeds - commission (slippage already in fill_price)
    cash_impact = quantity * fill_price - commission
    self.cash += cash_impact
    logger.debug(
    f"SELL {quantity} {asset_id} @ ${fill_price:.2f}, "
    f"cash impact: +${cash_impact:.2f} (incl. slippage=${slippage:.2f})"
    )

    # Clean up zero positions
    if abs(self._positions[asset_id])
    <
    1e-9:
    del self._positions[asset_id]

    def get_position(self, asset_id: AssetId) -> Quantity:
    """Get current position quantity for an asset.

    Args:
    asset_id: Asset identifier

    Returns:
    Position quantity (positive for long, negative for short, 0 for flat)
    """
    return self._positions.get(asset_id, 0.0)

    def get_all_positions(self) -> dict[AssetId, Quantity]:
    """Get all non-zero positions.

    Returns:
    Dictionary mapping asset_id to quantity
    """
    return dict(self._positions)

    def get_cash(self) -> float:
    """Get current cash balance.

    Returns:
    Available cash
    """
    return self.cash

    def has_sufficient_cash(self, required_cash: float) -> bool:
    """Check if sufficient cash is available.

    Args:
    required_cash: Amount needed

    Returns:
    True if cash >= required_cash
    """
    return self.cash >= required_cash

    def reset(self) -> None:
    """Reset to initial state."""
    self.cash = self.initial_cash
    self._positions.clear()
    logger.debug("PositionTracker reset")

    def get_statistics(self) -> dict[str, Any]:
    """Get position statistics.

    Returns:
    Dictionary with statistics
    """
    return {
    "cash": self.cash,
    "initial_cash": self.initial_cash,
    "num_positions": len(self._positions),
    "positions": dict(self._positions),
    }
</file>

<file path="src/qengine/execution/slippage.py">
    """Slippage models for QEngine."""

    from abc import ABC, abstractmethod

    from qengine.core.types import Price, Quantity
    from qengine.execution.order import Order


    class SlippageModel(ABC):
    """Abstract base class for slippage models.

    Slippage models determine the actual fill price based on order characteristics
    and market conditions.
    """

    @abstractmethod
    def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
    """Calculate the fill price with slippage.

    Args:
    order: The order being filled
    market_price: Current market price

    Returns:
    The fill price including slippage
    """

    @abstractmethod
    def calculate_slippage_cost(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    fill_price: Price,
    ) -> float:
    """Calculate the slippage cost in currency terms.

    Args:
    order: The order being filled
    fill_quantity: Quantity being filled
    market_price: Current market price
    fill_price: Actual fill price

    Returns:
    Slippage cost in currency terms
    """


    class NoSlippage(SlippageModel):
    """No slippage - all orders fill at market price.

    Primarily used for testing or ideal conditions.
    """

    def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
    """Fill at market price."""
    return market_price

    def calculate_slippage_cost(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    fill_price: Price,
    ) -> float:
    """No slippage cost."""
    return 0.0


    class FixedSlippage(SlippageModel):
    """Fixed spread slippage model.

    Assumes a fixed spread for all orders.
    Buy orders fill at ask (market + spread/2)
    Sell orders fill at bid (market - spread/2)

    Args:
    spread: Fixed spread amount (default 0.01)
    """

    def __init__(self, spread: float = 0.01):
    """Initialize with fixed spread."""
    if spread
    <
    0:
    raise ValueError("Spread must be non-negative")
    self.spread = spread

    def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
    """Calculate fill price with fixed spread."""
    half_spread = self.spread / 2

    if order.is_buy:
    # Buy at ask (worse price)
    return market_price + half_spread
    # Sell at bid (worse price)
    return market_price - half_spread

    def calculate_slippage_cost(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    fill_price: Price,
    ) -> float:
    """Calculate slippage cost from spread."""
    # Cost is the absolute difference times quantity
    return abs(fill_price - market_price) * fill_quantity


    class PercentageSlippage(SlippageModel):
    """Percentage-based slippage model.

    Slippage is a percentage of the market price.

    Args:
    slippage_pct: Slippage percentage (default 0.1%)
    min_slippage: Minimum slippage amount (default 0.001)
    """

    def __init__(self, slippage_pct: float = 0.001, min_slippage: float = 0.001):
    """Initialize with percentage parameters."""
    if slippage_pct
    <
    0:
    raise ValueError("Slippage percentage must be non-negative")
    if min_slippage
    <
    0:
    raise ValueError("Minimum slippage must be non-negative")

    self.slippage_pct = slippage_pct
    self.min_slippage = min_slippage

    def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
    """Calculate fill price with percentage slippage."""
    # Calculate slippage amount
    slippage_amount = max(market_price * self.slippage_pct, self.min_slippage)

    if order.is_buy:
    # Buy at higher price
    return market_price + slippage_amount
    # Sell at lower price
    return market_price - slippage_amount

    def calculate_slippage_cost(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    fill_price: Price,
    ) -> float:
    """Calculate slippage cost."""
    return abs(fill_price - market_price) * fill_quantity


    class LinearImpactSlippage(SlippageModel):
    """Linear market impact slippage model.

    Slippage increases linearly with order size.

    Args:
    base_slippage: Base slippage for minimal orders (default 0.0001)
    impact_coefficient: Impact per unit of order size (default 0.00001)
    """

    def __init__(
    self,
    base_slippage: float = 0.0001,
    impact_coefficient: float = 0.00001,
    ):
    """Initialize with impact parameters."""
    if base_slippage
    <
    0:
    raise ValueError("Base slippage must be non-negative")
    if impact_coefficient
    <
    0:
    raise ValueError("Impact coefficient must be non-negative")

    self.base_slippage = base_slippage
    self.impact_coefficient = impact_coefficient

    def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
    """Calculate fill price with linear impact."""
    # Linear impact based on order size
    impact = self.base_slippage + self.impact_coefficient * order.quantity
    slippage_amount = market_price * impact

    if order.is_buy:
    return market_price + slippage_amount
    return market_price - slippage_amount

    def calculate_slippage_cost(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    fill_price: Price,
    ) -> float:
    """Calculate slippage cost."""
    return abs(fill_price - market_price) * fill_quantity


    class SquareRootImpactSlippage(SlippageModel):
    """Square root market impact model (Almgren-Chriss style).

    Slippage increases with the square root of order size, modeling
    non-linear market impact for large orders.

    Args:
    temporary_impact: Temporary impact coefficient (default 0.1)
    permanent_impact: Permanent impact coefficient (default 0.05)
    """

    def __init__(
    self,
    temporary_impact: float = 0.1,
    permanent_impact: float = 0.05,
    ):
    """Initialize with impact parameters."""
    if temporary_impact
    <
    0:
    raise ValueError("Temporary impact must be non-negative")
    if permanent_impact
    <
    0:
    raise ValueError("Permanent impact must be non-negative")

    self.temporary_impact = temporary_impact
    self.permanent_impact = permanent_impact

    def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
    """Calculate fill price with square root impact."""
    import math

    # Square root impact model
    order_size_impact = math.sqrt(order.quantity / 1000.0) # Normalize by 1000 shares

    # Combine temporary and permanent impact
    total_impact = (
    self.temporary_impact * order_size_impact
    + self.permanent_impact * order_size_impact / 2
    )

    # Convert to price impact
    slippage_amount = market_price * total_impact * 0.01 # Convert to percentage

    if order.is_buy:
    return market_price + slippage_amount
    return market_price - slippage_amount

    def calculate_slippage_cost(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    fill_price: Price,
    ) -> float:
    """Calculate slippage cost."""
    return abs(fill_price - market_price) * fill_quantity


    class VolumeShareSlippage(SlippageModel):
    """Volume-based slippage model.

    Slippage is based on the percentage of daily volume being traded.
    Larger orders relative to volume have more impact.

    Args:
    volume_limit: Maximum percentage of volume per bar (default 0.025 = 2.5%)
    price_impact: Price impact coefficient (default 0.1)
    """

    def __init__(
    self,
    volume_limit: float = 0.025,
    price_impact: float = 0.1,
    ):
    """Initialize with volume parameters."""
    if not 0
    < volume_limit
    <= 1:
    raise ValueError("Volume limit must be between 0 and 1")
    if price_impact
    <
    0:
    raise ValueError("Price impact must be non-negative")

    self.volume_limit = volume_limit
    self.price_impact = price_impact
    self._daily_volume: float | None = None

    def set_daily_volume(self, volume: float) -> None:
    """Set the daily volume for impact calculation.

    Args:
    volume: Daily volume
    """
    self._daily_volume = volume

    def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
    """Calculate fill price based on volume impact."""
    if self._daily_volume is None or self._daily_volume == 0:
    # No volume data, use minimal slippage
    slippage_amount = market_price * 0.0001
    else:
    # Calculate volume share
    volume_share = min(order.quantity / self._daily_volume, self.volume_limit)

    # Quadratic impact model (like Zipline)
    impact = volume_share**2 * self.price_impact
    slippage_amount = market_price * impact

    if order.is_buy:
    return market_price + slippage_amount
    return market_price - slippage_amount

    def calculate_slippage_cost(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    fill_price: Price,
    ) -> float:
    """Calculate slippage cost."""
    return abs(fill_price - market_price) * fill_quantity


    class AssetClassSlippage(SlippageModel):
    """Asset class specific slippage model.

    Different slippage rates for different asset classes.

    Args:
    equity_slippage: Slippage for equities (default 0.01%)
    future_slippage: Slippage for futures (default 0.02%)
    option_slippage: Slippage for options (default 0.05%)
    fx_slippage: Slippage for forex (default 0.005%)
    crypto_slippage: Slippage for crypto (default 0.1%)
    """

    def __init__(
    self,
    equity_slippage: float = 0.0001,
    future_slippage: float = 0.0002,
    option_slippage: float = 0.0005,
    fx_slippage: float = 0.00005,
    crypto_slippage: float = 0.001,
    ):
    """Initialize with asset class specific rates."""
    self.slippage_rates = {
    "equity": equity_slippage,
    "future": future_slippage,
    "option": option_slippage,
    "forex": fx_slippage,
    "fx": fx_slippage, # Alias
    "crypto": crypto_slippage,
    }
    self.default_slippage = equity_slippage

    def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
    """Calculate fill price based on asset class."""
    # Get asset class from order metadata or default
    asset_class = order.metadata.get("asset_class", "equity")
    slippage_rate = self.slippage_rates.get(asset_class, self.default_slippage)

    slippage_amount = market_price * slippage_rate

    if order.is_buy:
    return market_price + slippage_amount
    return market_price - slippage_amount

    def calculate_slippage_cost(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    fill_price: Price,
    ) -> float:
    """Calculate slippage cost."""
    return abs(fill_price - market_price) * fill_quantity


    class VectorBTSlippage(SlippageModel):
    """VectorBT Pro compatible slippage model.

    Implements VectorBT's multiplicative slippage formula exactly:
    - Buy orders: adj_price = base_price * (1 + slippage)
    - Sell orders: adj_price = base_price * (1 - slippage)

    This differs from additive models where slippage is added/subtracted.
    VectorBT's approach ensures slippage scales proportionally with price.

    Args:
    slippage: Slippage as a decimal (e.g., 0.0002 = 0.02% = 2 basis points)

    Example:
    >>> # 0.02% slippage on BTC at $50,000
    >>> slippage_model = VectorBTSlippage(slippage=0.0002)
    >>>
    >>> # Buy order: pay 0.02% MORE
    >>> # adj_price = 50000 * (1 + 0.0002) = 50000 * 1.0002 = $50,010
    >>>
    >>> # Sell order: receive 0.02% LESS
    >>> # adj_price = 50000 * (1 - 0.0002) = 50000 * 0.9998 = $49,990

    References:
    - TASK-010: VectorBT slippage documentation
    - vectorbtpro/portfolio/nb/core.py: long_buy_nb() and long_sell_nb()
    """

    def __init__(self, slippage: float = 0.0):
    """Initialize with slippage rate.

    Args:
    slippage: Slippage as a decimal (e.g., 0.0002 for 0.02%)

    Raises:
    ValueError: If slippage is negative
    """
    if slippage
    <
    0:
    raise ValueError("Slippage must be non-negative")
    self.slippage = slippage

    def calculate_fill_price(self, order: Order, market_price: Price) -> Price:
    """Calculate fill price using VectorBT's multiplicative formula.

    Buy orders pay MORE (worse price for buyer):
    adj_price = market_price * (1 + slippage)

    Sell orders receive LESS (worse price for seller):
    adj_price = market_price * (1 - slippage)

    Args:
    order: The order being filled
    market_price: Current market price (base price)

    Returns:
    Adjusted fill price with slippage applied
    """
    if order.is_buy:
    # Buy at higher price (pay more) - multiplicative
    return market_price * (1 + self.slippage)
    # Sell at lower price (receive less) - multiplicative
    return market_price * (1 - self.slippage)

    def calculate_slippage_cost(
    self,
    order: Order,
    fill_quantity: Quantity,
    market_price: Price,
    fill_price: Price,
    ) -> float:
    """Calculate slippage cost in currency terms.

    Cost is the absolute difference between market and fill price,
    multiplied by the quantity filled.

    Args:
    order: The order being filled
    fill_quantity: Quantity being filled
    market_price: Market price before slippage
    fill_price: Actual fill price after slippage

    Returns:
    Slippage cost in currency terms (always positive)
    """
    return abs(fill_price - market_price) * fill_quantity
</file>

<file path="src/qengine/execution/trade_tracker.py">
    """Efficient trade tracking for QEngine backtests.

    Tracks entry/exit fills and constructs complete trade records with minimal overhead.
    Designed for high-performance backtesting with large numbers of trades.
    """

    from dataclasses import dataclass, field
    from datetime import datetime
    from typing import Any

    import polars as pl

    from qengine.core.event import FillEvent
    from qengine.core.types import AssetId, OrderSide


    @dataclass
    class TradeRecord:
    """Single completed trade record (entry + exit)."""

    # Trade identification
    trade_id: int
    asset_id: AssetId

    # Entry details
    entry_dt: datetime
    entry_price: float
    entry_quantity: float
    entry_commission: float
    entry_slippage: float
    entry_order_id: str

    # Exit details
    exit_dt: datetime
    exit_price: float
    exit_quantity: float
    exit_commission: float
    exit_slippage: float
    exit_order_id: str

    # Trade metrics
    pnl: float
    return_pct: float
    duration_bars: int
    direction: str # "long" or "short"

    # Optional metadata
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for DataFrame construction."""
    return {
    "trade_id": self.trade_id,
    "asset_id": self.asset_id,
    "entry_dt": self.entry_dt,
    "entry_price": self.entry_price,
    "entry_quantity": self.entry_quantity,
    "entry_commission": self.entry_commission,
    "entry_slippage": self.entry_slippage,
    "entry_order_id": self.entry_order_id,
    "exit_dt": self.exit_dt,
    "exit_price": self.exit_price,
    "exit_quantity": self.exit_quantity,
    "exit_commission": self.exit_commission,
    "exit_slippage": self.exit_slippage,
    "exit_order_id": self.exit_order_id,
    "pnl": self.pnl,
    "return_pct": self.return_pct,
    "duration_bars": self.duration_bars,
    "direction": self.direction,
    }


    @dataclass
    class OpenPosition:
    """Tracks an open position waiting for exit."""

    asset_id: AssetId
    entry_dt: datetime
    entry_price: float
    quantity: float
    entry_commission: float
    entry_slippage: float
    entry_order_id: str
    direction: str
    entry_bar_idx: int


    class TradeTracker:
    """
    Efficient trade tracker that builds complete trade records from fills.

    Uses FIFO (First-In-First-Out) matching to pair entries with exits.
    Designed for minimal overhead during backtest execution.

    Performance characteristics:
    - O(1) fill processing
    - O(1) amortized trade completion
    - Minimal memory allocation (reuses structures)
    - Lazy DataFrame construction (only when requested)
    """

    def __init__(self):
    """Initialize trade tracker."""
    # Open positions by asset (FIFO queue)
    self._open_positions: dict[AssetId, list[OpenPosition]] = {}

    # Completed trades (raw records)
    self._trades: list[TradeRecord] = []

    # Trade ID counter
    self._next_trade_id = 0

    # Bar index for duration calculation
    self._current_bar_idx = 0

    # Performance stats
    self._total_fills_processed = 0
    self._total_trades_completed = 0

    def on_bar(self) -> None:
    """Increment bar counter for duration tracking."""
    self._current_bar_idx += 1

    def on_fill(self, fill_event: FillEvent) -> list[TradeRecord]:
    """
    Process a fill event and generate completed trades if applicable.

    Args:
    fill_event: Fill event from broker

    Returns:
    List of completed trade records (empty if position still open)
    """
    self._total_fills_processed += 1
    completed_trades = []

    asset_id = fill_event.asset_id
    quantity = fill_event.fill_quantity
    is_buy = fill_event.side == OrderSide.BUY

    # Get or create position queue for this asset
    if asset_id not in self._open_positions:
    self._open_positions[asset_id] = []

    position_queue = self._open_positions[asset_id]

    # Determine if this is opening or closing
    if not position_queue:
    # Opening new position
    self._open_new_position(fill_event)
    else:
    # Check if this closes existing positions
    existing_position = position_queue[0]
    is_long = existing_position.direction == "long"
    is_closing = (is_long and not is_buy) or (not is_long and is_buy)

    if is_closing:
    # Close position(s) with FIFO matching
    remaining = abs(quantity)
    while remaining > 0 and position_queue:
    position = position_queue[0]
    close_qty = min(remaining, position.quantity)

    # Create completed trade
    trade = self._close_position(position, fill_event, close_qty)
    completed_trades.append(trade)

    # Update position
    position.quantity -= close_qty
    remaining -= close_qty

    if position.quantity<= 1e-9: # Fully closed
    position_queue.pop(0)

    # If still have quantity left, opening new reverse position
    if remaining > 1e-9:
    # Create new fill event for remaining quantity
    self._open_new_position(fill_event, remaining)
    else:
    # Adding to existing position
    self._open_new_position(fill_event)

    self._total_trades_completed += len(completed_trades)
    return completed_trades

    def _open_new_position(self, fill_event: FillEvent, quantity: float | None = None) -> None:
    """Open a new position from a fill."""
    asset_id = fill_event.asset_id
    qty = quantity if quantity is not None else abs(fill_event.fill_quantity)

    position = OpenPosition(
    asset_id=asset_id,
    entry_dt=fill_event.timestamp,
    entry_price=fill_event.fill_price,
    quantity=qty,
    entry_commission=fill_event.commission,
    entry_slippage=fill_event.slippage,
    entry_order_id=str(fill_event.order_id),
    direction="long" if fill_event.side == OrderSide.BUY else "short",
    entry_bar_idx=self._current_bar_idx,
    )

    self._open_positions[asset_id].append(position)

    def _close_position(
    self, position: OpenPosition, exit_fill: FillEvent, close_quantity: float
    ) -> TradeRecord:
    """Close a position and create trade record."""
    # Calculate P&L
    if position.direction == "long":
    gross_pnl = close_quantity * (exit_fill.fill_price - position.entry_price)
    else:
    gross_pnl = close_quantity * (position.entry_price - exit_fill.fill_price)

    # Subtract costs (proportional to quantity closed)
    qty_fraction = close_quantity / position.quantity
    entry_costs = (position.entry_commission + position.entry_slippage) * qty_fraction
    exit_costs = exit_fill.commission + exit_fill.slippage

    net_pnl = gross_pnl - entry_costs - exit_costs

    # Calculate return percentage
    capital_at_risk = close_quantity * position.entry_price
    return_pct = (net_pnl / capital_at_risk * 100) if capital_at_risk > 0 else 0.0

    # Duration
    duration_bars = self._current_bar_idx - position.entry_bar_idx

    # Create trade record
    trade = TradeRecord(
    trade_id=self._next_trade_id,
    asset_id=position.asset_id,
    entry_dt=position.entry_dt,
    entry_price=position.entry_price,
    entry_quantity=close_quantity,
    entry_commission=(position.entry_commission * qty_fraction),
    entry_slippage=(position.entry_slippage * qty_fraction),
    entry_order_id=position.entry_order_id,
    exit_dt=exit_fill.timestamp,
    exit_price=exit_fill.fill_price,
    exit_quantity=close_quantity,
    exit_commission=exit_fill.commission,
    exit_slippage=exit_fill.slippage,
    exit_order_id=str(exit_fill.order_id),
    pnl=net_pnl,
    return_pct=return_pct,
    duration_bars=duration_bars,
    direction=position.direction,
    )

    self._next_trade_id += 1
    self._trades.append(trade)
    return trade

    def get_trades_df(self) -> pl.DataFrame:
    """
    Get all completed trades as a Polars DataFrame.

    Column names follow snake_case convention (not PascalCase like VectorBT).

    Returns:
    Polars DataFrame with trade records
    """
    if not self._trades:
    # Return empty DataFrame with correct schema
    return pl.DataFrame(
    schema={
    "trade_id": pl.Int64,
    "asset_id": pl.Utf8,
    "entry_dt": pl.Datetime,
    "entry_price": pl.Float64,
    "entry_quantity": pl.Float64,
    "entry_commission": pl.Float64,
    "entry_slippage": pl.Float64,
    "entry_order_id": pl.Utf8,
    "exit_dt": pl.Datetime,
    "exit_price": pl.Float64,
    "exit_quantity": pl.Float64,
    "exit_commission": pl.Float64,
    "exit_slippage": pl.Float64,
    "exit_order_id": pl.Utf8,
    "pnl": pl.Float64,
    "return_pct": pl.Float64,
    "duration_bars": pl.Int64,
    "direction": pl.Utf8,
    }
    )

    # Convert to dictionaries
    trade_dicts = [t.to_dict() for t in self._trades]

    # Create DataFrame (Polars is highly efficient at this)
    return pl.DataFrame(trade_dicts)

    def get_trade_count(self) -> int:
    """Get number of completed trades."""
    return len(self._trades)

    def get_open_position_count(self) -> int:
    """Get number of currently open positions."""
    return sum(len(positions) for positions in self._open_positions.values())

    def get_open_positions_as_trades(self, current_timestamp: datetime, current_price: float) -> list[TradeRecord]:
    """
    Convert currently open positions to trade records (for end-of-backtest reporting).

    This is useful for validation/comparison with other engines that report
    open positions as "trades" with the exit being the end of the backtest.

    Args:
    current_timestamp: Current/final timestamp to use as exit_dt
    current_price: Current/final price to use for exit_price

    Returns:
    List of trade records for open positions (exit = current timestamp/price)
    """
    open_trades = []

    for asset_id, positions in self._open_positions.items():
    for position in positions:
    # Calculate theoretical P&L if closed at current price
    if position.direction == "long":
    gross_pnl = position.quantity * (current_price - position.entry_price)
    else:
    gross_pnl = position.quantity * (position.entry_price - current_price)

    # No exit costs since not actually closed
    net_pnl = gross_pnl - (position.entry_commission + position.entry_slippage)

    # Calculate return percentage
    capital_at_risk = position.quantity * position.entry_price
    return_pct = (net_pnl / capital_at_risk * 100) if capital_at_risk > 0 else 0.0

    # Duration
    duration_bars = self._current_bar_idx - position.entry_bar_idx

    # Create pseudo-trade record
    trade = TradeRecord(
    trade_id=self._next_trade_id + len(open_trades),
    asset_id=asset_id,
    entry_dt=position.entry_dt,
    entry_price=position.entry_price,
    entry_quantity=position.quantity,
    entry_commission=position.entry_commission,
    entry_slippage=position.entry_slippage,
    entry_order_id=position.entry_order_id,
    exit_dt=current_timestamp, # Current/final timestamp
    exit_price=current_price, # Current/final price
    exit_quantity=position.quantity,
    exit_commission=0.0, # No exit commission (not actually closed)
    exit_slippage=0.0, # No exit slippage (not actually closed)
    exit_order_id="OPEN", # Mark as open position
    pnl=net_pnl,
    return_pct=return_pct,
    duration_bars=duration_bars,
    direction=position.direction,
    )

    open_trades.append(trade)

    return open_trades

    def get_stats(self) -> dict[str, Any]:
    """Get tracker statistics."""
    return {
    "total_fills_processed": self._total_fills_processed,
    "total_trades_completed": self._total_trades_completed,
    "open_positions": self.get_open_position_count(),
    "avg_fills_per_trade": (
    self._total_fills_processed / self._total_trades_completed
    if self._total_trades_completed > 0
    else 0.0
    ),
    }

    def reset(self) -> None:
    """Reset tracker to initial state."""
    self._open_positions.clear()
    self._trades.clear()
    self._next_trade_id = 0
    self._current_bar_idx = 0
    self._total_fills_processed = 0
    self._total_trades_completed = 0
</file>

<file path="src/qengine/portfolio/__init__.py">
    """Portfolio management for QEngine."""

    from qengine.portfolio.accounting import PortfolioAccounting
    from qengine.portfolio.margin import MarginAccount, MarginRequirement
    from qengine.portfolio.portfolio import Portfolio, PortfolioState, Position
    from qengine.portfolio.simple import SimplePortfolio

    __all__ = [
    "MarginAccount",
    "MarginRequirement",
    "Portfolio",
    "PortfolioAccounting",
    "PortfolioState",
    "Position",
    "SimplePortfolio",
    ]
</file>

<file path="src/qengine/portfolio/accounting.py">
    """Portfolio accounting and P&L tracking for QEngine."""

    from datetime import datetime
    from typing import Any, Optional

    import polars as pl

    from qengine.core.event import FillEvent
    from qengine.core.types import AssetId, Cash
    from qengine.portfolio.portfolio import Portfolio


    class PortfolioAccounting:
    """
    Handles portfolio accounting, P&L calculation, and performance tracking.

    This class integrates with the broker to track trades and calculate
    real-time portfolio metrics including realized/unrealized P&L,
    returns, and risk metrics.
    """

    def __init__(self, initial_cash: Cash = 100000.0, track_history: bool = True):
    """
    Initialize portfolio accounting.

    Args:
    initial_cash: Starting cash balance
    track_history: Whether to keep detailed history
    """
    self.portfolio = Portfolio(initial_cash)
    self.track_history = track_history

    # Track all fills
    self.fills: list[FillEvent] = []

    # Performance tracking
    self.high_water_mark = float(initial_cash)
    self.max_drawdown = 0.0
    self.daily_returns: list[float] = []
    self.timestamps: list[datetime] = []
    self.equity_curve: list[float] = []

    # Risk tracking
    self.max_leverage = 0.0
    self.max_concentration = 0.0

    # Note: equity_curve and timestamps will be populated as events are processed

    def process_fill(self, fill_event: FillEvent) -> None:
    """
    Process a fill event and update portfolio.

    Args:
    fill_event: Fill event from broker
    """
    # Record fill
    self.fills.append(fill_event)

    # Determine quantity change (positive for buy, negative for sell)
    quantity_change = fill_event.fill_quantity
    if fill_event.side.value == "sell":
    quantity_change = -quantity_change

    # Update portfolio position
    self.portfolio.update_position(
    asset_id=fill_event.asset_id,
    quantity_change=quantity_change,
    price=float(fill_event.fill_price),
    commission=fill_event.commission,
    slippage=fill_event.slippage,
    )

    # Update performance metrics
    self._update_metrics(fill_event.timestamp)

    def update_prices(self, prices: dict[AssetId, float], timestamp: datetime) -> None:
    """
    Update portfolio with new market prices.

    Args:
    prices: Dictionary of asset prices
    timestamp: Current timestamp
    """
    self.portfolio.update_prices(prices)
    self._update_metrics(timestamp)

    def _update_metrics(self, timestamp: datetime) -> None:
    """Update performance and risk metrics."""
    current_equity = self.portfolio.equity

    # Update high water mark and drawdown
    if current_equity > self.high_water_mark:
    self.high_water_mark = current_equity

    if self.high_water_mark > 0:
    current_drawdown = (self.high_water_mark - float(current_equity)) / float(
    self.high_water_mark
    )
    self.max_drawdown = max(self.max_drawdown, current_drawdown)

    # Track equity curve
    if self.track_history:
    self.timestamps.append(timestamp)
    self.equity_curve.append(current_equity)

    # Calculate daily return if we have previous data
    if len(self.equity_curve) > 1:
    prev_equity = self.equity_curve[-2]
    if prev_equity > 0:
    daily_return = (current_equity - prev_equity) / prev_equity
    self.daily_returns.append(daily_return)

    # Update risk metrics from current state
    state = self.portfolio.get_current_state(timestamp)
    self.max_leverage = max(self.max_leverage, state.leverage)
    self.max_concentration = max(self.max_concentration, state.concentration)

    # Save state if tracking history
    if self.track_history:
    self.portfolio.save_state(timestamp)

    def calculate_win_rate(self) -> float:
    """Calculate win rate from trades (percentage of winning trades)."""
    if not self.fills:
    return 0.0

    # Group trades by asset to calculate P&L
    winning_trades = 0
    total_trades = 0

    # Track positions to determine win/loss
    position_pnl: dict[str, list[dict[str, float]]] = {}

    for fill in self.fills:
    asset_id = fill.asset_id

    if fill.side.value == "buy":
    if asset_id not in position_pnl:
    position_pnl[asset_id] = []
    position_pnl[asset_id].append(
    {"quantity": fill.fill_quantity, "price": float(fill.fill_price)},
    )
    elif fill.side.value == "sell":
    if position_pnl.get(asset_id):
    # Calculate P&L for this trade
    buy_info = position_pnl[asset_id].pop(0)
    pnl = (float(fill.fill_price) - buy_info["price"]) * min(
    fill.fill_quantity,
    buy_info["quantity"],
    )

    total_trades += 1
    if pnl > 0:
    winning_trades += 1

    return winning_trades / total_trades if total_trades > 0 else 0.0

    def calculate_profit_factor(self) -> float:
    """Calculate profit factor (gross profit / gross loss)."""
    gross_profit = 0.0
    gross_loss = 0.0

    # Track positions to determine profits and losses
    position_costs: dict[str, list[dict[str, float]]] = {}

    for fill in self.fills:
    asset_id = fill.asset_id

    if fill.side.value == "buy":
    if asset_id not in position_costs:
    position_costs[asset_id] = []
    position_costs[asset_id].append(
    {"quantity": fill.fill_quantity, "price": float(fill.fill_price)},
    )
    elif fill.side.value == "sell":
    if position_costs.get(asset_id):
    # Calculate P&L for this trade
    buy_info = position_costs[asset_id].pop(0)
    pnl = (float(fill.fill_price) - buy_info["price"]) * min(
    fill.fill_quantity,
    buy_info["quantity"],
    )

    if pnl > 0:
    gross_profit += pnl
    else:
    gross_loss += abs(pnl)

    return (
    gross_profit / gross_loss
    if gross_loss > 0
    else float("inf")
    if gross_profit > 0
    else 0.0
    )

    def calculate_avg_commission(self) -> float:
    """Calculate average commission per trade."""
    if not self.fills:
    return 0.0
    return self.portfolio.total_commission / len(self.fills)

    def calculate_avg_slippage(self) -> float:
    """Calculate average slippage per trade."""
    if not self.fills:
    return 0.0
    return self.portfolio.total_slippage / len(self.fills)

    def get_performance_metrics(self) -> dict[str, Any]:
    """Get comprehensive performance metrics."""
    metrics = {
    "total_return": self.portfolio.returns,
    "total_pnl": self.portfolio.total_realized_pnl + self.portfolio.unrealized_pnl,
    "realized_pnl": self.portfolio.total_realized_pnl,
    "unrealized_pnl": self.portfolio.unrealized_pnl,
    "max_drawdown": self.max_drawdown,
    "current_equity": self.portfolio.equity,
    "current_cash": self.portfolio.cash,
    "total_commission": self.portfolio.total_commission,
    "total_slippage": self.portfolio.total_slippage,
    "num_trades": len(self.fills),
    "max_leverage": self.max_leverage,
    "max_concentration": self.max_concentration,
    }

    # Add Sharpe ratio if we have enough data
    if len(self.daily_returns) > 1:
    import numpy as np

    returns = np.array(self.daily_returns)
    if returns.std() > 0:
    # Annualized Sharpe (assuming 252 trading days)
    metrics["sharpe_ratio"] = (returns.mean() / returns.std()) * np.sqrt(252)
    else:
    metrics["sharpe_ratio"] = 0.0

    # Add trading performance metrics
    metrics["win_rate"] = self.calculate_win_rate()
    metrics["profit_factor"] = self.calculate_profit_factor()
    metrics["avg_commission_per_trade"] = self.calculate_avg_commission()
    metrics["avg_slippage_per_trade"] = self.calculate_avg_slippage()

    return metrics

    def get_trades_df(self) -> Optional[pl.DataFrame]:
    """Get all trades as a Polars DataFrame."""
    if not self.fills:
    return None

    trades_data = []
    for fill in self.fills:
    trades_data.append(
    {
    "timestamp": fill.timestamp,
    "order_id": fill.order_id,
    "trade_id": fill.trade_id,
    "asset_id": fill.asset_id,
    "side": fill.side.value,
    "quantity": fill.fill_quantity,
    "price": fill.fill_price,
    "commission": fill.commission,
    "slippage": fill.slippage,
    "total_cost": fill.total_cost,
    },
    )

    return pl.DataFrame(trades_data)

    def get_equity_curve_df(self) -> Optional[pl.DataFrame]:
    """Get equity curve as a Polars DataFrame."""
    if not self.timestamps:
    return None

    return pl.DataFrame(
    {
    "timestamp": self.timestamps,
    "equity": self.equity_curve,
    "returns": [0.0, *self.daily_returns], # Pad with 0 for first day
    },
    )

    def get_positions_df(self) -> Optional[pl.DataFrame]:
    """Get current positions as a Polars DataFrame."""
    if not self.portfolio.positions:
    return None

    positions_data = []
    for position in self.portfolio.positions.values():
    # Get realized P&L from portfolio (tracked at portfolio level, not position level)
    realized_pnl = self.portfolio.asset_realized_pnl.get(position.asset_id, 0.0)
    total_pnl = position.unrealized_pnl + realized_pnl

    positions_data.append(
    {
    "asset_id": position.asset_id,
    "quantity": position.quantity,
    "cost_basis": position.cost_basis,
    "last_price": position.last_price,
    "market_value": position.market_value,
    "unrealized_pnl": position.unrealized_pnl,
    "realized_pnl": realized_pnl,
    "total_pnl": total_pnl,
    },
    )

    return pl.DataFrame(positions_data)

    def get_summary(self) -> dict[str, Any]:
    """Get portfolio summary."""
    summary = self.portfolio.get_position_summary()
    summary.update(self.get_performance_metrics())
    return summary

    def reset(self) -> None:
    """Reset portfolio to initial state."""
    initial_cash = self.portfolio.initial_cash
    self.portfolio = Portfolio(initial_cash)
    self.fills.clear()
    self.high_water_mark = float(initial_cash)
    self.max_drawdown = 0.0
    self.daily_returns.clear()
    self.timestamps.clear()
    self.equity_curve.clear()
    self.max_leverage = 0.0
    self.max_concentration = 0.0

    if self.track_history:
    # Note: Initial timestamp will be set when first event is processed
    self.equity_curve.append(initial_cash)
</file>

<file path="src/qengine/portfolio/margin.py">
    """Margin management for derivatives and leveraged trading."""

    from dataclasses import dataclass, field
    from datetime import datetime
    from typing import Any, Optional

    from qengine.core.assets import AssetRegistry, AssetSpec
    from qengine.core.types import AssetId, Cash, Price, Quantity


    @dataclass
    class MarginRequirement:
    """Margin requirements for a position."""

    asset_id: AssetId
    initial_margin: Cash
    maintenance_margin: Cash
    current_margin: Cash
    excess_margin: Cash
    margin_call: bool = False
    liquidation_price: Optional[Price] = None


    @dataclass
    class MarginAccount:
    """
    Manages margin requirements for derivatives and leveraged trading.

    Handles:
    - Futures margin requirements
    - Options margin for sellers
    - FX leverage
    - Crypto perpetuals and leveraged trading
    - Portfolio margining
    """

    cash_balance: Cash
    initial_margin_requirement: Cash = 0.0
    maintenance_margin_requirement: Cash = 0.0
    margin_used: Cash = 0.0
    available_margin: Cash = 0.0
    positions: dict[AssetId, dict[str, Any]] = field(default_factory=dict)

    # Risk parameters
    margin_call_level: float = 1.0 # 100% of maintenance margin
    liquidation_level: float = 0.8 # 80% of maintenance margin

    def __init__(self, initial_cash: Cash, asset_registry: AssetRegistry):
    """Initialize margin account."""
    self.cash_balance = initial_cash
    self.available_margin = initial_cash
    self.asset_registry = asset_registry
    self.positions = {}
    self.margin_calls: list[MarginRequirement] = []

    def check_margin_requirement(
    self,
    asset_id: AssetId,
    quantity: Quantity,
    price: Price,
    ) -> tuple[bool, Cash]:
    """
    Check if there's sufficient margin for a new position.

    Args:
    asset_id: Asset to trade
    quantity: Quantity to trade
    price: Current price

    Returns:
    Tuple of (has_sufficient_margin, required_margin)
    """
    asset_spec = self.asset_registry.get(asset_id)
    if not asset_spec:
    # Default to equity-like behavior
    required = abs(quantity) * float(price)
    return self.available_margin >= required, required

    required_margin = asset_spec.get_margin_requirement(quantity, price)
    has_margin = self.available_margin >= required_margin

    return has_margin, required_margin

    def open_position(
    self,
    asset_id: AssetId,
    quantity: Quantity,
    price: Price,
    timestamp: datetime,
    ) -> bool:
    """
    Open or modify a position with margin.

    Args:
    asset_id: Asset to trade
    quantity: Quantity to trade (positive for long, negative for short)
    price: Entry price
    timestamp: Transaction time

    Returns:
    Success status
    """
    has_margin, required_margin = self.check_margin_requirement(asset_id, quantity, price)

    if not has_margin:
    return False

    asset_spec = self.asset_registry.get(asset_id)

    if asset_id in self.positions:
    # Modify existing position
    pos = self.positions[asset_id]
    old_margin = pos["margin_used"]

    # Update position
    pos["quantity"] += quantity
    pos["avg_price"] = (
    (pos["avg_price"] * abs(pos["quantity"] - quantity) + float(price) * abs(quantity))
    / abs(pos["quantity"])
    if pos["quantity"] != 0
    else 0
    )
    pos["last_price"] = float(price)
    pos["timestamp"] = timestamp

    # Recalculate margin
    if asset_spec:
    new_margin = asset_spec.get_margin_requirement(pos["quantity"], price)
    pos["margin_used"] = new_margin
    margin_change = new_margin - old_margin
    else:
    pos["margin_used"] = abs(pos["quantity"]) * price
    margin_change = pos["margin_used"] - old_margin

    # Update account margins
    self.margin_used += margin_change
    self.available_margin -= margin_change

    # Remove position if closed
    if pos["quantity"] == 0:
    self.margin_used -= pos["margin_used"]
    self.available_margin += pos["margin_used"]
    del self.positions[asset_id]
    else:
    # Open new position
    self.positions[asset_id] = {
    "quantity": quantity,
    "avg_price": float(price),
    "last_price": float(price),
    "margin_used": required_margin,
    "timestamp": timestamp,
    "asset_spec": asset_spec,
    }

    self.margin_used = float(self.margin_used) + float(required_margin)
    self.available_margin = float(self.available_margin) - float(required_margin)

    # Update margin requirements
    self._update_margin_requirements()

    return True

    def update_prices(self, prices: dict[AssetId, Price]) -> list[MarginRequirement]:
    """
    Update positions with new prices and check margin requirements.

    Args:
    prices: Current market prices

    Returns:
    List of margin requirements/calls
    """
    margin_status = []

    for asset_id, price in prices.items():
    if asset_id not in self.positions:
    continue

    pos = self.positions[asset_id]
    pos["last_price"] = price

    # Calculate unrealized P&L
    pos["quantity"] * (price - pos["avg_price"])

    # Update margin for this position
    asset_spec = pos.get("asset_spec")
    if asset_spec and asset_spec.requires_margin:
    current_margin = asset_spec.get_margin_requirement(pos["quantity"], price)

    # Calculate liquidation price
    liquidation_price = self._calculate_liquidation_price(asset_id, pos, asset_spec)

    # Check margin status
    margin_req = MarginRequirement(
    asset_id=asset_id,
    initial_margin=asset_spec.initial_margin * abs(pos["quantity"]),
    maintenance_margin=asset_spec.maintenance_margin * abs(pos["quantity"]),
    current_margin=current_margin,
    excess_margin=self.available_margin,
    margin_call=current_margin
    > float(self.available_margin) * self.margin_call_level,
    liquidation_price=liquidation_price,
    )

    margin_status.append(margin_req)

    # Force liquidation if below threshold
    if current_margin > float(self.available_margin) * self.liquidation_level:
    self._force_liquidation(asset_id, price)

    # Update total equity
    self._update_equity()

    return margin_status

    def _calculate_liquidation_price(
    self,
    _asset_id: AssetId,
    position: dict[str, Any],
    asset_spec: AssetSpec,
    ) -> Optional[Price]:
    """Calculate liquidation price for a position."""
    if not asset_spec.requires_margin:
    return None

    quantity = position["quantity"]
    avg_price = position["avg_price"]

    if asset_spec.asset_class.value == "future":
    # Futures liquidation when margin depleted
    maintenance_margin = asset_spec.maintenance_margin * abs(quantity)
    if quantity > 0: # Long position
    return float(
    avg_price
    - (float(self.available_margin) - maintenance_margin)
    / (quantity * asset_spec.contract_size)
    )
    # Short position
    return float(
    avg_price
    + (float(self.available_margin) - maintenance_margin)
    / (abs(quantity) * asset_spec.contract_size)
    )
    if asset_spec.asset_class.value == "fx":
    # FX liquidation based on leverage
    margin_used = position["margin_used"]
    if quantity > 0:
    return float(
    avg_price
    * (1 - self.liquidation_level * margin_used / (abs(quantity) * avg_price))
    )
    return float(
    avg_price * (1 + self.liquidation_level * margin_used / (abs(quantity) * avg_price))
    )

    return None

    def _force_liquidation(self, asset_id: AssetId, price: Price) -> None:
    """Force liquidate a position due to margin call."""
    if asset_id in self.positions:
    pos = self.positions[asset_id]

    # Return margin to available
    self.margin_used -= pos["margin_used"]
    self.available_margin += pos["margin_used"]

    # Calculate and apply loss
    loss = pos["quantity"] * (price - pos["avg_price"])
    self.cash_balance += loss # Loss reduces cash

    # Remove position
    del self.positions[asset_id]

    def _update_margin_requirements(self) -> None:
    """Update total margin requirements."""
    self.initial_margin_requirement = 0.0
    self.maintenance_margin_requirement = 0.0

    for _asset_id, pos in self.positions.items():
    asset_spec = pos.get("asset_spec")
    if asset_spec and asset_spec.requires_margin:
    self.initial_margin_requirement += asset_spec.initial_margin * abs(pos["quantity"])
    self.maintenance_margin_requirement += asset_spec.maintenance_margin * abs(
    pos["quantity"],
    )

    def _update_equity(self) -> None:
    """Update total account equity."""
    total_unrealized = 0.0

    for pos in self.positions.values():
    unrealized = pos["quantity"] * (pos["last_price"] - pos["avg_price"])

    # Apply contract multiplier for futures
    asset_spec = pos.get("asset_spec")
    if asset_spec and asset_spec.asset_class.value == "future":
    unrealized *= asset_spec.contract_size

    total_unrealized += unrealized

    # Update available margin with unrealized P&L
    self.available_margin = (
    float(self.cash_balance) + total_unrealized - float(self.margin_used)
    )

    def get_margin_status(self) -> dict[str, Any]:
    """Get current margin account status."""
    total_unrealized = sum(
    pos["quantity"] * (pos["last_price"] - pos["avg_price"])
    for pos in self.positions.values()
    )

    return {
    "cash_balance": self.cash_balance,
    "margin_used": self.margin_used,
    "available_margin": self.available_margin,
    "initial_requirement": self.initial_margin_requirement,
    "maintenance_requirement": self.maintenance_margin_requirement,
    "unrealized_pnl": total_unrealized,
    "total_equity": self.cash_balance + total_unrealized,
    "margin_utilization": float(self.margin_used) / float(self.available_margin)
    if self.available_margin > 0
    else 0,
    "num_positions": len(self.positions),
    "has_margin_call": any(mc.margin_call for mc in self.margin_calls),
    }
</file>

<file path="src/qengine/portfolio/portfolio.py">
    """Portfolio state management for QEngine."""

    from dataclasses import dataclass, field
    from datetime import datetime
    from typing import Any, Union

    from qengine.core.types import AssetId, Cash, Quantity


    @dataclass
    class Position:
    """Represents a position in a single asset - current holdings only."""

    asset_id: AssetId
    quantity: Quantity = 0.0
    cost_basis: float = 0.0
    last_price: float = 0.0
    unrealized_pnl: float = 0.0

    @property
    def market_value(self) -> float:
    """Current market value of the position."""
    return self.quantity * self.last_price

    def update_price(self, price: float) -> None:
    """Update position with new market price."""
    self.last_price = price
    if self.quantity != 0:
    self.unrealized_pnl = self.quantity * (price - self.cost_basis / self.quantity)

    def add_shares(self, quantity: Quantity, price: float) -> None:
    """Add shares to position."""
    if self.quantity + quantity == 0:
    # Closing position
    self.unrealized_pnl = 0.0
    self.cost_basis = 0.0
    else:
    # Update cost basis
    new_cost = quantity * price
    self.cost_basis += new_cost

    self.quantity += quantity
    self.update_price(price)

    def remove_shares(self, quantity: Quantity, price: float) -> float:
    """Remove shares from position, returns realized P&L for this transaction."""
    # Use tolerance for floating-point comparison (e.g., 1.0 vs 0.9999999999999998)
    TOLERANCE = 1e-9
    if abs(quantity) > abs(self.quantity) + TOLERANCE:
    raise ValueError(f"Cannot remove {quantity} shares, only have {self.quantity}")

    # Calculate realized P&L for the shares being removed
    avg_cost = self.cost_basis / self.quantity if self.quantity != 0 else 0
    realized = quantity * (price - avg_cost)

    # Update cost basis
    self.cost_basis -= quantity * avg_cost
    self.quantity -= quantity

    self.update_price(price)
    return realized


    @dataclass
    class PortfolioState:
    """Complete portfolio state at a point in time."""

    timestamp: datetime
    cash: Cash
    positions: dict[AssetId, Position] = field(default_factory=dict)
    pending_orders: list[Any] = field(default_factory=list)
    filled_orders: list[Any] = field(default_factory=list)

    # Performance metrics
    total_value: float = 0.0
    total_realized_pnl: float = 0.0
    total_unrealized_pnl: float = 0.0
    total_commission: float = 0.0
    total_slippage: float = 0.0

    # Risk metrics
    leverage: float = 1.0
    max_position_value: float = 0.0
    concentration: float = 0.0

    @property
    def equity(self) -> float:
    """Total equity (cash + positions)."""
    position_value = sum(p.market_value for p in self.positions.values())
    return float(self.cash) + position_value

    @property
    def total_pnl(self) -> float:
    """Total P&L across all positions."""
    return self.total_realized_pnl + self.total_unrealized_pnl

    def update_metrics(self) -> None:
    """Update portfolio metrics."""
    # Update position values
    position_values = [p.market_value for p in self.positions.values()]

    if position_values:
    self.max_position_value = max(abs(v) for v in position_values)
    total_position_value = sum(abs(v) for v in position_values)

    # Update concentration (largest position as % of portfolio)
    if self.equity > 0:
    self.concentration = self.max_position_value / self.equity
    self.leverage = total_position_value / self.equity
    else:
    self.concentration = 0.0
    self.leverage = 0.0
    else:
    self.max_position_value = 0.0
    self.concentration = 0.0
    self.leverage = 0.0

    # Update P&L (realized P&L is tracked at Portfolio level, not per Position)
    self.total_unrealized_pnl = sum(p.unrealized_pnl for p in self.positions.values())
    # total_realized_pnl is set from Portfolio.total_realized_pnl (passed in get_current_state)
    self.total_value = self.equity


    class Portfolio:
    """Portfolio management with state tracking."""

    def __init__(self, initial_cash: Cash = 100000.0):
    """Initialize portfolio with starting cash."""
    self.initial_cash = float(initial_cash)
    self.cash = float(initial_cash)
    self.positions: dict[AssetId, Position] = {}

    # Track cumulative costs and P&L
    self.total_commission = 0.0
    self.total_slippage = 0.0
    self.total_realized_pnl = 0.0
    self.asset_realized_pnl: dict[AssetId, float] = {} # Per-asset P&L tracking

    # History tracking
    self.state_history: list[PortfolioState] = []

    def get_position(self, asset_id: AssetId) -> Union[Position, None]:
    """Get position for an asset."""
    return self.positions.get(asset_id)

    def update_position(
    self,
    asset_id: AssetId,
    quantity_change: Quantity,
    price: float,
    commission: float = 0.0,
    slippage: float = 0.0,
    ) -> None:
    """
    Update a position with a trade.

    Args:
    asset_id: Asset identifier
    quantity_change: Change in quantity (positive for buy, negative for sell)
    price: Execution price
    commission: Commission paid
    slippage: Slippage cost
    """
    # Get or create position
    if asset_id not in self.positions:
    self.positions[asset_id] = Position(asset_id=asset_id)

    position = self.positions[asset_id]

    # Update position
    if quantity_change > 0:
    position.add_shares(quantity_change, price)
    self.cash = float(self.cash) - (quantity_change * price + commission)
    else:
    realized_pnl = position.remove_shares(-quantity_change, price)
    self.cash = float(self.cash) + ((-quantity_change) * price - commission)

    # Track realized P&L (portfolio-level and per-asset)
    self.total_realized_pnl += realized_pnl
    if asset_id not in self.asset_realized_pnl:
    self.asset_realized_pnl[asset_id] = 0.0
    self.asset_realized_pnl[asset_id] += realized_pnl

    # Track costs
    self.total_commission += commission
    self.total_slippage += slippage

    # Remove empty positions (clean deletion rule)
    if position.quantity == 0:
    del self.positions[asset_id]

    def update_prices(self, prices: dict[AssetId, float]) -> None:
    """Update all positions with new market prices."""
    for asset_id, price in prices.items():
    if asset_id in self.positions:
    self.positions[asset_id].update_price(price)

    def get_current_state(self, timestamp: datetime) -> PortfolioState:
    """Get current portfolio state."""
    state = PortfolioState(
    timestamp=timestamp,
    cash=self.cash,
    positions=self.positions.copy(),
    total_commission=self.total_commission,
    total_slippage=self.total_slippage,
    total_realized_pnl=self.total_realized_pnl,
    )
    state.update_metrics()
    return state

    def save_state(self, timestamp: datetime) -> None:
    """Save current state to history."""
    self.state_history.append(self.get_current_state(timestamp))

    @property
    def equity(self) -> float:
    """Total equity (cash + positions)."""
    position_value = sum(p.market_value for p in self.positions.values())
    return float(self.cash) + position_value

    @property
    def returns(self) -> float:
    """Simple returns from initial capital."""
    if self.initial_cash == 0:
    return 0.0
    return (self.equity - float(self.initial_cash)) / float(self.initial_cash)

    @property
    def unrealized_pnl(self) -> float:
    """Total unrealized P&L."""
    return sum(p.unrealized_pnl for p in self.positions.values())

    def get_position_summary(self) -> dict[str, Any]:
    """Get summary of all positions."""
    return {
    "cash": self.cash,
    "equity": self.equity,
    "positions": len(self.positions),
    "realized_pnl": self.total_realized_pnl,
    "unrealized_pnl": self.unrealized_pnl,
    "total_pnl": self.total_realized_pnl + self.unrealized_pnl,
    "returns": self.returns,
    "commission": self.total_commission,
    "slippage": self.total_slippage,
    }
</file>

<file path="src/qengine/portfolio/simple.py">
    """Simple portfolio implementation for basic backtesting."""

    import logging
    from datetime import datetime
    from typing import Any, Optional

    import polars as pl

    from qengine.core.event import FillEvent, MarketEvent
    from qengine.core.types import AssetId, Cash
    from qengine.portfolio.portfolio import Portfolio

    logger = logging.getLogger(__name__)


    class SimplePortfolio(Portfolio):
    """Simple portfolio implementation with basic tracking.

    This portfolio provides:
    - Position tracking
    - P&L calculation
    - Basic performance metrics
    - Event handling integration
    """

    def __init__(self, initial_capital: Cash = 100000.0, currency: str = "USD"):
    """Initialize simple portfolio.

    Args:
    initial_capital: Starting cash balance
    currency: Base currency
    """
    super().__init__(initial_cash=initial_capital)
    self.currency = currency
    self.trades: list[dict[str, Any]] = [] # Track all trades
    self.current_prices: dict[AssetId, float] = {} # Latest market prices

    def initialize(self) -> None:
    """Initialize portfolio for new backtest."""
    logger.debug(f"Initializing portfolio with ${self.initial_cash:,.2f} {self.currency}")

    def on_fill_event(self, event: FillEvent) -> None:
    """Handle fill event from broker.

    Args:
    event: Fill event with execution details
    """
    # Update position
    self.update_position(
    asset_id=event.asset_id,
    quantity_change=event.fill_quantity
    if event.side.value in ["buy", "BUY"]
    else -event.fill_quantity,
    price=float(event.fill_price),
    commission=event.commission,
    slippage=event.slippage,
    )

    # Record trade
    self.trades.append(
    {
    "timestamp": event.timestamp,
    "asset_id": event.asset_id,
    "side": event.side.value,
    "quantity": event.fill_quantity,
    "price": float(event.fill_price),
    "commission": event.commission,
    "slippage": event.slippage,
    "pnl": 0.0, # Will be calculated later
    },
    )

    logger.info(
    f"Fill: {event.side.value.upper()} {event.fill_quantity} {event.asset_id} "
    f"@ ${float(event.fill_price):.2f} (commission: ${event.commission:.2f})",
    )

    def update_market_value(self, event: MarketEvent) -> None:
    """Update portfolio with latest market prices.

    Args:
    event: Market event with price data
    """
    # Update current price for the asset
    if hasattr(event, "close") and event.close is not None:
    self.current_prices[event.asset_id] = float(event.close)
    elif hasattr(event, "price") and event.price is not None:
    self.current_prices[event.asset_id] = float(event.price)

    # Update all positions with latest prices
    self.update_prices(self.current_prices)

    def get_total_value(self) -> float:
    """Get total portfolio value (cash + positions).

    Returns:
    Total portfolio value
    """
    return self.equity

    def get_positions(self) -> pl.DataFrame:
    """Get DataFrame of current positions.

    Returns:
    DataFrame with position details
    """
    if not self.positions:
    return pl.DataFrame()

    positions_data = []
    for asset_id, position in self.positions.items():
    # Get realized P&L from portfolio (tracked at portfolio level, not position level)
    realized_pnl = self.asset_realized_pnl.get(asset_id, 0.0)
    positions_data.append(
    {
    "asset_id": asset_id,
    "quantity": position.quantity,
    "cost_basis": position.cost_basis,
    "market_value": position.market_value,
    "unrealized_pnl": position.unrealized_pnl,
    "realized_pnl": realized_pnl,
    "last_price": position.last_price,
    },
    )

    return pl.DataFrame(positions_data)

    def get_trades(self) -> pl.DataFrame:
    """Get DataFrame of all trades.

    Returns:
    DataFrame with trade history
    """
    if not self.trades:
    return pl.DataFrame()
    return pl.DataFrame(self.trades)

    def get_returns(self) -> pl.Series:
    """Get returns series.

    Returns:
    Series of portfolio returns
    """
    if not self.state_history:
    return pl.Series([])

    returns = []
    prev_value = self.initial_cash

    for state in self.state_history:
    current_value = state.equity
    ret = (current_value - prev_value) / prev_value if prev_value != 0 else 0
    returns.append(ret)
    prev_value = current_value

    return pl.Series(returns)

    def calculate_metrics(self) -> dict[str, Any]:
    """Calculate performance metrics.

    Returns:
    Dictionary of performance metrics
    """
    returns = self.get_returns()

    metrics = {
    "total_return": self.returns * 100, # Percentage
    "total_trades": len(self.trades),
    "winning_trades": sum(1 for t in self.trades if t.get("pnl", 0) > 0),
    "losing_trades": sum(1 for t in self.trades if t.get("pnl", 0)
    <
    0),
    "total_commission": self.total_commission,
    "total_slippage": self.total_slippage,
    "final_equity": self.equity,
    "cash_remaining": self.cash,
    }

    # Calculate returns-based metrics if we have data
    if len(returns) > 0:
    import numpy as np

    returns_array = returns.to_numpy()

    # Remove any NaN values
    returns_array = returns_array[~np.isnan(returns_array)]

    if len(returns_array) > 0:
    metrics["avg_return"] = float(np.mean(returns_array))
    metrics["std_return"] = float(np.std(returns_array))

    # Sharpe ratio (assuming 0 risk-free rate)
    if metrics["std_return"] > 0:
    metrics["sharpe_ratio"] = (
    np.sqrt(252) * metrics["avg_return"] / metrics["std_return"]
    )
    else:
    metrics["sharpe_ratio"] = 0.0

    # Maximum drawdown
    cumulative = np.cumprod(1 + returns_array)
    running_max = np.maximum.accumulate(cumulative)
    drawdown = (cumulative - running_max) / running_max
    metrics["max_drawdown"] = np.min(drawdown) * 100 # Percentage

    # Win rate
    if metrics["total_trades"] > 0:
    metrics["win_rate"] = (
    metrics["winning_trades"] / metrics["total_trades"]
    ) * 100
    else:
    metrics["win_rate"] = 0.0

    return metrics

    def finalize(self, timestamp: Optional[datetime] = None) -> None:
    """Finalize portfolio at end of backtest.

    Args:
    timestamp: Current simulation time (if None, uses datetime.now() for compatibility)
    """
    # Save final state
    self.save_state(timestamp or datetime.now())

    # Calculate P&L for all trades
    for i, trade in enumerate(self.trades):
    if i > 0 and trade["side"] in ["sell", "SELL"]:
    # Find corresponding buy trade and calculate P&L
    # This is simplified - real implementation would match specific lots
    prev_trades = [t for t in self.trades[:i] if t["asset_id"] == trade["asset_id"]]
    if prev_trades:
    avg_buy_price = sum(
    t["price"] * t["quantity"]
    for t in prev_trades
    if t["side"] in ["buy", "BUY"]
    ) / sum(t["quantity"] for t in prev_trades if t["side"] in ["buy", "BUY"])
    trade["pnl"] = (trade["price"] - avg_buy_price) * trade["quantity"] - trade[
    "commission"
    ]

    logger.info(f"Portfolio finalized. Final equity: ${self.equity:,.2f}")

    def reset(self) -> None:
    """Reset portfolio to initial state."""
    self.cash = self.initial_cash
    self.positions.clear()
    self.trades.clear()
    self.current_prices.clear()
    self.state_history.clear()
    self.total_commission = 0.0
    self.total_slippage = 0.0
    self.total_realized_pnl = 0.0


    __all__ = ["SimplePortfolio"]
</file>

<file path="src/qengine/reporting/__init__.py">
    """Reporting module for QEngine."""

    from qengine.reporting.base import ReportGenerator
    from qengine.reporting.html import HTMLReportGenerator
    from qengine.reporting.parquet import ParquetReportGenerator
    from qengine.reporting.reporter import ConsoleReporter, InMemoryReporter, Reporter

    __all__ = [
    "ConsoleReporter",
    "HTMLReportGenerator",
    "InMemoryReporter",
    "ParquetReportGenerator",
    "ReportGenerator",
    "Reporter",
    ]
</file>

<file path="src/qengine/reporting/base.py">
    """Base reporting functionality for QEngine."""

    from abc import ABC, abstractmethod
    from datetime import datetime
    from pathlib import Path
    from typing import Any

    from qengine.portfolio.accounting import PortfolioAccounting


    class ReportGenerator(ABC):
    """
    Abstract base class for report generation.

    Different report formats (HTML, Parquet, JSON) should implement this interface.
    """

    def __init__(self, output_dir: Path | None = None, report_name: str | None = None):
    """
    Initialize report generator.

    Args:
    output_dir: Directory to save reports
    report_name: Base name for report files
    """
    self.output_dir = Path(output_dir) if output_dir else Path.cwd() / "reports"
    # Report name will use timestamp from first event if not provided
    self.report_name = report_name or "backtest_report"

    # Ensure output directory exists
    self.output_dir.mkdir(parents=True, exist_ok=True)

    @abstractmethod
    def generate(
    self,
    accounting: PortfolioAccounting,
    strategy_params: dict[str, Any] | None = None,
    backtest_params: dict[str, Any] | None = None,
    ) -> Path:
    """
    Generate report from portfolio accounting data.

    Args:
    accounting: Portfolio accounting with results
    strategy_params: Strategy configuration parameters
    backtest_params: Backtest configuration parameters

    Returns:
    Path to generated report
    """

    def _prepare_report_data(
    self,
    accounting: PortfolioAccounting,
    strategy_params: dict[str, Any] | None = None,
    backtest_params: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
    """
    Prepare standardized report data from accounting.

    Args:
    accounting: Portfolio accounting instance
    strategy_params: Strategy parameters
    backtest_params: Backtest parameters

    Returns:
    Dictionary with report data
    """
    # Get performance metrics
    metrics = accounting.get_performance_metrics()

    # Get summary data
    summary = accounting.get_summary()

    # Prepare report data structure
    report_data = {
    "metadata": {
    "report_name": self.report_name,
    "generated_at": datetime.now().isoformat(), # Wall clock time for report generation
    "strategy_params": strategy_params or {},
    "backtest_params": backtest_params or {},
    },
    "performance": {
    "total_return": metrics.get("total_return", 0.0),
    "total_pnl": metrics.get("total_pnl", 0.0),
    "realized_pnl": metrics.get("realized_pnl", 0.0),
    "unrealized_pnl": metrics.get("unrealized_pnl", 0.0),
    "max_drawdown": metrics.get("max_drawdown", 0.0),
    "sharpe_ratio": metrics.get("sharpe_ratio", 0.0),
    "num_trades": metrics.get("num_trades", 0),
    "win_rate": accounting.calculate_win_rate(),
    "profit_factor": accounting.calculate_profit_factor(),
    },
    "costs": {
    "total_commission": metrics.get("total_commission", 0.0),
    "total_slippage": metrics.get("total_slippage", 0.0),
    "avg_commission_per_trade": accounting.calculate_avg_commission(),
    "avg_slippage_per_trade": accounting.calculate_avg_slippage(),
    },
    "portfolio": {
    "initial_cash": accounting.portfolio.initial_cash,
    "final_equity": summary.get("equity", 0.0),
    "final_cash": summary.get("cash", 0.0),
    "num_positions": summary.get("positions", 0),
    },
    "risk": {
    "max_leverage": metrics.get("max_leverage", 1.0),
    "max_concentration": metrics.get("max_concentration", 0.0),
    },
    "trades": accounting.get_trades_df(),
    "equity_curve": accounting.get_equity_curve_df(),
    "positions": accounting.get_positions_df(),
    }

    return report_data
</file>

<file path="src/qengine/reporting/html.py">
    """HTML report generation for QEngine backtests."""

    import json
    from pathlib import Path
    from typing import Any

    from qengine.portfolio.accounting import PortfolioAccounting
    from qengine.reporting.base import ReportGenerator


    class HTMLReportGenerator(ReportGenerator):
    """
    Generates comprehensive HTML reports for backtest results.

    Creates interactive reports with:
    - Performance summary
    - Equity curve charts
    - Trade analysis
    - Risk metrics
    - Asset class breakdown
    """

    def generate(
    self,
    accounting: PortfolioAccounting,
    strategy_params: dict[str, Any] | None = None,
    backtest_params: dict[str, Any] | None = None,
    ) -> Path:
    """
    Generate HTML report from portfolio accounting data.

    Args:
    accounting: Portfolio accounting with results
    strategy_params: Strategy configuration parameters
    backtest_params: Backtest configuration parameters

    Returns:
    Path to generated HTML report
    """
    # Prepare report data
    report_data = self._prepare_report_data(accounting, strategy_params, backtest_params)

    # Generate HTML content
    html_content = self._generate_html_content(report_data)

    # Save report
    report_path = self.output_dir / f"{self.report_name}.html"
    with open(report_path, "w", encoding="utf-8") as f:
    f.write(html_content)

    return report_path

    def _generate_html_content(self, report_data: dict[str, Any]) -> str:
    """Generate the complete HTML report content."""
    html = f"""
    <!DOCTYPE html>
    <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>QEngine Backtest Report - {report_data["metadata"]["report_name"]}</title>
            <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
            <style>
                {self._get_css_styles()}
            </style>
        </head>
        <body>
            <div class="container">
                {self._generate_header(report_data)}
                {self._generate_summary_section(report_data)}
                {self._generate_performance_section(report_data)}
                {self._generate_charts_section(report_data)}
                {self._generate_trades_section(report_data)}
                {self._generate_positions_section(report_data)}
                {self._generate_risk_section(report_data)}
                {self._generate_footer(report_data)}
            </div>

            <script>
                {self._generate_javascript(report_data)}
            </script>
        </body>
    </html>
    """
    return html

    def _get_css_styles(self) -> str:
    """Get CSS styles for the report."""
    return """
    * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    }

    body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #f5f5f5;
    color: #333;
    line-height: 1.6;
    }

    .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    }

    .header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 30px;
    border-radius: 10px;
    margin-bottom: 30px;
    text-align: center;
    }

    .header h1 {
    font-size: 2.5em;
    margin-bottom: 10px;
    }

    .header .subtitle {
    font-size: 1.2em;
    opacity: 0.9;
    }

    .section {
    background: white;
    margin-bottom: 30px;
    padding: 25px;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .section h2 {
    color: #667eea;
    font-size: 1.8em;
    margin-bottom: 20px;
    border-bottom: 3px solid #667eea;
    padding-bottom: 10px;
    }

    .metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
    }

    .metric-card {
    background: #f8f9ff;
    padding: 20px;
    border-radius: 8px;
    border-left: 4px solid #667eea;
    }

    .metric-label {
    font-size: 0.9em;
    color: #666;
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    }

    .metric-value {
    font-size: 1.8em;
    font-weight: bold;
    color: #333;
    }

    .metric-value.positive {
    color: #28a745;
    }

    .metric-value.negative {
    color: #dc3545;
    }

    .chart-container {
    margin: 20px 0;
    min-height: 400px;
    }

    .table-container {
    overflow-x: auto;
    margin-top: 20px;
    }

    table {
    width: 100%;
    border-collapse: collapse;
    background: white;
    }

    th, td {
    padding: 12px;
    text-align: left;
    border-bottom: 1px solid #ddd;
    }

    th {
    background-color: #f8f9ff;
    font-weight: 600;
    color: #667eea;
    }

    tr:hover {
    background-color: #f8f9ff;
    }

    .footer {
    text-align: center;
    color: #666;
    font-size: 0.9em;
    margin-top: 40px;
    padding-top: 20px;
    border-top: 1px solid #ddd;
    }

    .warning {
    background-color: #fff3cd;
    border: 1px solid #ffeaa7;
    color: #856404;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    }

    .info {
    background-color: #d1ecf1;
    border: 1px solid #bee5eb;
    color: #0c5460;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    }

    @media (max-width: 768px) {
    .metrics-grid {
    grid-template-columns: 1fr;
    }

    .header h1 {
    font-size: 2em;
    }
    }
    """

    def _generate_header(self, report_data: dict[str, Any]) -> str:
    """Generate the report header."""
    metadata = report_data["metadata"]
    return f"""
    <div class="header">
        <h1>QEngine Backtest Report</h1>
        <div class="subtitle">
            {metadata["report_name"]}
            <br>
            Generated: {metadata["generated_at"][:19]}
        </div>
    </div>
    """

    def _generate_summary_section(self, report_data: dict[str, Any]) -> str:
    """Generate the summary metrics section."""
    perf = report_data["performance"]
    portfolio = report_data["portfolio"]
    costs = report_data["costs"]

    return f"""
    <div class="section">
        <h2>Performance Summary</h2>
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-label">Total Return</div>
                <div class="metric-value {" positive" if perf["total_return"] >= 0 else "negative"}">
                {perf["total_return"]:.2%}
            </div>
        </div>

        <div class="metric-card">
            <div class="metric-label">Total P&L</div>
            <div class="metric-value {" positive" if perf["total_pnl"] >= 0 else "negative"}">
            ${perf["total_pnl"]:,.2f}
        </div>
    </div>

    <div class="metric-card">
        <div class="metric-label">Sharpe Ratio</div>
        <div class="metric-value {" positive" if perf.get("sharpe_ratio", 0) >= 0 else "negative"}">
        {perf.get("sharpe_ratio", "N/A")}
    </div>
</div>

<div class="metric-card">
    <div class="metric-label">Max Drawdown</div>
    <div class="metric-value negative">
        -{perf["max_drawdown"]:.2%}
    </div>
</div>

<div class="metric-card">
    <div class="metric-label">Win Rate</div>
    <div class="metric-value">
        {perf["win_rate"]:.2%}
    </div>
</div>

<div class="metric-card">
    <div class="metric-label">Total Trades</div>
    <div class="metric-value">
        {perf["num_trades"]:,}
    </div>
</div>

<div class="metric-card">
    <div class="metric-label">Final Equity</div>
    <div class="metric-value">
        ${portfolio["final_equity"]:,.2f}
    </div>
</div>

<div class="metric-card">
    <div class="metric-label">Total Commission</div>
    <div class="metric-value negative">
        ${costs["total_commission"]:,.2f}
    </div>
</div>
</div>
        </div>
        """

        def _generate_performance_section(self, report_data: dict[str, Any]) -> str:
        """Generate detailed performance metrics."""
        perf = report_data["performance"]
        costs = report_data["costs"]

        return f"""
<div class="section">
<h2>Detailed Performance</h2>

<div class="metrics-grid">
    <div class="metric-card">
        <div class="metric-label">Realized P&L</div>
        <div class="metric-value {" positive" if perf["realized_pnl"] >= 0 else "negative"}">
        ${perf["realized_pnl"]:,.2f}
    </div>
</div>

<div class="metric-card">
    <div class="metric-label">Unrealized P&L</div>
    <div class="metric-value {" positive" if perf["unrealized_pnl"] >= 0 else "negative"}">
    ${perf["unrealized_pnl"]:,.2f}
</div>
</div>

<div class="metric-card">
<div class="metric-label">Profit Factor</div>
<div class="metric-value">
    {perf["profit_factor"]:.2f}
</div>
</div>

<div class="metric-card">
<div class="metric-label">Avg Commission/Trade</div>
<div class="metric-value">
    ${costs["avg_commission_per_trade"]:.2f}
</div>
</div>
        </div>
        </div>
        """

        def _generate_charts_section(self, report_data: dict[str, Any]) -> str:
        """Generate charts section."""
        return """
<div class="section">
<h2>Charts</h2>

<div class="chart-container">
    <div id="equity-curve-chart"></div>
</div>

<div class="chart-container">
    <div id="returns-chart"></div>
</div>
</div>
        """

        def _generate_trades_section(self, report_data: dict[str, Any]) -> str:
        """Generate trades analysis section."""
        trades_df = report_data.get("trades")

        if trades_df is None or len(trades_df) == 0:
        return """
<div class="section">
<h2>Trade Analysis</h2>
<div class="info">No trades found in this backtest.</div>
</div>
        """

        # Get first few trades for display
        display_trades = trades_df.head(20).to_dicts()

        trades_html = ""
        for trade in display_trades:
        trades_html += f"""
<tr>
<td>{trade["timestamp"]}</td>
<td>{trade["asset_id"]}</td>
<td>{trade["side"].upper()}</td>
<td>{trade["quantity"]:.2f}</td>
<td>${trade["price"]:.2f}</td>
<td>${trade["commission"]:.2f}</td>
<td>${trade["total_cost"]:.2f}</td>
</tr>
        """

        return f"""
<div class="section">
<h2>Trade Analysis</h2>

<div class="info">
    Showing first 20 trades out of {len(trades_df)} total trades.
</div>

<div class="table-container">
    <table>
        <thead>
            <tr>
                <th>Timestamp</th>
                <th>Asset</th>
                <th>Side</th>
                <th>Quantity</th>
                <th>Price</th>
                <th>Commission</th>
                <th>Total Cost</th>
            </tr>
        </thead>
        <tbody>
            {trades_html}
        </tbody>
    </table>
</div>
</div>
        """

        def _generate_positions_section(self, report_data: dict[str, Any]) -> str:
        """Generate current positions section."""
        positions_df = report_data.get("positions")

        if positions_df is None or len(positions_df) == 0:
        return """
<div class="section">
<h2>Current Positions</h2>
<div class="info">No open positions at end of backtest.</div>
</div>
        """

        positions_html = ""
        for pos in positions_df.to_dicts():
        positions_html += f"""
<tr>
<td>{pos["asset_id"]}</td>
<td>{pos["quantity"]:.2f}</td>
<td>${pos["cost_basis"]:.2f}</td>
<td>${pos["last_price"]:.2f}</td>
<td>${pos["market_value"]:.2f}</td>
<td class="{" positive" if pos["unrealized_pnl"] >= 0 else "negative"}">${pos["unrealized_pnl"]:.2f}
</td>
<td class="{" positive" if pos["total_pnl"] >= 0 else "negative"}">${pos["total_pnl"]:.2f}</td>
        </tr>
        """

        return f"""
<div class="section">
<h2>Current Positions</h2>

<div class="table-container">
    <table>
        <thead>
            <tr>
                <th>Asset</th>
                <th>Quantity</th>
                <th>Cost Basis</th>
                <th>Last Price</th>
                <th>Market Value</th>
                <th>Unrealized P&L</th>
                <th>Total P&L</th>
            </tr>
        </thead>
        <tbody>
            {positions_html}
        </tbody>
    </table>
</div>
</div>
        """

        def _generate_risk_section(self, report_data: dict[str, Any]) -> str:
        """Generate risk metrics section."""
        risk = report_data.get("risk", {})

        return f"""
<div class="section">
<h2>Risk Metrics</h2>

<div class="metrics-grid">
    <div class="metric-card">
        <div class="metric-label">Max Leverage</div>
        <div class="metric-value">
            {risk.get("max_leverage", 1.0):.2f}x
        </div>
    </div>

    <div class="metric-card">
        <div class="metric-label">Max Concentration</div>
        <div class="metric-value">
            {risk.get("max_concentration", 0.0):.2%}
        </div>
    </div>
</div>

<div class="warning">
    <strong>Risk Disclaimer:</strong>
    Past performance does not guarantee future results.
    All trading involves risk of loss.
</div>
</div>
        """

        def _generate_footer(self, report_data: dict[str, Any]) -> str:
        """Generate report footer."""
        return f"""
<div class="footer">
Report generated by QEngine Backtesting Framework
<br>
Generated at: {report_data["metadata"]["generated_at"]}
</div>
        """

        def _generate_javascript(self, report_data: dict[str, Any]) -> str:
        """Generate JavaScript for interactive charts."""
        equity_df = report_data.get("equity_curve")

        if equity_df is None or len(equity_df) == 0:
        return "// No data available for charts"

        # Convert DataFrame to JSON for JavaScript
        equity_data = equity_df.to_dicts()

        # Convert datetime objects to strings for JSON serialization
        for item in equity_data:
        if "timestamp" in item:
        item["timestamp"] = item["timestamp"].isoformat()

        return f"""
        // Equity curve chart
        const equityData = {json.dumps(equity_data)};

        const equityTrace = {{
        x: equityData.map(d => d.timestamp),
        y: equityData.map(d => d.equity),
        type: 'scatter',
        mode: 'lines',
        name: 'Equity',
        line: {{
        color: '#667eea',
        width: 2
        }}
        }};

        const equityLayout = {{
        title: 'Equity Curve',
        xaxis: {{ title: 'Date' }},
        yaxis: {{ title: 'Portfolio Value ($)' }},
        margin: {{ t: 50 }}
        }};

        Plotly.newPlot('equity-curve-chart', [equityTrace], equityLayout);

        // Returns chart
        const returnsTrace = {{
        x: equityData.map(d => d.timestamp).slice(1),
        y: equityData.map(d => d.returns).slice(1),
        type: 'scatter',
        mode: 'markers',
        name: 'Daily Returns',
        marker: {{
        color: equityData.map(d => d.returns > 0 ? '#28a745' : '#dc3545').slice(1),
        size: 4
        }}
        }};

        const returnsLayout = {{
        title: 'Daily Returns Distribution',
        xaxis: {{ title: 'Date' }},
        yaxis: {{ title: 'Daily Return' }},
        margin: {{ t: 50 }}
        }};

        Plotly.newPlot('returns-chart', [returnsTrace], returnsLayout);
        """
        </file>

<file path="src/qengine/reporting/parquet.py">
"""Parquet report generation for QEngine backtests."""

import json
from pathlib import Path
from typing import Any

import polars as pl

from qengine.portfolio.accounting import PortfolioAccounting
from qengine.reporting.base import ReportGenerator


class ParquetReportGenerator(ReportGenerator):
"""
Generates Parquet-based reports for backtest results.

Creates structured data files optimized for:
- Data science workflows
- Further analysis with Polars/Pandas
- Integration with data pipelines
- Long-term storage and archival
"""

def generate(
self,
accounting: PortfolioAccounting,
strategy_params: dict[str, Any] | None = None,
backtest_params: dict[str, Any] | None = None,
) -> Path:
"""
Generate Parquet report from portfolio accounting data.

Args:
accounting: Portfolio accounting with results
strategy_params: Strategy configuration parameters
backtest_params: Backtest configuration parameters

Returns:
Path to generated report directory
"""
# Create report directory
report_dir = self.output_dir / f"{self.report_name}_parquet"
report_dir.mkdir(exist_ok=True)

# Prepare report data
report_data = self._prepare_report_data(accounting, strategy_params, backtest_params)

# Save metadata as JSON
self._save_metadata(report_data, report_dir)

# Save performance metrics
self._save_performance_metrics(report_data, report_dir)

# Save time series data
self._save_equity_curve(report_data, report_dir)

# Save trades data
self._save_trades(report_data, report_dir)

# Save positions data
self._save_positions(report_data, report_dir)

# Create summary file
self._create_summary_file(report_data, report_dir)

return report_dir

def _save_metadata(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Save metadata and configuration as JSON."""
metadata = {
"report_info": report_data["metadata"],
"backtest_config": {
"strategy_params": report_data["metadata"].get("strategy_params", {}),
"backtest_params": report_data["metadata"].get("backtest_params", {}),
},
"portfolio_config": report_data["portfolio"],
"file_manifest": {
"metadata": "metadata.json",
"performance": "performance_metrics.parquet",
"equity_curve": "equity_curve.parquet",
"trades": "trades.parquet",
"positions": "positions.parquet",
"summary": "summary.parquet",
},
}

metadata_path = report_dir / "metadata.json"
with open(metadata_path, "w") as f:
json.dump(metadata, f, indent=2, default=str)

def _save_performance_metrics(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Save performance metrics as Parquet."""
# Combine all performance data
metrics_data = []

# Performance metrics
for key, value in report_data["performance"].items():
metrics_data.append(
{
"category": "performance",
"metric": key,
"value": float(value) if isinstance(value, (int, float)) else str(value),
"format": "percentage"
if "return" in key or "rate" in key
else "currency"
if "pnl" in key
else "number",
},
)

# Cost metrics
for key, value in report_data["costs"].items():
metrics_data.append(
{
"category": "costs",
"metric": key,
"value": float(value) if isinstance(value, (int, float)) else str(value),
"format": "currency" if "commission" in key or "slippage" in key else "number",
},
)

# Risk metrics
for key, value in report_data["risk"].items():
metrics_data.append(
{
"category": "risk",
"metric": key,
"value": float(value) if isinstance(value, (int, float)) else str(value),
"format": "percentage" if "concentration" in key else "number",
},
)

# Portfolio metrics
for key, value in report_data["portfolio"].items():
metrics_data.append(
{
"category": "portfolio",
"metric": key,
"value": float(value) if isinstance(value, (int, float)) else str(value),
"format": "currency" if "cash" in key or "equity" in key else "number",
},
)

metrics_df = pl.DataFrame(metrics_data)
metrics_path = report_dir / "performance_metrics.parquet"
metrics_df.write_parquet(metrics_path)

def _save_equity_curve(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Save equity curve as Parquet."""
equity_df = report_data.get("equity_curve")

if equity_df is not None and len(equity_df) > 0:
# Add derived metrics
enhanced_df = equity_df.with_columns(
[
# Cumulative returns
pl.col("returns").cum_sum().alias("cumulative_returns"),
# Running maximum for drawdown calculation
pl.col("equity").cum_max().alias("running_max"),
# Drawdown
((pl.col("equity") / pl.col("equity").cum_max()) - 1).alias("drawdown"),
# Volatility (rolling 30-day)
pl.col("returns").rolling_std(window_size=30).alias("rolling_volatility_30d"),
# Rolling Sharpe (annualized)
(
pl.col("returns").rolling_mean(window_size=30)
/ pl.col("returns").rolling_std(window_size=30)
* (252**0.5)
).alias("rolling_sharpe_30d"),
],
)

equity_path = report_dir / "equity_curve.parquet"
enhanced_df.write_parquet(equity_path)
else:
# Create empty DataFrame with schema
empty_df = pl.DataFrame(
{
"timestamp": [],
"equity": [],
"returns": [],
"cumulative_returns": [],
"running_max": [],
"drawdown": [],
"rolling_volatility_30d": [],
"rolling_sharpe_30d": [],
},
schema={
"timestamp": pl.Datetime,
"equity": pl.Float64,
"returns": pl.Float64,
"cumulative_returns": pl.Float64,
"running_max": pl.Float64,
"drawdown": pl.Float64,
"rolling_volatility_30d": pl.Float64,
"rolling_sharpe_30d": pl.Float64,
},
)
empty_df.write_parquet(report_dir / "equity_curve.parquet")

def _save_trades(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Save trades data as Parquet."""
trades_df = report_data.get("trades")

if trades_df is not None and len(trades_df) > 0:
# Add derived columns for analysis
enhanced_df = trades_df.with_columns(
[
# Notional value
(pl.col("quantity") * pl.col("price")).alias("notional_value"),
# Commission rate
(pl.col("commission") / (pl.col("quantity") * pl.col("price"))).alias(
"commission_rate",
),
# Slippage rate
(pl.col("slippage") / (pl.col("quantity") * pl.col("price"))).alias(
"slippage_rate",
),
# Trade direction
pl.when(pl.col("side") == "buy").then(1).otherwise(-1).alias("direction"),
# Time-based features
pl.col("timestamp").dt.hour().alias("hour_of_day"),
pl.col("timestamp").dt.day().alias("day_of_month"),
pl.col("timestamp").dt.weekday().alias("day_of_week"),
# Size categories
pl.when(pl.col("quantity") * pl.col("price")
<
1000)
.then(pl.lit("small"))
.when(pl.col("quantity") * pl.col("price")
<
10000)
.then(pl.lit("medium"))
.otherwise(pl.lit("large"))
.alias("trade_size_category"),
],
)

trades_path = report_dir / "trades.parquet"
enhanced_df.write_parquet(trades_path)
else:
# Create empty DataFrame with schema
empty_df = pl.DataFrame(
{
"timestamp": [],
"order_id": [],
"trade_id": [],
"asset_id": [],
"side": [],
"quantity": [],
"price": [],
"commission": [],
"slippage": [],
"total_cost": [],
"notional_value": [],
"commission_rate": [],
"slippage_rate": [],
"direction": [],
"hour_of_day": [],
"day_of_month": [],
"day_of_week": [],
"trade_size_category": [],
},
schema={
"timestamp": pl.Datetime,
"order_id": pl.Utf8,
"trade_id": pl.Utf8,
"asset_id": pl.Utf8,
"side": pl.Utf8,
"quantity": pl.Float64,
"price": pl.Float64,
"commission": pl.Float64,
"slippage": pl.Float64,
"total_cost": pl.Float64,
"notional_value": pl.Float64,
"commission_rate": pl.Float64,
"slippage_rate": pl.Float64,
"direction": pl.Int8,
"hour_of_day": pl.UInt32,
"day_of_month": pl.UInt32,
"day_of_week": pl.UInt32,
"trade_size_category": pl.Utf8,
},
)
empty_df.write_parquet(report_dir / "trades.parquet")

def _save_positions(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Save positions data as Parquet."""
positions_df = report_data.get("positions")

if positions_df is not None and len(positions_df) > 0:
# Add derived columns
enhanced_df = positions_df.with_columns(
[
# Position direction
pl.when(pl.col("quantity") > 0)
.then(pl.lit("long"))
.when(pl.col("quantity")
<
0)
.then(pl.lit("short"))
.otherwise(pl.lit("flat"))
.alias("position_type"),
# Average cost per share
(pl.col("cost_basis") / pl.col("quantity")).alias("avg_cost_per_share"),
# Unrealized return percentage
(pl.col("unrealized_pnl") / pl.col("cost_basis")).alias(
"unrealized_return_pct",
),
# Total return percentage
(pl.col("total_pnl") / pl.col("cost_basis")).alias("total_return_pct"),
# Position weight (would need portfolio value for this)
pl.col("market_value").alias("position_weight_placeholder"),
],
)

positions_path = report_dir / "positions.parquet"
enhanced_df.write_parquet(positions_path)
else:
# Create empty DataFrame with schema
empty_df = pl.DataFrame(
{
"asset_id": [],
"quantity": [],
"cost_basis": [],
"last_price": [],
"market_value": [],
"unrealized_pnl": [],
"realized_pnl": [],
"total_pnl": [],
"position_type": [],
"avg_cost_per_share": [],
"unrealized_return_pct": [],
"total_return_pct": [],
"position_weight_placeholder": [],
},
schema={
"asset_id": pl.Utf8,
"quantity": pl.Float64,
"cost_basis": pl.Float64,
"last_price": pl.Float64,
"market_value": pl.Float64,
"unrealized_pnl": pl.Float64,
"realized_pnl": pl.Float64,
"total_pnl": pl.Float64,
"position_type": pl.Utf8,
"avg_cost_per_share": pl.Float64,
"unrealized_return_pct": pl.Float64,
"total_return_pct": pl.Float64,
"position_weight_placeholder": pl.Float64,
},
)
empty_df.write_parquet(report_dir / "positions.parquet")

def _create_summary_file(self, report_data: dict[str, Any], report_dir: Path) -> None:
"""Create a summary file with key statistics."""
summary_data = [
{
"report_name": report_data["metadata"]["report_name"],
"generated_at": report_data["metadata"]["generated_at"],
"total_return": report_data["performance"]["total_return"],
"total_pnl": report_data["performance"]["total_pnl"],
"sharpe_ratio": report_data["performance"].get("sharpe_ratio", None),
"max_drawdown": report_data["performance"]["max_drawdown"],
"win_rate": report_data["performance"]["win_rate"],
"num_trades": report_data["performance"]["num_trades"],
"total_commission": report_data["costs"]["total_commission"],
"total_slippage": report_data["costs"]["total_slippage"],
"initial_capital": report_data["portfolio"]["initial_cash"],
"final_equity": report_data["portfolio"]["final_equity"],
"max_leverage": report_data["risk"]["max_leverage"],
"max_concentration": report_data["risk"]["max_concentration"],
},
]

summary_df = pl.DataFrame(summary_data)
summary_path = report_dir / "summary.parquet"
summary_df.write_parquet(summary_path)

def load_report(self, report_dir: Path) -> dict[str, Any]:
"""
Load a previously generated Parquet report.

Args:
report_dir: Directory containing the Parquet report

Returns:
Dictionary with loaded report data
"""
if not report_dir.exists():
raise FileNotFoundError(f"Report directory not found: {report_dir}")

# Load metadata
metadata_path = report_dir / "metadata.json"
with open(metadata_path) as f:
metadata = json.load(f)

# Load data files
report_data = {
"metadata": metadata,
"performance_metrics": pl.read_parquet(report_dir / "performance_metrics.parquet"),
"equity_curve": pl.read_parquet(report_dir / "equity_curve.parquet"),
"trades": pl.read_parquet(report_dir / "trades.parquet"),
"positions": pl.read_parquet(report_dir / "positions.parquet"),
"summary": pl.read_parquet(report_dir / "summary.parquet"),
}

return report_data
</file>

<file path="src/qengine/reporting/reporter.py">
"""Reporter implementations for capturing backtest events and results."""

import logging
from datetime import datetime
from typing import Any

from qengine.core.event import Event

logger = logging.getLogger(__name__)


class Reporter:
"""Abstract base class for reporters."""

def on_start(self) -> None:
"""Called at start of backtest."""

def on_event(self, event: Event) -> None:
"""Called for each event processed."""

def on_end(self) -> None:
"""Called at end of backtest."""

def reset(self) -> None:
"""Reset reporter state."""

def get_report(self) -> Any:
"""Get the generated report."""


class InMemoryReporter(Reporter):
"""Reporter that stores all events and results in memory.

This reporter captures:
- All events processed during backtest
- Timestamps and event counts
- Summary statistics

Useful for debugging and analysis of backtest execution.
"""

def __init__(self, capture_all_events: bool = False):
"""Initialize in-memory reporter.

Args:
capture_all_events: If True, store all events (can use significant memory)
"""
self.capture_all_events = capture_all_events
self.events = []
self.event_counts = {}
self.start_time: datetime | None = None
self.end_time: datetime | None = None
self.first_event_time: datetime | None = None
self.last_event_time: datetime | None = None

def on_start(self) -> None:
"""Mark start of backtest."""
# Note: start_time will be set from first event
self.start_time = None
logger.debug("InMemoryReporter started")

def on_event(self, event: Event) -> None:
"""Capture event details.

Args:
event: Event to record
"""
# Track event counts by type
event_type = (
event.event_type.value if hasattr(event.event_type, "value") else str(event.event_type)
)
self.event_counts[event_type] = self.event_counts.get(event_type, 0) + 1

# Track first and last event timestamps
if self.first_event_time is None:
self.first_event_time = event.timestamp
self.last_event_time = event.timestamp

# Optionally store full event
if self.capture_all_events:
self.events.append(
{
"timestamp": event.timestamp,
"type": event_type,
"event": event,
},
)

def on_end(self) -> None:
"""Mark end of backtest."""
# Note: end_time will be set from last event
if not self.end_time:
self.end_time = self.last_event_time
logger.debug(f"InMemoryReporter finished. Total events: {sum(self.event_counts.values())}")

def get_report(self) -> dict[str, Any]:
"""Get summary report of captured events.

Returns:
Dictionary with event statistics and timing information
"""
total_events = sum(self.event_counts.values())
duration = (
(self.end_time - self.start_time).total_seconds()
if self.end_time and self.start_time
else 0
)

report = {
"summary": {
"total_events": total_events,
"event_types": len(self.event_counts),
"duration_seconds": duration,
"events_per_second": total_events / duration if duration > 0 else 0,
},
"event_counts": self.event_counts,
"timing": {
"start_time": self.start_time.isoformat() if self.start_time else None,
"end_time": self.end_time.isoformat() if self.end_time else None,
"first_event": self.first_event_time.isoformat() if self.first_event_time else None,
"last_event": self.last_event_time.isoformat() if self.last_event_time else None,
},
}

if self.capture_all_events:
report["events"] = self.events

# Add event type breakdown
if self.event_counts:
report["breakdown"] = {
event_type: {
"count": count,
"percentage": (count / total_events * 100) if total_events > 0 else 0,
}
for event_type, count in self.event_counts.items()
}

return report

def reset(self) -> None:
"""Reset reporter to initial state."""
self.events.clear()
self.event_counts.clear()
self.start_time = None
self.end_time = None
self.first_event_time = None
self.last_event_time = None


class ConsoleReporter(Reporter):
"""Reporter that logs events to console.

Useful for real-time monitoring of backtest progress.
"""

def __init__(self, log_level: str = "INFO", log_every_n: int = 1000):
"""Initialize console reporter.

Args:
log_level: Logging level (DEBUG, INFO, WARNING, ERROR)
log_every_n: Log summary every N events
"""
self.log_level = getattr(logging, log_level.upper(), logging.INFO)
self.log_every_n = log_every_n
self.event_count = 0
self.event_counts = {}

def on_start(self) -> None:
"""Log backtest start."""
logger.log(self.log_level, "=" * 60)
logger.log(self.log_level, "BACKTEST STARTED")
logger.log(self.log_level, "=" * 60)

def on_event(self, event: Event) -> None:
"""Log event if appropriate.

Args:
event: Event to potentially log
"""
self.event_count += 1
event_type = (
event.event_type.value if hasattr(event.event_type, "value") else str(event.event_type)
)
self.event_counts[event_type] = self.event_counts.get(event_type, 0) + 1

# Log periodic summary
if self.event_count % self.log_every_n == 0:
logger.log(
self.log_level,
f"Processed {self.event_count:,} events. "
f"Latest: {event.timestamp} | "
f"Types: {dict(sorted(self.event_counts.items()))}",
)

def on_end(self) -> None:
"""Log backtest completion."""
logger.log(self.log_level, "=" * 60)
logger.log(self.log_level, "BACKTEST COMPLETED")
logger.log(self.log_level, f"Total Events: {self.event_count:,}")
logger.log(self.log_level, f"Event Breakdown: {dict(sorted(self.event_counts.items()))}")
logger.log(self.log_level, "=" * 60)

def reset(self) -> None:
"""Reset reporter state."""
self.event_count = 0
self.event_counts.clear()

def get_report(self) -> dict[str, Any]:
"""Get simple report for console reporter.

Returns:
Event count summary
"""
return {
"total_events": self.event_count,
"event_counts": self.event_counts,
}


__all__ = [
"ConsoleReporter",
"InMemoryReporter",
"Reporter",
]
</file>

<file path="src/qengine/strategy/__init__.py">
"""Strategy framework for QEngine."""

from qengine.strategy.adapters import (
DataFrameAdapter,
ExternalStrategyInterface,
PITData,
StrategyAdapter,
StrategySignal,
)
from qengine.strategy.base import Strategy
from qengine.strategy.crypto_basis_adapter import (
CryptoBasisAdapter,
CryptoBasisExternalStrategy,
create_crypto_basis_strategy,
)

__all__ = [
"CryptoBasisAdapter",
"CryptoBasisExternalStrategy",
"DataFrameAdapter",
"ExternalStrategyInterface",
"PITData",
"Strategy",
"StrategyAdapter",
"StrategySignal",
"create_crypto_basis_strategy",
]
</file>

<file path="src/qengine/strategy/adapters.py">
"""
Strategy-QEngine Integration Bridge
==================================

This module provides adapters that bridge external strategy implementations
to QEngine's event-driven architecture. It allows existing strategies to run
within QEngine and benefit from advanced execution models.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Callable

import polars as pl

from qengine.core.event import Event, FillEvent, MarketEvent
from qengine.core.types import AssetId, OrderSide, OrderType, Price
from qengine.execution.order import Order
from qengine.strategy.base import Strategy


@dataclass
class PITData:
"""Point-in-time data snapshot for strategy decision making."""

timestamp: datetime
asset_data: dict[AssetId, dict[str, Any]]
market_prices: dict[AssetId, Price]

def get_price(self, asset_id: AssetId) -> Price | None:
"""Get current price for asset."""
return self.market_prices.get(asset_id)

def get_data(self, asset_id: AssetId, field: str) -> Any:
"""Get specific field for asset."""
return self.asset_data.get(asset_id, {}).get(field)


@dataclass
class StrategySignal:
"""Signal generated by external strategy."""

timestamp: datetime
asset_id: AssetId
position: float # Target position (-1 to 1, or absolute quantities)
confidence: float = 0.0
metadata: dict[str, Any] = None

def __post_init__(self):
if self.metadata is None:
self.metadata = {}


class ExternalStrategyInterface(ABC):
"""
Interface that external strategies must implement to integrate with QEngine.

This defines the minimal API needed for QEngine integration.
"""

@abstractmethod
def generate_signal(
self,
timestamp: datetime,
pit_data: PITData,
) -> StrategySignal | None:
"""
Generate trading signal based on point-in-time data.

Args:
timestamp: Current timestamp
pit_data: Point-in-time data snapshot

Returns:
Trading signal or None if no action needed
"""

@abstractmethod
def initialize(self) -> None:
"""Initialize strategy state."""

@abstractmethod
def finalize(self) -> None:
"""Cleanup strategy state."""


class StrategyAdapter(Strategy):
"""
Base adapter that bridges external strategies to QEngine.

This class handles the translation between QEngine's event-driven architecture
and external strategy APIs.
"""

def __init__(
self,
external_strategy: ExternalStrategyInterface,
position_sizer: Callable[[StrategySignal, float], float] | None = None,
risk_manager: Callable[[StrategySignal], bool] | None = None,
name: str | None = None,
):
"""
Initialize strategy adapter.

Args:
external_strategy: External strategy implementation
position_sizer: Optional position sizing function
risk_manager: Optional risk management function
name: Strategy name
"""
super().__init__(name=name or f"Adapter_{external_strategy.__class__.__name__}")
self.external_strategy = external_strategy
self.position_sizer = position_sizer or self._default_position_sizer
self.risk_manager = risk_manager or self._default_risk_manager

# State tracking
self._data_history: dict[AssetId, list[dict]] = {}
self._last_signals: dict[AssetId, StrategySignal] = {}
self._target_positions: dict[AssetId, float] = {}
self._pending_orders: dict[AssetId, list[Order]] = {}

def on_start(self) -> None:
"""Initialize external strategy."""
self.log("Starting strategy adapter")
self.external_strategy.initialize()

def on_end(self) -> None:
"""Cleanup external strategy."""
self.log("Stopping strategy adapter")
self.external_strategy.finalize()

def on_event(self, event: Event) -> None:
"""Route events to appropriate handlers."""
if isinstance(event, MarketEvent):
self.on_market_event(event)
elif isinstance(event, FillEvent):
self.on_fill_event(event)

def on_market_event(self, event: MarketEvent) -> None:
"""Process market event and generate signals."""
try:
# Update data history
self._update_data_history(event)

# Create point-in-time data snapshot
pit_data = self._create_pit_data(event.timestamp)

# Generate signal from external strategy
signal = self.external_strategy.generate_signal(event.timestamp, pit_data)

if signal:
self._process_signal(signal)

except Exception as e:
self.log(f"Error processing market event: {e}", level="ERROR")

def on_fill_event(self, event: FillEvent) -> None:
"""Update position tracking when fills occur."""
super().on_fill_event(event)

# Remove filled orders from pending
if event.asset_id in self._pending_orders:
self._pending_orders[event.asset_id] = [
order
for order in self._pending_orders[event.asset_id]
if order.order_id != event.order_id
]

self.log(f"Fill received: {event.asset_id} {event.fill_quantity} @ {event.fill_price}")

def _update_data_history(self, event: MarketEvent) -> None:
"""Update historical data for strategy calculations."""
if event.asset_id not in self._data_history:
self._data_history[event.asset_id] = []

data_point = {
"timestamp": event.timestamp,
"open": event.open,
"high": event.high,
"low": event.low,
"close": event.close,
"volume": event.volume,
}

self._data_history[event.asset_id].append(data_point)

# Keep only last N points for memory efficiency
if len(self._data_history[event.asset_id]) > 1000:
self._data_history[event.asset_id] = self._data_history[event.asset_id][-500:]

def _create_pit_data(self, timestamp: datetime) -> PITData:
"""Create point-in-time data snapshot."""
asset_data = {}
market_prices = {}

for asset_id, history in self._data_history.items():
if history:
# Get most recent data up to timestamp
valid_data = [d for d in history if d["timestamp"]<= timestamp]
if valid_data:
latest = valid_data[-1]
asset_data[asset_id] = latest
market_prices[asset_id] = latest["close"]

return PITData(
timestamp=timestamp,
asset_data=asset_data,
market_prices=market_prices,
)

def _process_signal(self, signal: StrategySignal) -> None:
"""Process signal and submit orders if needed."""
# Store last signal
self._last_signals[signal.asset_id] = signal

# Apply risk management
if not self.risk_manager(signal):
self.log(f"Signal rejected by risk manager: {signal.asset_id}", level="WARNING")
return

# Calculate position size
current_cash = self.broker.get_cash() if hasattr(self.broker, "get_cash") else 100000
position_size = self.position_sizer(signal, current_cash)

# Get current position
current_position = self._positions.get(signal.asset_id, 0)

# Calculate required trade
trade_quantity = position_size - current_position

if abs(trade_quantity) > 0.001: # Minimum trade threshold
self._submit_rebalance_order(signal.asset_id, trade_quantity)

def _submit_rebalance_order(self, asset_id: AssetId, quantity: float) -> None:
"""Submit order to rebalance to target position."""
if abs(quantity)
<
0.001:
return

# Determine order side
side = OrderSide.BUY if quantity > 0 else OrderSide.SELL
abs_quantity = abs(quantity)

# Create market order for immediate execution
order = Order(
asset_id=asset_id,
order_type=OrderType.MARKET,
side=side,
quantity=abs_quantity,
)

# Submit through broker
if hasattr(self.broker, "submit_order"):
order_id = self.broker.submit_order(order)

# Track pending order
if asset_id not in self._pending_orders:
self._pending_orders[asset_id] = []
self._pending_orders[asset_id].append(order)

self.log(f"Order submitted: {order_id} - {side.value} {abs_quantity} {asset_id}")
else:
self.log("No broker available for order submission", level="ERROR")

def _default_position_sizer(self, signal: StrategySignal, cash: float) -> float:
"""Default position sizing based on signal position and confidence."""
# Use signal position directly, scaled by confidence
base_position = signal.position * signal.confidence

# Simple position sizing - use portion of cash based on signal
if abs(base_position) > 0:
position_value = cash * 0.1 # 10% of cash
return base_position * position_value # Signed position value

return 0.0

def _default_risk_manager(self, signal: StrategySignal) -> bool:
"""Default risk management - always allow signals."""
# Basic checks
if not signal.asset_id:
return False
if abs(signal.position) > 10: # Sanity check on position size
return False
return True

def get_strategy_state(self) -> dict[str, Any]:
"""Get current strategy state for debugging."""
return {
"name": self.name,
"current_positions": self.current_positions,
"target_positions": self._target_positions.copy(),
"last_signals": {k: v.__dict__ for k, v in self._last_signals.items()},
"pending_orders": {k: len(v) for k, v in self._pending_orders.items()},
"data_history_lengths": {k: len(v) for k, v in self._data_history.items()},
}


class DataFrameAdapter(StrategyAdapter):
"""
Adapter for strategies that work with DataFrame-based data.

This adapter maintains a rolling DataFrame of market data that can be
accessed by external strategies for calculations.
"""

def __init__(
self,
external_strategy: ExternalStrategyInterface,
window_size: int = 1000,
**kwargs,
):
"""
Initialize DataFrame adapter.

Args:
external_strategy: External strategy implementation
window_size: Size of rolling data window
**kwargs: Additional arguments for StrategyAdapter
"""
super().__init__(external_strategy, **kwargs)
self.window_size = window_size
self._dataframes: dict[AssetId, pl.DataFrame] = {}

def _update_data_history(self, event: MarketEvent) -> None:
"""Update DataFrame with new market data."""
# Call parent to maintain backward compatibility
super()._update_data_history(event)

# Create new row
new_row = pl.DataFrame(
{
"timestamp": [event.timestamp],
"asset_id": [event.asset_id],
"open": [event.open],
"high": [event.high],
"low": [event.low],
"close": [event.close],
"volume": [event.volume],
},
)

# Update or create DataFrame
if event.asset_id not in self._dataframes:
self._dataframes[event.asset_id] = new_row
else:
self._dataframes[event.asset_id] = pl.concat(
[
self._dataframes[event.asset_id],
new_row,
],
)

# Maintain window size
if len(self._dataframes[event.asset_id]) > self.window_size:
self._dataframes[event.asset_id] = self._dataframes[event.asset_id].tail(
self.window_size,
)

def get_dataframe(self, asset_id: AssetId) -> pl.DataFrame | None:
"""Get DataFrame for asset."""
return self._dataframes.get(asset_id)

def get_all_dataframes(self) -> dict[AssetId, pl.DataFrame]:
"""Get all DataFrames."""
return self._dataframes.copy()
</file>

<file path="src/qengine/strategy/base.py">
"""Base strategy class and interfaces for QEngine."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any

from qengine.core.event import Event, FillEvent, MarketEvent, SignalEvent
from qengine.core.types import AssetId, EventType, OrderSide


class StrategyState(Enum):
"""Strategy lifecycle states."""

INITIALIZED = "initialized"
STARTING = "starting"
RUNNING = "running"
STOPPING = "stopping"
STOPPED = "stopped"


@dataclass
class StrategyContext:
"""Context object containing strategy runtime information."""

start_time: datetime
end_time: datetime
initial_capital: float
commission_model: Any | None = None
slippage_model: Any | None = None
data_feeds: list[Any] = field(default_factory=list)
parameters: dict[str, Any] = field(default_factory=dict)


class Strategy(ABC):
"""
Abstract base class for all trading strategies.

This class defines the interface that all strategies must implement.
Strategies receive events through the on_event method and can submit
orders through the broker interface.
"""

def __init__(self, name: str | None = None):
"""
Initialize the strategy.

Args:
name: Optional name for the strategy
"""
self.name = name or self.__class__.__name__
self.state = StrategyState.INITIALIZED
self.broker = None # Will be injected by the engine
self.data = None # PIT data accessor
self.context = None # Strategy context
self._subscriptions: set[tuple] = set()
self._positions: dict[AssetId, float] = {}
self._orders: list[Any] = []
self._trades: list[Any] = []

def on_start(self, portfolio=None, event_bus=None) -> None:
"""
Called once when the strategy starts.

Args:
portfolio: Portfolio instance for position tracking (optional)
event_bus: Event bus for publishing orders (optional)

Override this method to perform one-time initialization tasks like:
- Setting up indicators
- Subscribing to data feeds
- Initializing internal state
"""
# Store references if provided
if portfolio is not None:
self.portfolio = portfolio
if event_bus is not None:
self.event_bus = event_bus

@abstractmethod
def on_event(self, event: Event) -> None:
"""
Process an event.

This is the main method where strategy logic is implemented.
It's called for every event the strategy is subscribed to.

Event routing is now properly fixed to ensure strategies receive
all relevant events including MarketEvent, FillEvent, etc.

Args:
event: The event to process (MarketEvent, FillEvent, etc.)
"""

def on_market_event(self, event: MarketEvent) -> None:
"""
Process a market data event.

Override this for specialized market data handling.

Args:
event: Market data event
"""

def on_signal_event(self, event: SignalEvent) -> None:
"""
Process an ML signal event.

Override this for signal-based strategies.

Args:
event: Signal event from ML model
"""

def on_fill_event(self, event: FillEvent) -> None:
"""
Process an order fill event.

Override this to track fills and update internal state.

Args:
event: Fill event
"""
# Default implementation updates position tracking
if event.side in [OrderSide.BUY, OrderSide.COVER]:
self._positions[event.asset_id] = (
self._positions.get(event.asset_id, 0) + event.fill_quantity
)
else:
self._positions[event.asset_id] = (
self._positions.get(event.asset_id, 0) - event.fill_quantity
)

def on_end(self) -> None:
"""
Called once when the strategy stops.

Override this to perform cleanup tasks like:
- Closing positions
- Saving state
- Final analysis
"""

def before_trading_start(self) -> None:
"""
Called before the start of each trading day.

Override this for daily preparation tasks like:
- Updating universe
- Recalculating signals
- Adjusting parameters
"""

def after_trading_end(self) -> None:
"""
Called after the end of each trading day.

Override this for end-of-day tasks like:
- Recording metrics
- Rebalancing
- Risk calculations
"""

def subscribe(
self,
asset: AssetId | None = None,
event_type: EventType | None = None,
**kwargs,
) -> None:
"""
Subscribe to specific events.

Args:
asset: Asset to subscribe to (None for all)
event_type: Type of events to receive
**kwargs: Additional subscription parameters
"""
subscription = (asset, event_type, tuple(kwargs.items()))
self._subscriptions.add(subscription)

def unsubscribe(
self,
asset: AssetId | None = None,
event_type: EventType | None = None,
**kwargs,
) -> None:
"""
Unsubscribe from specific events.

Args:
asset: Asset to unsubscribe from
event_type: Type of events to stop receiving
**kwargs: Additional parameters
"""
subscription = (asset, event_type, tuple(kwargs.items()))
self._subscriptions.discard(subscription)

@property
def current_positions(self) -> dict[AssetId, float]:
"""Get current position quantities by asset."""
return self._positions.copy()

@property
def is_flat(self) -> bool:
"""Check if strategy has no positions."""
return all(qty == 0 for qty in self._positions.values())

def log(self, message: str, level: str = "INFO", timestamp: datetime | None = None) -> None:
"""
Log a message.

Args:
message: Message to log
level: Log level (INFO, WARNING, ERROR, DEBUG)
timestamp: Simulation timestamp (if None, uses wall clock time for compatibility)
"""
# Use simulation time if provided, otherwise fall back to wall clock time
if timestamp:
time_str = timestamp.isoformat()
else:
time_str = datetime.now().isoformat()
print(f"[{time_str}] [{self.name}] [{level}] {message}")

def __repr__(self) -> str:
return f"{self.__class__.__name__}(name='{self.name}', state={self.state})"


class SignalStrategy(Strategy):
"""
Base class for signal-based strategies.

This provides a simpler interface for strategies that primarily
react to ML signals rather than raw market data.
"""

def __init__(self, name: str | None = None, signal_threshold: float = 0.5):
"""
Initialize signal strategy.

Args:
name: Strategy name
signal_threshold: Threshold for acting on signals
"""
super().__init__(name)
self.signal_threshold = signal_threshold
self._signal_history: dict[AssetId, list[float]] = {}

def on_event(self, event: Event) -> None:
"""Route events to appropriate handlers."""
if isinstance(event, SignalEvent):
self.on_signal_event(event)
elif isinstance(event, MarketEvent):
self.on_market_event(event)
elif isinstance(event, FillEvent):
self.on_fill_event(event)

def on_signal_event(self, event: SignalEvent) -> None:
"""
Process signal and make trading decision.

Args:
event: Signal event
"""
# Track signal history
if event.asset_id not in self._signal_history:
self._signal_history[event.asset_id] = []
self._signal_history[event.asset_id].append(event.signal_value)

# Make trading decision based on signal
self.process_signal(event.asset_id, event.signal_value, event.confidence)

@abstractmethod
def process_signal(
self,
asset_id: AssetId,
signal_value: float,
confidence: float | None,
) -> None:
"""
Process a signal and decide on action.

Args:
asset_id: Asset the signal is for
signal_value: Signal value (typically -1 to 1)
confidence: Optional confidence score
"""


class IndicatorStrategy(Strategy):
"""
Base class for indicator-based strategies.

Provides utilities for managing technical indicators.
"""

def __init__(self, name: str | None = None):
"""Initialize indicator strategy."""
super().__init__(name)
self._indicators: dict[str, Any] = {}

def add_indicator(self, name: str, indicator: Any) -> None:
"""
Add a technical indicator.

Args:
name: Name for the indicator
indicator: Indicator instance
"""
self._indicators[name] = indicator

def get_indicator(self, name: str) -> Any:
"""
Get an indicator by name.

Args:
name: Indicator name

Returns:
Indicator instance
"""
return self._indicators.get(name)

def update_indicators(self, price: float) -> None:
"""
Update all indicators with new price.

Args:
price: Latest price
"""
for indicator in self._indicators.values():
if hasattr(indicator, "update"):
indicator.update(price)
</file>

<file path="src/qengine/strategy/crypto_basis_adapter.py">
"""
Crypto Basis Strategy QEngine Adapter
=====================================

Adapter that integrates the CryptoBasisStrategy with QEngine's event-driven architecture.
This allows the basis trading strategy to run within QEngine and benefit from
advanced execution models, slippage simulation, and commission structures.
"""

from dataclasses import dataclass, field
from datetime import datetime

import numpy as np

from qengine.core.types import AssetId
from qengine.strategy.adapters import (
DataFrameAdapter,
ExternalStrategyInterface,
PITData,
StrategySignal,
)


@dataclass
class BasisState:
"""State tracking for basis calculations."""

spot_prices: list[float] = field(default_factory=list)
futures_prices: list[float] = field(default_factory=list)
timestamps: list[datetime] = field(default_factory=list)
basis_history: list[float] = field(default_factory=list)

# Rolling statistics
basis_mean: float | None = None
basis_std: float | None = None
current_z_score: float | None = None

# Position tracking
current_position: float = 0.0
entry_basis: float | None = None
entry_timestamp: datetime | None = None


class CryptoBasisExternalStrategy(ExternalStrategyInterface):
"""
External strategy implementation for crypto basis trading.

This wraps the original CryptoBasisStrategy logic in the interface
required for QEngine integration.
"""

def __init__(
self,
spot_asset_id: AssetId = "BTC",
futures_asset_id: AssetId = "BTC_FUTURE",
lookback_window: int = 120,
entry_threshold: float = 2.0,
exit_threshold: float = 0.5,
max_position: float = 0.3,
min_data_points: int = 50,
):
"""
Initialize crypto basis strategy.

Args:
spot_asset_id: Asset ID for spot prices
futures_asset_id: Asset ID for futures prices
lookback_window: Number of periods for rolling statistics
entry_threshold: Z-score threshold for entry
exit_threshold: Z-score threshold for exit
max_position: Maximum position size
min_data_points: Minimum data points before generating signals
"""
self.spot_asset_id = spot_asset_id
self.futures_asset_id = futures_asset_id
self.lookback_window = lookback_window
self.entry_threshold = entry_threshold
self.exit_threshold = exit_threshold
self.max_position = max_position
self.min_data_points = min_data_points

# State
self.state = BasisState()
self.volatility_lookback = 20

def initialize(self) -> None:
"""Initialize strategy state."""
self.state = BasisState()

def finalize(self) -> None:
"""Cleanup strategy state."""
# Log final statistics
if self.state.basis_history:
total_signals = len([b for b in self.state.basis_history if b != 0])
print(f"[CryptoBasisStrategy] Generated {total_signals} signals")
print(f"[CryptoBasisStrategy] Final position: {self.state.current_position}")

def generate_signal(
self,
timestamp: datetime,
pit_data: PITData,
) -> StrategySignal | None:
"""
Generate trading signal based on basis analysis.

Args:
timestamp: Current timestamp
pit_data: Point-in-time data snapshot

Returns:
Trading signal or None
"""
# Get current prices
spot_price = pit_data.get_price(self.spot_asset_id)
futures_price = pit_data.get_price(self.futures_asset_id)

if spot_price is None or futures_price is None:
return None

# Update state with new data
self._update_state(timestamp, spot_price, futures_price)

# Calculate current statistics if we have enough data
if len(self.state.basis_history) >= 2:
self._calculate_statistics()

# Need minimum data points for signal generation
if len(self.state.basis_history)
< self.min_data_points:
  return None

# Generate signal
signal = self._generate_basis_signal(timestamp)

return signal

def _update_state(
self,
timestamp: datetime,
spot_price: float,
futures_price: float,
) -> None:
"""Update internal state with new price data."""
# Calculate basis
basis = futures_price - spot_price

# Update history
self.state.timestamps.append(timestamp)
self.state.spot_prices.append(spot_price)
self.state.futures_prices.append(futures_price)
self.state.basis_history.append(basis)

# Maintain window size
if len(self.state.basis_history) > self.lookback_window:
self.state.timestamps = self.state.timestamps[-self.lookback_window :]
self.state.spot_prices = self.state.spot_prices[-self.lookback_window :]
self.state.futures_prices = self.state.futures_prices[-self.lookback_window :]
self.state.basis_history = self.state.basis_history[-self.lookback_window :]

def _calculate_statistics(self) -> None:
"""Calculate rolling statistics for basis."""
if len(self.state.basis_history)
<
2:
return

basis_array = np.array(self.state.basis_history)

# Rolling mean and std
self.state.basis_mean = np.mean(basis_array)
self.state.basis_std = np.std(basis_array)

# Current z-score
if self.state.basis_std > 1e-8: # Avoid division by zero
current_basis = self.state.basis_history[-1]
self.state.current_z_score = (
current_basis - self.state.basis_mean
) / self.state.basis_std
else:
self.state.current_z_score = 0.0

def _generate_basis_signal(self, timestamp: datetime) -> StrategySignal | None:
"""Generate trading signal based on basis z-score."""
if self.state.current_z_score is None:
return None

z_score = self.state.current_z_score
current_basis = self.state.basis_history[-1]

# Calculate volatility for position sizing
spot_returns = np.diff(np.log(self.state.spot_prices[-self.volatility_lookback :]))
volatility = np.std(spot_returns) if len(spot_returns) > 1 else 0.01

position = 0.0
confidence = 0.0

# Entry logic
if abs(self.state.current_position)
<
1e-6: # Flat position
if z_score > self.entry_threshold:
# Basis too high: short futures, long spot (negative position)
position = -1.0
confidence = min((z_score - self.entry_threshold) / 2, 1.0)
self.state.entry_basis = current_basis
self.state.entry_timestamp = timestamp

elif z_score
<
-self.entry_threshold:
# Basis too low: long futures, short spot (positive position)
position = 1.0
confidence = min((abs(z_score) - self.entry_threshold) / 2, 1.0)
self.state.entry_basis = current_basis
self.state.entry_timestamp = timestamp

# Exit logic
else:
if self.state.current_position > 0: # Long futures/short spot
if z_score > -self.exit_threshold: # Basis normalized
position = 0.0
confidence = 1.0
elif z_score > self.entry_threshold: # Reversal
position = -1.0
confidence = min((z_score - self.entry_threshold) / 2, 1.0)
else:
position = self.state.current_position # Hold

elif self.state.current_position
<
0: # Short futures/long spot
if z_score
< self.exit_threshold:
# Basis normalized
position = 0.0
confidence = 1.0
elif z_score
<
-self.entry_threshold: # Reversal
position = 1.0
confidence = min((abs(z_score) - self.entry_threshold) / 2, 1.0)
else:
position = self.state.current_position # Hold

# Apply volatility adjustment and position limits
if position != 0:
volatility_scalar = 1 / (1 + volatility * 10) # Reduce size in high vol
position = position * min(confidence * volatility_scalar, self.max_position)

# Update position state
old_position = self.state.current_position
self.state.current_position = position

# Only generate signal if position changed significantly
if abs(position - old_position) > 0.001:
return StrategySignal(
timestamp=timestamp,
asset_id=self.spot_asset_id, # Use spot as primary asset
position=position,
confidence=confidence,
metadata={
"basis": current_basis,
"z_score": z_score,
"volatility": volatility,
"entry_basis": self.state.entry_basis,
"strategy_type": "crypto_basis",
"spot_price": self.state.spot_prices[-1],
"futures_price": self.state.futures_prices[-1],
},
)

return None

def get_current_statistics(self) -> dict[str, float]:
"""Get current basis statistics for monitoring."""
if not self.state.basis_history:
return {}

return {
"current_basis": self.state.basis_history[-1],
"basis_mean": self.state.basis_mean or 0,
"basis_std": self.state.basis_std or 0,
"z_score": self.state.current_z_score or 0,
"current_position": self.state.current_position,
"data_points": len(self.state.basis_history),
}


class CryptoBasisAdapter(DataFrameAdapter):
"""
Complete adapter for crypto basis trading strategy.

This combines the external strategy with DataFrame support
and provides a complete QEngine integration.
"""

def __init__(
self,
spot_asset_id: AssetId = "BTC",
futures_asset_id: AssetId = "BTC_FUTURE",
lookback_window: int = 120,
entry_threshold: float = 2.0,
exit_threshold: float = 0.5,
max_position: float = 0.3,
position_scaling: float = 0.1,
window_size: int = 1000,
**kwargs,
):
"""
Initialize crypto basis adapter.

Args:
spot_asset_id: Asset ID for spot prices
futures_asset_id: Asset ID for futures prices
lookback_window: Rolling window for statistics
entry_threshold: Z-score threshold for entries
exit_threshold: Z-score threshold for exits
max_position: Maximum position size
position_scaling: Scaling factor for position size
**kwargs: Additional arguments for DataFrameAdapter
"""
# Create external strategy
external_strategy = CryptoBasisExternalStrategy(
spot_asset_id=spot_asset_id,
futures_asset_id=futures_asset_id,
lookback_window=lookback_window,
entry_threshold=entry_threshold,
exit_threshold=exit_threshold,
max_position=max_position,
)

# Create custom position sizer
def basis_position_sizer(signal: StrategySignal, cash: float) -> float:
# Scale position based on available cash and signal strength
base_value = cash * position_scaling # Use X% of cash
position_value = base_value * abs(signal.position) * signal.confidence

# Return signed position value
return position_value if signal.position > 0 else -position_value

# Filter kwargs for parent constructor
parent_kwargs = {
k: v for k, v in kwargs.items() if k in ["position_sizer", "risk_manager", "name"]
}

# Initialize adapter
super().__init__(
external_strategy=external_strategy,
window_size=window_size,
position_sizer=basis_position_sizer,
name=f"CryptoBasisAdapter_{spot_asset_id}_{futures_asset_id}",
**parent_kwargs,
)

# Store configuration
self.spot_asset_id = spot_asset_id
self.futures_asset_id = futures_asset_id
self._last_statistics = {}

# Event synchronization for multi-asset basis calculation
self._event_buffer: dict[datetime, dict[AssetId, MarketEvent]] = {}
self._required_assets = {spot_asset_id, futures_asset_id}

def on_start(self) -> None:
"""Start strategy and subscribe to data feeds."""
super().on_start()

# Subscribe to both spot and futures data
self.subscribe(asset=self.spot_asset_id, event_type="market")
self.subscribe(asset=self.futures_asset_id, event_type="market")

self.log(f"Subscribed to {self.spot_asset_id} (spot) and {self.futures_asset_id} (futures)")

def on_market_event(self, event) -> None:
"""Process market events with synchronization for basis calculation."""
# Buffer the event by timestamp and asset
if event.timestamp not in self._event_buffer:
self._event_buffer[event.timestamp] = {}

self._event_buffer[event.timestamp][event.asset_id] = event

# Check if we have both required assets for this timestamp
buffered_assets = set(self._event_buffer[event.timestamp].keys())

if self._required_assets.issubset(buffered_assets):
# We have both spot and futures data - process synchronously
self._process_synchronized_events(event.timestamp)

# Clean up old buffer entries (keep only last 10 timestamps)
timestamps = sorted(self._event_buffer.keys())
if len(timestamps) > 10:
for old_ts in timestamps[:-10]:
del self._event_buffer[old_ts]
else:
# Still waiting for the other asset - update both DataFrame and parent's history
super()._update_data_history(event)

def _process_synchronized_events(self, timestamp: datetime) -> None:
"""Process events when both spot and futures data are available."""
buffered_events = self._event_buffer[timestamp]

# Process both events to update DataFrames AND internal history
for event in buffered_events.values():
# Call parent's update which maintains _data_history dict
super()._update_data_history(event)

# Now create PITData - parent's _create_pit_data should have both prices now
try:
# Create point-in-time data snapshot with both prices
pit_data = self._create_pit_data(timestamp)

# Debug: check if PITData has both prices
spot_price = pit_data.get_price(self.spot_asset_id)
futures_price = pit_data.get_price(self.futures_asset_id)

if spot_price is None or futures_price is None:
self.log(
f"Missing prices in PITData: spot={spot_price}, futures={futures_price}",
level="WARNING",
)
return

# Generate signal from external strategy (now has both prices)
signal = self.external_strategy.generate_signal(timestamp, pit_data)

if signal:
self.log(
f"Signal generated: pos={signal.position:.3f}, conf={signal.confidence:.3f}",
)
self._process_signal(signal)
else:
# Check if we expected a signal but didn't get one
stats = self.external_strategy.get_current_statistics()
if abs(stats.get("z_score", 0)) > 1.0:
self.log(f"Expected signal but got None: z_score={stats.get('z_score', 0):.2f}")

# Update statistics for monitoring
if hasattr(self.external_strategy, "get_current_statistics"):
self._last_statistics = self.external_strategy.get_current_statistics()

# Log all statistics for debugging
self.log(
f"Basis stats: z={self._last_statistics['z_score']:.3f}, "
f"mean={self._last_statistics.get('basis_mean', 0):.1f}, "
f"std={self._last_statistics.get('basis_std', 0):.3f}, "
f"current={self._last_statistics.get('current_basis', 0):.0f}, "
f"data_pts={self._last_statistics.get('data_points', 0)}",
level="INFO",
)

except Exception as e:
self.log(f"Error processing synchronized events: {e}", level="ERROR")

def get_strategy_diagnostics(self) -> dict[str, any]:
"""Get detailed diagnostics for strategy monitoring."""
base_state = self.get_strategy_state()

# Add basis-specific statistics
base_state.update(
{
"basis_statistics": self._last_statistics,
"spot_asset": self.spot_asset_id,
"futures_asset": self.futures_asset_id,
"dataframe_sizes": {
asset: len(df) for asset, df in self.get_all_dataframes().items()
},
},
)

return base_state


def create_crypto_basis_strategy(
spot_asset_id: AssetId = "BTC",
futures_asset_id: AssetId = "BTC_FUTURE",
**strategy_params,
) -> CryptoBasisAdapter:
"""
Factory function to create a crypto basis strategy.

Args:
spot_asset_id: Asset ID for spot prices
futures_asset_id: Asset ID for futures prices
**strategy_params: Strategy parameters

Returns:
Configured CryptoBasisAdapter
"""
return CryptoBasisAdapter(
spot_asset_id=spot_asset_id,
futures_asset_id=futures_asset_id,
**strategy_params,
)
</file>

<file path="src/qengine/__init__.py">
"""QEngine - A state-of-the-art event-driven backtesting engine.

QEngine is designed for high-performance backtesting of machine learning-driven
trading strategies with a focus on preventing data leakage and providing
realistic market simulation.
"""

__version__ = "0.1.0"

from qengine.core import Clock, Event, EventBus
from qengine.data import DataFeed
from qengine.engine import BacktestEngine, BacktestResults
from qengine.strategy import Strategy

__all__ = [
"BacktestEngine",
"BacktestResults",
"Clock",
"DataFeed",
"Event",
"EventBus",
"Strategy",
]
</file>

<file path="src/qengine/engine.py">
"""Main backtest engine that orchestrates the simulation."""

import logging
from datetime import datetime
from typing import Any

import polars as pl

from qengine.core.clock import Clock
from qengine.core.event import EventBus, EventType
from qengine.data.feed import DataFeed
from qengine.execution.broker import Broker
from qengine.portfolio.portfolio import Portfolio
from qengine.reporting.reporter import Reporter
from qengine.strategy.base import Strategy

logger = logging.getLogger(__name__)


class BacktestEngine:
"""Main backtesting engine that coordinates all components.

The engine follows an event-driven architecture where:
1. Data feeds generate market events
2. Strategies consume events and generate signals/orders
3. Broker executes orders and generates fills
4. Portfolio tracks positions and P&L
5. Reporter captures results

Example:
>>> from ml4t_backtest import BacktestEngine
>>> from qengine.data import ParquetDataFeed
>>> from qengine.strategy import BuyAndHoldStrategy
>>>
>>> engine = BacktestEngine(
... data_feed=ParquetDataFeed("data.parquet"),
... strategy=BuyAndHoldStrategy(),
... initial_capital=100000
... )
>>> results = engine.run()
"""

def __init__(
self,
data_feed: DataFeed,
strategy: Strategy,
broker: Broker | None = None,
portfolio: Portfolio | None = None,
reporter: Reporter | None = None,
initial_capital: float = 100000.0,
currency: str = "USD",
use_priority_queue: bool = True,
corporate_actions: list | None = None,
):
"""Initialize the backtest engine.

Args:
data_feed: Source of market data events
strategy: Trading strategy to execute
broker: Order execution broker (default: SimulationBroker)
portfolio: Portfolio tracker (default: SimplePortfolio)
reporter: Results reporter (default: InMemoryReporter)
initial_capital: Starting capital
currency: Base currency for the portfolio
use_priority_queue: Use priority queue for event ordering
corporate_actions: List of corporate actions to process during backtest
"""
self.data_feed = data_feed
self.strategy = strategy
self.initial_capital = initial_capital
self.currency = currency

# Create event bus for communication
self.event_bus = EventBus(use_priority_queue=use_priority_queue)

# Create clock for time management
self.clock = Clock()

# Initialize broker if not provided
if broker is None:
from qengine.execution.broker import SimulationBroker

self.broker = SimulationBroker()
else:
self.broker = broker

# Initialize portfolio if not provided
if portfolio is None:
from qengine.portfolio.simple import SimplePortfolio

self.portfolio = SimplePortfolio(initial_capital=initial_capital, currency=currency)
else:
self.portfolio = portfolio

# Initialize reporter if not provided
if reporter is None:
from qengine.reporting.reporter import InMemoryReporter

self.reporter = InMemoryReporter()
else:
self.reporter = reporter

# Initialize corporate action processor
from qengine.execution.corporate_actions import CorporateActionProcessor

self.corporate_action_processor = CorporateActionProcessor()
if corporate_actions:
for action in corporate_actions:
self.corporate_action_processor.add_action(action)

# Wire up event handlers
self._setup_event_handlers()

# Statistics
self.events_processed = 0
self.start_time: datetime | None = None
self.end_time: datetime | None = None

def _setup_event_handlers(self) -> None:
"""Connect components via event subscriptions."""
# Strategy subscribes to market and fill events
# Note: Using on_event allows strategies to route events internally
self.event_bus.subscribe(EventType.MARKET, self.strategy.on_event)
self.event_bus.subscribe(EventType.FILL, self.strategy.on_event)

# Broker subscribes to order events AND market events (for fill checking)
self.event_bus.subscribe(EventType.ORDER, self.broker.on_order_event)
self.event_bus.subscribe(EventType.MARKET, self.broker.on_market_event)

# Portfolio subscribes to fill events
self.event_bus.subscribe(EventType.FILL, self.portfolio.on_fill_event)

# Reporter subscribes to all events for logging
for event_type in EventType:
self.event_bus.subscribe(event_type, self.reporter.on_event)

def run(
self,
start_date: datetime | None = None,
end_date: datetime | None = None,
max_events: int | None = None,
) -> dict[str, Any]:
"""Run the backtest simulation.

Args:
start_date: Start date for backtest (None = use data start)
end_date: End date for backtest (None = use data end)
max_events: Maximum events to process (for debugging)

Returns:
Dictionary containing backtest results including:
- trades: DataFrame of executed trades
- positions: DataFrame of position history
- returns: Series of strategy returns
- metrics: Performance metrics dict
- events_processed: Number of events processed
"""
logger.info("Starting backtest engine")
self.start_time = datetime.now() # Wall clock time for performance measurement

# Initialize components
self.strategy.on_start(self.portfolio, self.event_bus)
self.broker.initialize(self.portfolio, self.event_bus)
self.portfolio.initialize()
self.reporter.on_start()

# Initialize clock with data feed's time range
if hasattr(self.data_feed, "get_time_range"):
data_start, data_end = self.data_feed.get_time_range()
self.clock.advance_to(start_date or data_start)

# Main event loop
self.events_processed = 0

while not self.data_feed.is_exhausted:
# Check max events limit
if max_events and self.events_processed >= max_events:
logger.info(f"Reached max events limit: {max_events}")
break

# Get next market event from data feed
market_event = self.data_feed.get_next_event()
if market_event is None:
break

# Update clock
self.clock.advance_to(market_event.timestamp)

# Publish market event FIRST (this allows pending orders to be filled)
self.event_bus.publish(market_event)

# Process all events in queue (market -> signal -> order -> fill)
events_in_cycle = self.event_bus.process_all()
self.events_processed += events_in_cycle + 1 # +1 for market event

# Process corporate actions AFTER fills (at start of each trading day)
# Check if we've moved to a new date
if hasattr(self, "_last_processed_date"):
current_date = market_event.timestamp.date()
if current_date != self._last_processed_date:
# Process any pending corporate actions
# Convert Position objects to quantities for corporate action processor
current_positions = {
asset_id: position.quantity
for asset_id, position in self.portfolio.positions.items()
}
open_orders = self.broker.get_open_orders() # Get all open orders
cash = self.portfolio.cash

# Process corporate actions
updated_positions, updated_orders, updated_cash, notifications = (
self.corporate_action_processor.process_actions(
current_date, current_positions, open_orders, cash
)
)

# Update portfolio and broker with adjustments
if notifications:
for notification in notifications:
logger.info(f"Corporate Action: {notification}")

# Apply position adjustments to Portfolio objects
for asset_id, new_quantity in updated_positions.items():
if asset_id in self.portfolio.positions:
# Update existing position quantity
self.portfolio.positions[asset_id].quantity = new_quantity
elif new_quantity != 0:
# Create new position if needed
from qengine.portfolio.portfolio import Position

self.portfolio.positions[asset_id] = Position(
asset_id=asset_id, quantity=new_quantity
)

# Remove positions with zero quantity
assets_to_remove = [
asset_id
for asset_id, position in self.portfolio.positions.items()
if position.quantity == 0
]
for asset_id in assets_to_remove:
del self.portfolio.positions[asset_id]

# Update cash
self.portfolio.cash = updated_cash
# Note: Orders are updated in place, so broker already has updated orders

self._last_processed_date = current_date
else:
self._last_processed_date = market_event.timestamp.date()

# Update portfolio valuations
self.portfolio.update_market_value(market_event)

# Log progress periodically
if self.events_processed % 10000 == 0:
logger.info(f"Processed {self.events_processed:,} events")

# Finalize
self.strategy.on_end()
self.broker.finalize()
self.portfolio.finalize()
self.reporter.on_end()

self.end_time = datetime.now() # Wall clock time for performance measurement
duration = (self.end_time - self.start_time).total_seconds()

logger.info(
f"Backtest complete: {self.events_processed:,} events in {duration:.2f}s "
f"({self.events_processed / duration:.0f} events/sec)",
)

# Compile results
results = self._compile_results()
return results

def _compile_results(self) -> dict[str, Any]:
"""Compile backtest results from all components.

Returns:
Dictionary with comprehensive backtest results
"""
# Get data from components
trades = self.broker.get_trades()
positions = self.portfolio.get_positions()
returns = self.portfolio.get_returns()
metrics = self.portfolio.calculate_metrics()

# Add engine statistics
duration = (self.end_time - self.start_time).total_seconds() if self.end_time else 0

results = {
"trades": trades,
"positions": positions,
"returns": returns,
"metrics": metrics,
"events_processed": self.events_processed,
"duration_seconds": duration,
"events_per_second": self.events_processed / duration if duration > 0 else 0,
"initial_capital": self.initial_capital,
"final_value": self.portfolio.get_total_value(),
"total_return": (self.portfolio.get_total_value() / self.initial_capital - 1) * 100,
}

# Add reporter data if available
if hasattr(self.reporter, "get_report"):
results["report"] = self.reporter.get_report()

return results

def reset(self) -> None:
"""Reset the engine for another run."""
logger.info("Resetting backtest engine")

# Clear event bus
self.event_bus.clear()

# Reset components
self.data_feed.reset()
self.strategy.reset()
self.broker.reset()
self.portfolio.reset()
self.reporter.reset()

# Reset statistics
self.events_processed = 0
self.start_time = None
self.end_time = None

# Re-setup event handlers
self._setup_event_handlers()


class BacktestResults:
"""Container for backtest results with analysis methods."""

def __init__(self, results: dict[str, Any]):
"""Initialize with results dictionary from BacktestEngine.

Args:
results: Results dictionary from engine.run()
"""
self.results = results
self.trades = results.get("trades", pl.DataFrame())
self.positions = results.get("positions", pl.DataFrame())
self.returns = results.get("returns", pl.Series())
self.metrics = results.get("metrics", {})

@property
def total_return(self) -> float:
"""Total return percentage."""
return self.results.get("total_return", 0.0)

@property
def sharpe_ratio(self) -> float:
"""Sharpe ratio of returns."""
return self.metrics.get("sharpe_ratio", 0.0)

@property
def max_drawdown(self) -> float:
"""Maximum drawdown percentage."""
return self.metrics.get("max_drawdown", 0.0)

@property
def win_rate(self) -> float:
"""Percentage of winning trades."""
if self.trades.is_empty():
return 0.0
winning = self.trades.filter(pl.col("pnl") > 0)
return len(winning) / len(self.trades) * 100

def summary(self) -> str:
"""Generate a text summary of results.

Returns:
Formatted summary string
"""
return f"""
Backtest Results Summary
========================
Total Return: {self.total_return:.2f}%
Sharpe Ratio: {self.sharpe_ratio:.2f}
Max Drawdown: {self.max_drawdown:.2f}%
Win Rate: {self.win_rate:.2f}%
Total Trades: {len(self.trades):,}
Events Processed: {self.results.get("events_processed", 0):,}
Duration: {self.results.get("duration_seconds", 0):.2f}s
""".strip()

def to_dict(self) -> dict[str, Any]:
"""Convert to dictionary for serialization.

Returns:
Dictionary of results
"""
return self.results

def save(self, path: str) -> None:
"""Save results to file.

Args:
path: Output file path (supports .parquet, .json, .html)
"""
if path.endswith(".parquet"):
# Save DataFrames to parquet
self.trades.write_parquet(path.replace(".parquet", "_trades.parquet"))
self.positions.write_parquet(path.replace(".parquet", "_positions.parquet"))
elif path.endswith(".json"):
# Save as JSON
import json

with open(path, "w") as f:
# Convert non-serializable objects
data = {
k: v if not isinstance(v, (pl.DataFrame, pl.Series)) else None
for k, v in self.results.items()
}
json.dump(data, f, indent=2, default=str)
elif path.endswith(".html"):
# Generate HTML report
from qengine.reporting.html import generate_html_report

html = generate_html_report(self)
with open(path, "w") as f:
f.write(html)
else:
raise ValueError(f"Unsupported file format: {path}")


__all__ = [
"BacktestEngine",
"BacktestResults",
]
</file>

<file path="README.md">
# QEngine

**Production-ready** event-driven backtesting engine for ML-driven trading strategies with architectural guarantees
against data leakage. All critical issues resolved (September 2025).

## Installation

```bash
# Development setup (from monorepo root)
make setup
make test-qng # Test qengine

# Or standalone
pip install -e .
```

## Quick Start

```python
import qengine as qe
from qengine.data import ParquetDataFeed
from qengine.strategy import Strategy

# Create strategy
class MomentumStrategy(Strategy):
def on_market_event(self, event, context):
# Access point-in-time safe data
if context.signals['momentum'] > 0.02:
self.submit_order(qe.MarketOrder("AAPL", 100, "BUY"))

# Run backtest
engine = qe.BacktestEngine(
data_feed=ParquetDataFeed("data.parquet"),
strategy=MomentumStrategy(),
initial_capital=100_000
)

results = engine.run()
print(f"Sharpe: {results.sharpe_ratio:.2f}, Return: {results.total_return:.1%}")
```

## Key Features

- **Event-Driven Core**: Point-in-time correctness with no data leakage
- **Temporal Accuracy**: Execution delay prevents lookahead bias (NEW)
- **Advanced Orders**: Market, Limit, Stop, Bracket with realistic execution
- **Execution Models**: Slippage (7 models), Commission (9 models), Market Impact
- **Multi-Asset Support**: Synchronized multi-feed data handling (NEW)
- **ML Integration**: Strategy adapters for sklearn/torch models
- **Performance**: 8,552 trades/sec, Polars-based, optional Numba JIT
- **Robust Execution**: No negative fills, proper cash constraints (NEW)
- **Validation**: 100% agreement with VectorBT, 159 unit tests

## Architecture

```
DataFeed  EventBus  Strategy  Orders  Broker  Fills  Portfolio
 
Clock (Time Control) Performance
```

**Core Components:**
- `EventBus`: Priority-queue event routing with ~100k events/sec
- `Clock`: Centralized time control preventing data leakage
- `Strategy`: Base class with lifecycle hooks (on_start, on_market_event, on_fill)
- `Broker`: Realistic order matching with slippage/impact models
- `Portfolio`: Position tracking, P&L, and metrics calculation

## Usage Examples

### Order Types & Execution
```python
# Orders with realistic execution and temporal accuracy
order = qe.LimitOrder("AAPL", 100, "BUY", limit_price=150.0)
broker = SimulationBroker(
slippage=LinearImpactSlippage(0.1),
commission=PercentageCommission(0.001), # 10bps
execution_delay=True # Prevents lookahead bias (default)
)
```

```python
class MLStrategy(qe.Strategy):
def on_event(self, event):
# Point-in-time safe ML predictions
if event.event_type == EventType.MARKET:
signal = self.get_signal(event.asset_id)
if signal > 0.6:
self.submit_order(qe.MarketOrder(event.asset_id, 100, "BUY"))
```

## QuantLab Integration

```python
# Future integration (in development)
from qfeatures import Pipeline
from qeval import PurgedWalkForwardCV

# Feature engineering  Model validation  Backtesting
features = Pipeline().fit_transform(data)
validated_model = qeval.validate(model, features)
results = qengine.backtest(validated_model, features)
```

## Recent Updates (September 2025)

**All Critical Issues Resolved** - QEngine is now production-ready:

-  **Event Flow Fixed**: Complete event routing from market data to portfolio
-  **Temporal Accuracy**: Execution delay prevents lookahead bias
-  **Multi-Feed Sync**: Stable ordering for multiple data feeds
-  **P&L Calculations**: Clarified for all asset classes (options, FX, crypto)
-  **Cash Constraints**: Robust handling prevents negative fill quantities
-  **Corporate Actions**: Integrated stock splits, dividends processing
-  **Test Coverage**: 159 tests including edge cases and integration

See [docs/DELIVERY_SUMMARY.md](docs/DELIVERY_SUMMARY.md) for detailed fix documentation.

## Development

See [CLAUDE.md](CLAUDE.md) for development guidelines, code standards, and contributing instructions.

## License

Apache License 2.0
</file>
