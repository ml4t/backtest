"""
Strategy-QEngine Integration Bridge
==================================

This module provides adapters that bridge external strategy implementations
to QEngine's event-driven architecture. It allows existing strategies to run
within QEngine and benefit from advanced execution models.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Callable

import polars as pl

from qengine.core.event import Event, FillEvent, MarketEvent
from qengine.core.types import AssetId, OrderSide, OrderType, Price
from qengine.execution.order import Order
from qengine.strategy.base import Strategy


@dataclass
class PITData:
    """Point-in-time data snapshot for strategy decision making."""

    timestamp: datetime
    asset_data: dict[AssetId, dict[str, Any]]
    market_prices: dict[AssetId, Price]

    def get_price(self, asset_id: AssetId) -> Price | None:
        """Get current price for asset."""
        return self.market_prices.get(asset_id)

    def get_data(self, asset_id: AssetId, field: str) -> Any:
        """Get specific field for asset."""
        return self.asset_data.get(asset_id, {}).get(field)


@dataclass
class StrategySignal:
    """Signal generated by external strategy."""

    timestamp: datetime
    asset_id: AssetId
    position: float  # Target position (-1 to 1, or absolute quantities)
    confidence: float = 0.0
    metadata: dict[str, Any] = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


class ExternalStrategyInterface(ABC):
    """
    Interface that external strategies must implement to integrate with QEngine.

    This defines the minimal API needed for QEngine integration.
    """

    @abstractmethod
    def generate_signal(
        self,
        timestamp: datetime,
        pit_data: PITData,
    ) -> StrategySignal | None:
        """
        Generate trading signal based on point-in-time data.

        Args:
            timestamp: Current timestamp
            pit_data: Point-in-time data snapshot

        Returns:
            Trading signal or None if no action needed
        """

    @abstractmethod
    def initialize(self) -> None:
        """Initialize strategy state."""

    @abstractmethod
    def finalize(self) -> None:
        """Cleanup strategy state."""


class StrategyAdapter(Strategy):
    """
    Base adapter that bridges external strategies to QEngine.

    This class handles the translation between QEngine's event-driven architecture
    and external strategy APIs.
    """

    def __init__(
        self,
        external_strategy: ExternalStrategyInterface,
        position_sizer: Callable[[StrategySignal, float], float] | None = None,
        risk_manager: Callable[[StrategySignal], bool] | None = None,
        name: str | None = None,
    ):
        """
        Initialize strategy adapter.

        Args:
            external_strategy: External strategy implementation
            position_sizer: Optional position sizing function
            risk_manager: Optional risk management function
            name: Strategy name
        """
        super().__init__(name=name or f"Adapter_{external_strategy.__class__.__name__}")
        self.external_strategy = external_strategy
        self.position_sizer = position_sizer or self._default_position_sizer
        self.risk_manager = risk_manager or self._default_risk_manager

        # State tracking
        self._data_history: dict[AssetId, list[dict]] = {}
        self._last_signals: dict[AssetId, StrategySignal] = {}
        self._target_positions: dict[AssetId, float] = {}
        self._pending_orders: dict[AssetId, list[Order]] = {}

    def on_start(self) -> None:
        """Initialize external strategy."""
        self.log("Starting strategy adapter")
        self.external_strategy.initialize()

    def on_end(self) -> None:
        """Cleanup external strategy."""
        self.log("Stopping strategy adapter")
        self.external_strategy.finalize()

    def on_event(self, event: Event) -> None:
        """Route events to appropriate handlers."""
        if isinstance(event, MarketEvent):
            self.on_market_event(event)
        elif isinstance(event, FillEvent):
            self.on_fill_event(event)

    def on_market_event(self, event: MarketEvent) -> None:
        """Process market event and generate signals."""
        try:
            # Update data history
            self._update_data_history(event)

            # Create point-in-time data snapshot
            pit_data = self._create_pit_data(event.timestamp)

            # Generate signal from external strategy
            signal = self.external_strategy.generate_signal(event.timestamp, pit_data)

            if signal:
                self._process_signal(signal)

        except Exception as e:
            self.log(f"Error processing market event: {e}", level="ERROR")

    def on_fill_event(self, event: FillEvent) -> None:
        """Update position tracking when fills occur."""
        super().on_fill_event(event)

        # Remove filled orders from pending
        if event.asset_id in self._pending_orders:
            self._pending_orders[event.asset_id] = [
                order
                for order in self._pending_orders[event.asset_id]
                if order.order_id != event.order_id
            ]

        self.log(f"Fill received: {event.asset_id} {event.fill_quantity} @ {event.fill_price}")

    def _update_data_history(self, event: MarketEvent) -> None:
        """Update historical data for strategy calculations."""
        if event.asset_id not in self._data_history:
            self._data_history[event.asset_id] = []

        data_point = {
            "timestamp": event.timestamp,
            "open": event.open,
            "high": event.high,
            "low": event.low,
            "close": event.close,
            "volume": event.volume,
        }

        self._data_history[event.asset_id].append(data_point)

        # Keep only last N points for memory efficiency
        if len(self._data_history[event.asset_id]) > 1000:
            self._data_history[event.asset_id] = self._data_history[event.asset_id][-500:]

    def _create_pit_data(self, timestamp: datetime) -> PITData:
        """Create point-in-time data snapshot."""
        asset_data = {}
        market_prices = {}

        for asset_id, history in self._data_history.items():
            if history:
                # Get most recent data up to timestamp
                valid_data = [d for d in history if d["timestamp"] <= timestamp]
                if valid_data:
                    latest = valid_data[-1]
                    asset_data[asset_id] = latest
                    market_prices[asset_id] = latest["close"]

        return PITData(
            timestamp=timestamp,
            asset_data=asset_data,
            market_prices=market_prices,
        )

    def _process_signal(self, signal: StrategySignal) -> None:
        """Process signal and submit orders if needed."""
        # Store last signal
        self._last_signals[signal.asset_id] = signal

        # Apply risk management
        if not self.risk_manager(signal):
            self.log(f"Signal rejected by risk manager: {signal.asset_id}", level="WARNING")
            return

        # Calculate position size
        current_cash = self.broker.get_cash() if hasattr(self.broker, "get_cash") else 100000
        position_size = self.position_sizer(signal, current_cash)

        # Get current position
        current_position = self._positions.get(signal.asset_id, 0)

        # Calculate required trade
        trade_quantity = position_size - current_position

        if abs(trade_quantity) > 0.001:  # Minimum trade threshold
            self._submit_rebalance_order(signal.asset_id, trade_quantity)

    def _submit_rebalance_order(self, asset_id: AssetId, quantity: float) -> None:
        """Submit order to rebalance to target position."""
        if abs(quantity) < 0.001:
            return

        # Determine order side
        side = OrderSide.BUY if quantity > 0 else OrderSide.SELL
        abs_quantity = abs(quantity)

        # Create market order for immediate execution
        order = Order(
            asset_id=asset_id,
            order_type=OrderType.MARKET,
            side=side,
            quantity=abs_quantity,
        )

        # Submit through broker
        if hasattr(self.broker, "submit_order"):
            order_id = self.broker.submit_order(order)

            # Track pending order
            if asset_id not in self._pending_orders:
                self._pending_orders[asset_id] = []
            self._pending_orders[asset_id].append(order)

            self.log(f"Order submitted: {order_id} - {side.value} {abs_quantity} {asset_id}")
        else:
            self.log("No broker available for order submission", level="ERROR")

    def _default_position_sizer(self, signal: StrategySignal, cash: float) -> float:
        """Default position sizing based on signal position and confidence."""
        # Use signal position directly, scaled by confidence
        base_position = signal.position * signal.confidence

        # Simple position sizing - use portion of cash based on signal
        if abs(base_position) > 0:
            position_value = cash * 0.1  # 10% of cash
            return base_position * position_value  # Signed position value

        return 0.0

    def _default_risk_manager(self, signal: StrategySignal) -> bool:
        """Default risk management - always allow signals."""
        # Basic checks
        if not signal.asset_id:
            return False
        if abs(signal.position) > 10:  # Sanity check on position size
            return False
        return True

    def get_strategy_state(self) -> dict[str, Any]:
        """Get current strategy state for debugging."""
        return {
            "name": self.name,
            "current_positions": self.current_positions,
            "target_positions": self._target_positions.copy(),
            "last_signals": {k: v.__dict__ for k, v in self._last_signals.items()},
            "pending_orders": {k: len(v) for k, v in self._pending_orders.items()},
            "data_history_lengths": {k: len(v) for k, v in self._data_history.items()},
        }


class DataFrameAdapter(StrategyAdapter):
    """
    Adapter for strategies that work with DataFrame-based data.

    This adapter maintains a rolling DataFrame of market data that can be
    accessed by external strategies for calculations.
    """

    def __init__(
        self,
        external_strategy: ExternalStrategyInterface,
        window_size: int = 1000,
        **kwargs,
    ):
        """
        Initialize DataFrame adapter.

        Args:
            external_strategy: External strategy implementation
            window_size: Size of rolling data window
            **kwargs: Additional arguments for StrategyAdapter
        """
        super().__init__(external_strategy, **kwargs)
        self.window_size = window_size
        self._dataframes: dict[AssetId, pl.DataFrame] = {}

    def _update_data_history(self, event: MarketEvent) -> None:
        """Update DataFrame with new market data."""
        # Call parent to maintain backward compatibility
        super()._update_data_history(event)

        # Create new row
        new_row = pl.DataFrame(
            {
                "timestamp": [event.timestamp],
                "asset_id": [event.asset_id],
                "open": [event.open],
                "high": [event.high],
                "low": [event.low],
                "close": [event.close],
                "volume": [event.volume],
            },
        )

        # Update or create DataFrame
        if event.asset_id not in self._dataframes:
            self._dataframes[event.asset_id] = new_row
        else:
            self._dataframes[event.asset_id] = pl.concat(
                [
                    self._dataframes[event.asset_id],
                    new_row,
                ],
            )

            # Maintain window size
            if len(self._dataframes[event.asset_id]) > self.window_size:
                self._dataframes[event.asset_id] = self._dataframes[event.asset_id].tail(
                    self.window_size,
                )

    def get_dataframe(self, asset_id: AssetId) -> pl.DataFrame | None:
        """Get DataFrame for asset."""
        return self._dataframes.get(asset_id)

    def get_all_dataframes(self) -> dict[AssetId, pl.DataFrame]:
        """Get all DataFrames."""
        return self._dataframes.copy()
